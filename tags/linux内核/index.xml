<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux内核 on 讲故事的人</title>
        <link>https://drawing.fancymore.com/tags/linux%E5%86%85%E6%A0%B8/</link>
        <description>Recent content in Linux内核 on 讲故事的人</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 10 Jun 2014 01:16:33 +0800</lastBuildDate><atom:link href="https://drawing.fancymore.com/tags/linux%E5%86%85%E6%A0%B8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>overcommit 对 fork 的影响</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/redis-failed-when-out-of-memory/</link>
        <pubDate>Tue, 10 Jun 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/redis-failed-when-out-of-memory/</guid>
        <description>&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;
&lt;p&gt;线上的一个服务使用Redis作为中转队列，今天读写队列操作突然错误，相关功能处于不可用状态，错误显示读队列时返回异常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RDB 是 Redis 持久化数据的一种方式，其主要原理就是在某个时间点把内存中的所有数据的快照保存一份到磁盘上。在条件达到时通过fork一个子进程把内存中的数据写到一个临时文件中来实现保存数据快照。&lt;/p&gt;
&lt;p&gt;查看 Redis 的日志发现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:11.059 * 1 changes in 900 seconds. Saving...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:11.060 # Can&amp;#39;t save in background: fork: Cannot allocate memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:17.067 * 1 changes in 900 seconds. Saving...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:17.068 # Can&amp;#39;t save in background: fork: Cannot allocate memory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;原因&#34;&gt;原因&lt;/h1&gt;
&lt;p&gt;看到问题应该是由于fork出来一个进程后台持久化数据，由于内存不足导致fork失败，当Redis持久化失败时，设置当前为禁写的状态（读队列会删除元素，也算写操作）。使用info查看Redis状态，&lt;code&gt;rdb_last_bgsave_status&lt;/code&gt;显示为 err。此时即使重新设置状态为ok也无用，因为很快就会下一轮fork，状态会被重置。&lt;/p&gt;
&lt;h1 id=&#34;overcommit&#34;&gt;overcommit&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://redis.io/topics/faq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;有相关信息，需要设置&lt;code&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory&lt;/code&gt;，查阅&lt;a class=&#34;link&#34; href=&#34;http://www.win.tue.nl/~aeb/linux/lk/lk-9.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux Memory &lt;/a&gt;发现，&lt;code&gt;overcommit_memory&lt;/code&gt; 指定了Linux内存分配的策略。可选值：0，1，2。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。&lt;/li&gt;
&lt;li&gt;1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。&lt;/li&gt;
&lt;li&gt;2：表示内核允许分配超过所有物理内存和交换空间总和的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体什么含义呢？当使用malloc等函数，向系统申请内存时，一种情况是有可用内存时返回成功，无可用内存时返回失败&lt;code&gt;NULL&lt;/code&gt;，另一种情况是都返回成功，以便能运行更大的程序，因为申请内存后，可能不会立即使用，当使用时发现内存不足时，会发生OOM killer，它会选择杀死一些进程（用户态进程，不是内核线程），以便释放内存。选择进程的函数是&lt;code&gt;oom_badness&lt;/code&gt;函数(在&lt;code&gt;mm/oom_kill.c&lt;/code&gt;中)，该函数会计算每个进程的点数(0~1000)。点数越高，这个进程越有可能被杀死。每个进程的点数跟&lt;code&gt;oom_score_adj&lt;/code&gt;有关，而且&lt;code&gt;oom_score_adj&lt;/code&gt;可以被设置(-1000最低，1000最高)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;overcommit_memory&lt;/code&gt;的三种状态分别表示为三种&lt;code&gt;overcommit&lt;/code&gt;策略(&lt;code&gt;Documentation/vm/overcommit-accounting&lt;/code&gt;)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：启发式策略。合理的overcommit会被接受，不合理的overcommit会被拒绝。&lt;/li&gt;
&lt;li&gt;1：任何overcommit都会被接受。&lt;/li&gt;
&lt;li&gt;2：当系统分配的内存超过&lt;code&gt;swap+N%*物理RAM&lt;/code&gt;(N%由&lt;code&gt;vm.overcommit_ratio&lt;/code&gt;决定)时，会拒绝commit。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;overcommit 的策略通过&lt;code&gt;vm.overcommit_memory&lt;/code&gt;设置
overcommit的百分比由&lt;code&gt;vm.overcommit_ratio&lt;/code&gt;设置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;overcommit_memory&lt;/code&gt;设置为0时，Redis fork Linux会假定子进程占用同样多的内存空间（根据实际映射的物理内存决定），如果free空间不足，会发生错误导致无法正常fork。&lt;/p&gt;
&lt;h1 id=&#34;复盘&#34;&gt;复盘&lt;/h1&gt;
&lt;p&gt;复盘一下发现：写入量过大，导致fork时内存不足，fork失败，Redis这种情况下会切换成紧写的状态。导致Redis不可用，如果设置 &lt;code&gt;overcommit_memory&lt;/code&gt; 为1，看到Redis上一次dump数据花费了60s左右，内存使用12G，每条数据大小500字节左右，60s时间队列读取速度为4M，基本上相当于2G数据量，可以看到变化的数据有20%不到，根据写时复制的原则，fork就不会有问题了。&lt;/p&gt;
&lt;p&gt;不过Redis作为队列，在消息流动比较大，而且消息时效性比较强的情况下，可以禁用数据持久化功能，提升效率。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-进程调度</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-process-sched/</link>
        <pubDate>Fri, 23 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-process-sched/</guid>
        <description>&lt;p&gt;现代操作系统都可以同时运行若干进程，对于单核CPU，给定时刻只会有一个进程运行，CPU快速的在各个进程中切换，给用户以多个进程同时运行的错觉，对于多核CPU，可以真正并发运行多个进程，取决于CPU的数目。&lt;/p&gt;
&lt;p&gt;内核在各个进程切换过程中，必须做到进程之间不能互相干扰，而且需要CPU时间必须在各种应用程序中尽可能公平的共享，进程管理和调度有两个主要任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核决定各个进程分配多长时间，何时切换到下一个进程；&lt;/li&gt;
&lt;li&gt;进程从A切换到B时，需要确保进程B的执行环境与上一次撤销其处理资源时完全相同；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个任务称之为调度器的内核子系统的职责。&lt;/p&gt;
&lt;h1 id=&#34;进程生命周期&#34;&gt;进程生命周期&lt;/h1&gt;
&lt;p&gt;进程不是总是可以立即运行，有时必须等待外部信号，在信号发生时进程无法运行。当调度器在进程之间切换时，必须知道系统中每个进程的状态。进程可能有以下几种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行：进程正在运行&lt;/li&gt;
&lt;li&gt;等待：进程能够运行，但没有分到时间片，调度器下一次可以选择此进程&lt;/li&gt;
&lt;li&gt;睡眠：进程正在睡眠无法运行，正在等待外部事件&lt;/li&gt;
&lt;li&gt;僵尸：进程资源已经释放，但还保留进程表中的项&lt;/li&gt;
&lt;li&gt;终止：进程退出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux进程管理还需另外两种状态选项：用户状态和核心态。用户态受到各种限制，内核态却有无上的权利。进程通常处于用户状态，只能访问自身数据，无法干扰其他进程。如果进程想要访问系统数据或者功能，必须切换到核心态，用户态切换到核心态有两种方法，第一种是系统调用(系统调用)[/reading/linux-kernel-system-call.html]，另一种是通过中断。内核的抢占调度模型建立了一个层次结构，用户判断哪些进程状态可以由其他状态抢占。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通进程总是可能被抢占&lt;/li&gt;
&lt;li&gt;如果进程处于核心态并在处理系统调用，那么其他进程是无法抢占，但中断可以终止系统调用&lt;/li&gt;
&lt;li&gt;中断可以暂停出于用户状态和核心态的进程，中断有最高优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核有一个内核抢占的选项，支持紧急情况下切换到另一个进程，甚至当前处于核心态执行系统调用。&lt;/p&gt;
&lt;h1 id=&#34;进程表示&#34;&gt;进程表示&lt;/h1&gt;
&lt;p&gt;Linux内核涉及进程和进程所有算法都围绕一个名为 &lt;code&gt;task_struct&lt;/code&gt; 的数据结构建立，该结构定义在 &lt;code&gt;include/sched.h&lt;/code&gt; 中，这是系统中重要的一个结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 结构复杂，要想都搞清楚着实不易，但该结构可以分为各个部分，每个部分表示进程的不同方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态和执行信息：如待定信号，进程ID（pid），父进程及其他有关进程的指针，优先级和程序执行有关的信息&lt;/li&gt;
&lt;li&gt;有关分配的虚拟内存信息&lt;/li&gt;
&lt;li&gt;进程身份凭据，如用户ID，组ID及权限&lt;/li&gt;
&lt;li&gt;使用的文件包含程序代码的二进制文件，以及进程所处理的所有文件的文件系统信息&lt;/li&gt;
&lt;li&gt;线程信息记录该进程特定于CPU的运行时间数据&lt;/li&gt;
&lt;li&gt;在与其他应用程序协作时所需的进程间通信有关的信息&lt;/li&gt;
&lt;li&gt;该进程所用的信号处理程序，用于响应到来的信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 的许多成员并非简单类型变量，而是其他数据结构的指针。下面介绍一些结构的重要数据成员。&lt;/p&gt;
&lt;h2 id=&#34;当前状态-state&#34;&gt;当前状态 state&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt;指定了当前状态，可以使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TASK_RUNNING&lt;/code&gt;：进程处于可运行状态，这并不意味着实际分配了CPU，进程可能会一直等到调度器选中它&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;：针对等待某事件或其他资源的睡眠进程设置的。在内核发送信号给进程表明事件已经发生，进程状态变为 &lt;code&gt;TASK_RUNNING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt;：用于因内核指示而停用的睡眠进程，他们不能由外部信号唤醒，只能由内核亲自唤醒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_STOPPED&lt;/code&gt;：表示进程特意停止运行，例如由调度器暂停&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_TRACED&lt;/code&gt;：本来不是进程状态，用于从停止的进程中，将当前被调试的那些与常规的进程区分开&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面常量可以用于&lt;code&gt;struct task_struct&lt;/code&gt;进程状态字段，也可以用于&lt;code&gt;exit_state&lt;/code&gt;字段，后者明确地用于退出进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXIT_ZOMBIE&lt;/code&gt;：僵尸进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXIT_DEAD&lt;/code&gt;：状态则是指&lt;code&gt;wait&lt;/code&gt;系统调用已经发出，而进程完全从系统移除之前的状态，只有多个线程对同一个进程发出&lt;code&gt;wait&lt;/code&gt;调用时，才有意义&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;资源限制-rlimit&#34;&gt;资源限制 rlimit&lt;/h2&gt;
&lt;p&gt;Linux提供资源限制功能，该机制利用了&lt;code&gt;task_struct&lt;/code&gt;中的 rlim 数组，数组项类型为 &lt;code&gt;struct rlimit&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rlimit&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;rlim_cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;rlim_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述定义可以用于多种不同的资源类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rlim_cur&lt;/code&gt;：是进程当前资源限制，也称之为软限制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rlim_max&lt;/code&gt;：是该限制的最大容许值，称之为硬限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统调用&lt;code&gt;setrlimit&lt;/code&gt;来增减当前限制，但不能超过&lt;code&gt;rlim_max&lt;/code&gt;指定的值。&lt;code&gt;rlim&lt;/code&gt;数组中的位置标志了受限资源的类型，这也是内核需要定义的处理器常数，将资源与位置关联起来的原因。如果某一类资源没有限制，则将&lt;code&gt;rlim_max&lt;/code&gt;设置为&lt;code&gt;RLIM_INFINITY&lt;/code&gt;。以下是几种宏定义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;常数&lt;/th&gt;
&lt;th&gt;语义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_CPU&lt;/td&gt;
&lt;td&gt;按毫秒计算的最大CPU时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_FSIZE&lt;/td&gt;
&lt;td&gt;允许的最大文件长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_DATA&lt;/td&gt;
&lt;td&gt;数据段的最大长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_STACK&lt;/td&gt;
&lt;td&gt;（用户态）栈最大长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_CORE&lt;/td&gt;
&lt;td&gt;内存转储文件最大长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_NOFILE&lt;/td&gt;
&lt;td&gt;打开文件最大数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_SIGPENDING&lt;/td&gt;
&lt;td&gt;待决信号的最大数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RLIMIT_MSGQUEUE&lt;/td&gt;
&lt;td&gt;信息队列最大数目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在&lt;code&gt;proc&lt;/code&gt;文件系统中，可以从文件&lt;code&gt;/proc/self/limits&lt;/code&gt;查看当前&lt;code&gt;rlimit&lt;/code&gt;限制。&lt;/p&gt;
&lt;h2 id=&#34;进程类型&#34;&gt;进程类型&lt;/h2&gt;
&lt;p&gt;典型的UNIX进程包括：由二进制代码组成的应用程序、单线程、分配给应用程序的一组资源。新进程是由&lt;code&gt;fork&lt;/code&gt;和&lt;code&gt;exec&lt;/code&gt;系统调用完成的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork 生成当前进程的一个相同副本，成为子进程。&lt;/li&gt;
&lt;li&gt;exec 从一个可执行文件加载另一个应用程序，来代替当前运行的进程。&lt;/li&gt;
&lt;li&gt;clone 工作原理基本与fork相同，但新进程不是独立于父进程的，可以与其共享某些资源，如父进程的内存数据等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;clone&lt;/code&gt; 用于实现线程，但仅仅系统调用还不能做到这点，还需要用户空间库才能提供完整实现，如Linuxthreads和Next Generation Posix Threads等。&lt;/p&gt;
&lt;h2 id=&#34;命名空间&#34;&gt;命名空间&lt;/h2&gt;
&lt;p&gt;命名空间提供了虚拟化的一种轻量级形式，传统上，在Linux以及其他衍生的UINX扁蹄中，许多资源是全局管理的，例如系统中的所有进程按照惯例都是通过PID标识的，这意味着内核必须管理一个全局的PID列表，而且，所有调用者通过uname系统调用返回的系统相关信息都是相同的。用户的管理方式相同，即各个用户是通过一个全局唯一的UID号标识。&lt;/p&gt;
&lt;p&gt;有些情况下，如提供Web主机的提供商给每个用户提供Linux计算机全部访问权限，包括root权限在内，传统上，要为每个用户准备一台计算机，代价很高，使用KVM虚拟机是另一种办法，但资源分配做的不是很好，计算机各个用户都需要一个独立的内核，以及一份完全安装好的用户层应用。&lt;/p&gt;
&lt;p&gt;命名空间提供了一种不同的解决方案，所需资源较少，命令空间只使用一个内核，前述的所有全局资源都通过命令空间抽象起来，这使得可以将一组进程放置到容器中，各个容器彼此隔离，隔离可以使得容器的成员与其他容器毫无关系，但也可以通过允许容器进程一定的共享，来降低容器之间的间隔。例如，容器可以设置为使用自身的PID集合，但仍然与其他容器共享部分文件系统。&lt;/p&gt;
&lt;p&gt;Linux 系统对简单形式的命令空间的支持已经有很长时间了，主要是chroot系统调用，该方法可以将进程限制到文件系统的某一部分。因而是一种简单的命名空间机制，但真正的命名空间能够控制的功能远超文件系统视图。&lt;/p&gt;
&lt;p&gt;新命令空间可以用两种方法创建：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork 或 clone 系统调用创建新进程时，有特定选项可以控制是与父进程共享命名空间，还是建立新的命名空间&lt;/li&gt;
&lt;li&gt;unshare 系统调用将进程的某些部分从父进程分离，其中也包括命名空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在通过上述两种方式从父进程命名空间分离后，从该进程角度看，改变全局属性不会传播到父进程命名空间，而父进程修改也不会传播到子进程。&lt;/p&gt;
&lt;p&gt;命名空间的实现需要两个部分：每个子系统的命名空间结构，将此前所有的全局组建包装的命名空间中；将给定进程关联到所属各个命名空间的机制。&lt;/p&gt;
&lt;p&gt;子系统此前的全局属性现在封装到命名空间中，每个进程关联到一个选定的命名空间，每个可以感知命名空间的内核子系统都必须提供一个数据结构，将所有通过命名空间形式提供的对象集中起来。&lt;code&gt;struct nsproxy&lt;/code&gt;用户汇集指向特定于子系统的命名空间包装器的指针：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nsproxy&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;atomic_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uts_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uts_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ipc_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ipc_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mnt_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mnt_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;net&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;net_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当前内核的以下范围可以感知到命名空间：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UTS（UNIX Timesharing System）命名空间包含了运行内核的名称、版本、底层体系结构类型等信息&lt;/li&gt;
&lt;li&gt;保存在&lt;code&gt;struct ipc_namespace&lt;/code&gt; 中的所有与进程间通信IPC有关信息&lt;/li&gt;
&lt;li&gt;已经装载的文件系统的视图，在&lt;code&gt;struct mnt_namespace&lt;/code&gt;中给出&lt;/li&gt;
&lt;li&gt;有关进程ID的信息，由&lt;code&gt;struct pid_namespace&lt;/code&gt;提供&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct net_ns&lt;/code&gt; 包含所有网络相关的命名空间参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 结构成员 &lt;code&gt;struct nsproxy *nsproxy&lt;/code&gt;保存关联到自身的命名空间视图。因为使用指针，多个进程可以共享一组名字空间，这样，修改给定的命名空间，对所有属于该命名空间的进程都是可见的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;init_nsproxy&lt;/code&gt;定义了初始的全局命名空间，其中维护了指向各子系统初始的命名空间对象的指针：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nsproxy&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init_nsproxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ATOMIC_INIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uts_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_uts_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ipc_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_ipc_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mnt_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_pid_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#ifdef CONFIG_NET
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;net_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;进程id号&#34;&gt;进程ID号&lt;/h2&gt;
&lt;p&gt;UNIX进程总会分配一个号码用于在命令空间中唯一的标志它们，该号码被称作PID。用fork和clone产生的每个进程都会由内核自动地分配唯一的新的PID值。&lt;/p&gt;
&lt;p&gt;进程除了PID这个值还有其他的ID，有下列几种可能的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处于某个线程组中的所有统一的线程组ID（TGID），如果进程没有使用线程，则PID和TGID相同，线程组中的主进程被称作组长。通过clone组建的所有线程&lt;code&gt;task_struct&lt;/code&gt;的&lt;code&gt;group_leader&lt;/code&gt;成员，会指向组长的&lt;code&gt;task_struct&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;独立进程可以组成进程组（&lt;code&gt;setpgrp&lt;/code&gt;系统调用），进程组成员的&lt;code&gt;task_struct&lt;/code&gt;成员&lt;code&gt;pgrp&lt;/code&gt;属性都相同，即组长PID。&lt;/li&gt;
&lt;li&gt;几个进程组可以合并成一个会话。会话中所有进程都有相同的会话ID，保存在&lt;code&gt;task_struct&lt;/code&gt;的&lt;code&gt;session&lt;/code&gt;成员中。SID可以使用&lt;code&gt;setsid&lt;/code&gt;系统调用设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程关系&#34;&gt;进程关系&lt;/h2&gt;
&lt;p&gt;除了源于ID连接的关系外，内核还负责管理建立在UNIX进程创建模型之上的家族关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果进程A分支形成进程B，进程A称之为父进程二进程B是子进程&lt;/li&gt;
&lt;li&gt;如果进程B再次分支建立进程C，进程A和进程C之间称之为祖孙关系&lt;/li&gt;
&lt;li&gt;如果进程A分支若干次形成B1，B2&amp;hellip; 各个B进程之间成为兄弟进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 数据结构提供了两个链表表头，用于实现这些关系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;children&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sibling&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;进程管理相关的系统调用&#34;&gt;进程管理相关的系统调用&lt;/h1&gt;
&lt;h2 id=&#34;进程复制&#34;&gt;进程复制&lt;/h2&gt;
&lt;p&gt;Linux内核提供三个函数复制进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt;：这是重量级调用，因为它提供了一个完整副本，然后作为子进程执行，为减少调用相关的工作量，Linux使用了写时复制（copy-on-write）技术&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vfork&lt;/code&gt;：类似fork，但并不创建父进程数据副本，相反，父子进程之间共享数据，这节省了大量CPU时间，vfork设计用于子进程执行execve系统调用加载新程序的情况，但由于fork函数实现了写时复制功能，所以vfork在性能方面不再有优势，应避免使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clone&lt;/code&gt; 产生线程，可以对父子进程之间的共享、复制进行精确控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;写时复制&#34;&gt;写时复制&lt;/h2&gt;
&lt;p&gt;内核使用写时复制技术，以防止在&lt;code&gt;fork&lt;/code&gt;执行时将父进程的所有数据复制到子进程，该技术利用了下述事实，进程通常只使用了其内存页的一小部分，在调用&lt;code&gt;fork&lt;/code&gt;时，内核通常会复制父进程的每个内存页，这样有两个不好的负面效应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了大量的内存&lt;/li&gt;
&lt;li&gt;复制操作耗费很长时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果应用程序在进程复制之后使用&lt;code&gt;exec&lt;/code&gt;立即加载程序，那么负面效应会更严重。这意味着，此前复制操作是完全多余的。内核可以使用技巧来规避这个问题，并不复制整个地址空间，而是复制其页表，这样建立了虚拟地址和物理内存页之间的联系。&lt;code&gt;fork&lt;/code&gt;之后父子进程地址空间指向相同的物理内存页。&lt;/p&gt;
&lt;p&gt;这时父子进程不能修改彼此的页，这也是两个进程页表对其标志了只读的原因。如果两个进程只读内存页，二者共享空间不会有问题，只要有一个进程试图向复制的内存页写入，处理器会向内核报告缺页异常。内核查看额外的内存管理数据结构，如果是COW页，内核会创建当前进程的副本。这里的实现需要了解内存管理方面的知识。&lt;/p&gt;
&lt;p&gt;COW机制使得内核尽可能延迟内存页复制，当然大多数情况下，可能都不需要复制，节省了大量的时间。&lt;/p&gt;
&lt;h2 id=&#34;执行系统调用&#34;&gt;执行系统调用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;,&lt;code&gt;vfork&lt;/code&gt;,&lt;code&gt;clone&lt;/code&gt;系统调用的入口分别是&lt;code&gt;sys_fork&lt;/code&gt;,&lt;code&gt;sys_vfork&lt;/code&gt;,&lt;code&gt;sys_clone&lt;/code&gt;函数。其定义依赖于具体的体系结构。上述函数任务是从处理器寄存器中提取用户空间提供的信息，调用体系结构无关的&lt;code&gt;do_fork&lt;/code&gt;函数，后者负责进程复制。函数原型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// kernel/fork.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clone_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stack_start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stack_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent_tidptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;child_tidptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clone_flags&lt;/code&gt; 是一个标志集合，用来指定控制复制过程中的一些属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_stack&lt;/code&gt; 是用户状态下栈的起始地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;regs&lt;/code&gt; 是一个指向寄存器集合的指针，其中以原始形式保存了调用参数。该参数使用的数据类型是特定于体系结构的&lt;code&gt;struct pt_regs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack_size&lt;/code&gt; 是用户状态下栈的大小，通常没有必要，设置为0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parent_tidptr&lt;/code&gt;和&lt;code&gt;child_tidptr&lt;/code&gt; 是指向用户空间中地址的两个指针，分别指向父子进程的TID，NPTL（Native Posix Threads Library）库的线程实现需要这两个参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的fork变体，主要是通过标志集合区分，多数体系结构上，典型的fork调用实现方式于IA-32处理器相同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// arch/x86/kernel/process.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sys_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SIGCHLD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用的唯一标志是 SIGCHLD，这意味着在子进程终止后发送 SIGCHLD 信号通知父进程。如果&lt;code&gt;do_fork&lt;/code&gt;成功，则新建进程的PID作为系统调用的结果返回，否则返回负值错误码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sys_vfork&lt;/code&gt;的实现与&lt;code&gt;sys_fork&lt;/code&gt;只是略微不同，前者使用了额外的标志&lt;code&gt;CLONE_VFORK&lt;/code&gt;和&lt;code&gt;CLONE_VM&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sys_clone&lt;/code&gt;的实现方式与上述调用相似，差别在于&lt;code&gt;do_fork&lt;/code&gt;调用如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// arch/x86/kernel/process_32.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sys_clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clone_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;child_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clone_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;child_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标志不再是硬编码，可以通过各个寄存器参数传递到系统调用。而且，也不再复制父进程的栈，可以指定新的栈地址。&lt;/p&gt;
&lt;h2 id=&#34;do_fork-的实现&#34;&gt;do_fork 的实现&lt;/h2&gt;
&lt;p&gt;所有三个fork机制最终都调用了&lt;code&gt;do_fork&lt;/code&gt;，其代码流程如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;do_fork
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- copy_process
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 确定PID
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 初始化vfork的完成处理程序
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- wake_up_new_task
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 是否设置了CLONE_VFORK 标志 -&amp;gt; wait_for_completion
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;do_fork&lt;/code&gt;以调用&lt;code&gt;copy_process&lt;/code&gt;开始，后者执行生成新进程的实际工作，根据指定标志重用父进程的数据，子进程生成之后，内核必须执行以下收尾操作：&lt;/p&gt;
&lt;p&gt;进程复制&lt;code&gt;do_fork&lt;/code&gt;实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;copy_process&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;检查标志&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dup_task_struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;检查资源限制&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;初始化&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sched_fork&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;复制进程各个部分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_semundo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_files&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_fs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_sighand&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_signal&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_mm&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_namespaces&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_thread&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;设置各个&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ID&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、进程关系&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;复制进程的行为受到相当多的标志的控制，clone(2) 的手册详细讲述了这些标志，标志可以参考手册。该函数也需要做一些错误判断，Linux函数有时候会在成功的时候返回结构体指针，失败的情况下返回错误码，但函数只能返回一个值，所以Linux做了一个特殊处理，虽然一般而言指针可以指向内存任何位置，而Linux支持的每个体系结构的虚拟地址从0到4Kib的区域，该区域没有任何有意义的信息，因此内核可以重用此地址范围来编码错误。&lt;/p&gt;
&lt;p&gt;当检查完标志后，使用&lt;code&gt;dup_task_struct&lt;/code&gt;来建立父进程&lt;code&gt;task_struct&lt;/code&gt;的副本，父进程的&lt;code&gt;task_struct&lt;/code&gt;实例只有一个成员不同，新进程分配了一个新的核心态，即&lt;code&gt;task_struct-&amp;gt;stack&lt;/code&gt;。通常栈和&lt;code&gt;thread_info&lt;/code&gt;一同保存在一个联合之中，&lt;code&gt;thread_info&lt;/code&gt;保存了线程所需的所有特定于处理器的底层信息。&lt;/p&gt;
&lt;h2 id=&#34;内核线程&#34;&gt;内核线程&lt;/h2&gt;
&lt;p&gt;内核线程是直接由内核本身启动的进程，内核线程实际上是将内核函数委托给独立的进程，内核线程经常称之为守护线程，用于执行下列任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;周期性的修改内存页与页来源块设备同步&lt;/li&gt;
&lt;li&gt;如果内存页很少使用，写入交换区&lt;/li&gt;
&lt;li&gt;管理延迟动作&lt;/li&gt;
&lt;li&gt;实现文件系统的事务日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上，有两种类型的内核线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程启动后一直等待，直至内核请求线程执行某一特定操作&lt;/li&gt;
&lt;li&gt;线程启动后按周期性间隔运行，检测特定资源的使用，在用量超出或低于预期的限制时采取行动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用&lt;code&gt;kernel_thread&lt;/code&gt;函数可启动一个内核线程，定义是特定于体系结构的，但原型总是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kernel_thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;产生的线程将执行用fn指针传递的函数，用arg指定的参数自动传个fn，flags可指定CLONE标志。&lt;code&gt;kernel_thread&lt;/code&gt;第一个任务是构建一个&lt;code&gt;pt_regs&lt;/code&gt;实例，对其中的寄存器指定适当的值，这与普通的&lt;code&gt;fork&lt;/code&gt;类似，接下来调用&lt;code&gt;do_fork&lt;/code&gt;函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CLONE_VM&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CLONE_UNTRACED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;内核线程可以用两种方法实现，古老的方法内核中一些地方仍然在使用该方法，将一个函数直接传递给&lt;code&gt;kernel_thread&lt;/code&gt;，该函数接下来负责帮助内核调用&lt;code&gt;daemonize&lt;/code&gt;以转换为守护进程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该函数从内核线程释放其父进程的所有资源，不然这些资源会一直锁定到线程结束。这是不可取的，因为守护线程通常运行到系统关机，因为守护进程只操作内核地址区域。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;daemonize&lt;/code&gt; 阻塞信号的接收。&lt;/li&gt;
&lt;li&gt;将init用作守护进程的父进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核线程的现代方法是辅助函数&lt;code&gt;kthread_create&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kthread_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threadfn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;namefmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;p&#34;&gt;...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改函数创建一个新的内核线程，其名称由&lt;code&gt;namefmt&lt;/code&gt;给出，最初该线程是停止的，需要使用&lt;code&gt;wake_up_process&lt;/code&gt;启动它，此后，会调用threadfn给出的线程函数，而data则作为参数。&lt;/p&gt;
&lt;p&gt;另一个备选方案是宏&lt;code&gt;kthread_run&lt;/code&gt;，它会调用&lt;code&gt;kthread_create&lt;/code&gt;创建新线程，但立即唤醒它，还可使用&lt;code&gt;kthread_create_cpu&lt;/code&gt;代替&lt;code&gt;kthread_create&lt;/code&gt;创建内核线程，使之绑定到特定的CPU。&lt;/p&gt;
&lt;p&gt;内核线程会出现在系统进程列表中，在ps的输出中由放括号包围，以便与普通进程区分。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cppbreak@ThinkPad:~$ ps fax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  PID TTY      STAT   TIME COMMAND
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    2 ?        S      0:00 [kthreadd]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    3 ?        S      0:00  \_ [ksoftirqd/0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    6 ?        S      0:02  \_ [migration/0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    7 ?        S      0:00  \_ [watchdog/0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    8 ?        S      0:00  \_ [migration/1]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    9 ?        S      0:00  \_ [kworker/1:0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   10 ?        S      0:00  \_ [ksoftirqd/1]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   12 ?        S      0:00  \_ [watchdog/1]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   13 ?        S      0:01  \_ [migration/2]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;启动新程序-execve&#34;&gt;启动新程序 execve&lt;/h2&gt;
&lt;p&gt;Linux 通过用新代码替换现存程序，即可启动新程序。Linux提供的 &lt;code&gt;execve&lt;/code&gt; 系统调用可实现此功能。该函数的入口点是体系相关的&lt;code&gt;sys_execve&lt;/code&gt; 函数，该函数把具体的工作委托给&lt;code&gt;do_execve&lt;/code&gt;实现具体功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_execve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__envp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里不仅用参数传递了寄存器集合和可执行文件的名称filename，而且还传递了指向程序的参数和环境指针。这里argv和envp都是指针数组，而且指向用户空间，&lt;code&gt;__user&lt;/code&gt;注释允许自动化工具检测是否所有处理都正确。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;do_execve&lt;/code&gt; 代码执行流程如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;do_execv
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 打开可执行文件
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- bprm_init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                |----- mm_alloc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                |----- init_new_context
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                |----- __bprm_mm_init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- prepare_binprm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 复制环境和参数数组内容
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- search_binary_handler
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先要打开可执行文件，换言之，内核找到相关的inode并生成一个文件描述符，用于寻址文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bprm_init&lt;/code&gt;接下来处理若干管理性任务：&lt;code&gt;mm_alloc&lt;/code&gt;生成一个新的&lt;code&gt;mm_struct&lt;/code&gt;实例来管理进程地址空间。&lt;code&gt;init_new_context&lt;/code&gt;是一个特定于体系结构的函数，用于初始化该实例，而&lt;code&gt;__bprm_mm_init&lt;/code&gt;则建立初始化的栈。&lt;/p&gt;
&lt;p&gt;新进程的各个参数，例如euid，egid，参数列表，环境等等，这里会合并成一个类型为&lt;code&gt;linux_binprm&lt;/code&gt;的结构，&lt;code&gt;prepare_binprm&lt;/code&gt;用于提供一些父进程相关的值，特别是 UID 和 GID。&lt;/p&gt;
&lt;p&gt;Linux 支持可执行文件的各种不同组织格式，标准格式是ELF。Linux还支持其他不同的二进制格式，通过函数&lt;code&gt;search_binary_handler&lt;/code&gt;在&lt;code&gt;do_execve&lt;/code&gt;结束时查找一种适当的二进制格式。各种格式根据不同特点（文件开始时的“魔数”）识别。二进制格式处理程序执行以下操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;释放原进程所使用的所有资源&lt;/li&gt;
&lt;li&gt;将应用程序映射到虚拟地址空间中。
&lt;ul&gt;
&lt;li&gt;text段包含程序的可执行代码，&lt;code&gt;start_code&lt;/code&gt;和&lt;code&gt;end_code&lt;/code&gt;指定该段在地址空间中驻留的区域&lt;/li&gt;
&lt;li&gt;预先初始化的数据，位于&lt;code&gt;start_data&lt;/code&gt;和&lt;code&gt;end_data&lt;/code&gt;之间，映射自可执行文件对应段&lt;/li&gt;
&lt;li&gt;堆用户动态内存分配，置于虚拟地址空间中，&lt;code&gt;start_brk&lt;/code&gt;和&lt;code&gt;brk&lt;/code&gt;指定了其边界&lt;/li&gt;
&lt;li&gt;栈的位置由&lt;code&gt;start_stack&lt;/code&gt;定义，大多数计算机的栈都是自动向下增长&lt;/li&gt;
&lt;li&gt;程序的参数和环境也映射到虚拟地址空间中，分别位于&lt;code&gt;arg_start&lt;/code&gt;和&lt;code&gt;arg_end&lt;/code&gt;之间，以及&lt;code&gt;env_start&lt;/code&gt;和&lt;code&gt;env_end&lt;/code&gt;之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设置进程的指令指针和其他特定于体系结构的寄存器，以便在调度器选择该进程时开始执行程序的main函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux内核中，每种二进制格式都表示为下列数据结构的一个实例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linux_binfmt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load_binary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linux_binprm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load_shlib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;core_dump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;coredump_params&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cprm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min_coredump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/* minimal dump size */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;linux支持的部分二进制格式有&lt;code&gt;flat_format&lt;/code&gt;, &lt;code&gt;script_format&lt;/code&gt;, &lt;code&gt;misc_format&lt;/code&gt;, &lt;code&gt;elf_format&lt;/code&gt;, &lt;code&gt;elf_fdpic_format&lt;/code&gt;, &lt;code&gt;irix_format&lt;/code&gt;, &lt;code&gt;som_format&lt;/code&gt;, &lt;code&gt;aout_format&lt;/code&gt;。每种二进制格式必须提供下面三个函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;load_binary&lt;/code&gt; 用于加载普通程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load_shlib&lt;/code&gt; 用于加载共享库，即动态库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;core_dump&lt;/code&gt; 用于程序错误的情况下输出内存转储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每种格式首先必须用&lt;code&gt;register_binfmt&lt;/code&gt;向内核注册。该函数的目的是向一个链表增加一个新的二进制格式，该链表的表头是&lt;code&gt;fs/exec.c&lt;/code&gt;中的全局变量&lt;code&gt;formats&lt;/code&gt;，&lt;code&gt;linux_binfmt&lt;/code&gt;实例通过其&lt;code&gt;next&lt;/code&gt;成员彼此连接起来。&lt;/p&gt;
&lt;h2 id=&#34;退出进程&#34;&gt;退出进程&lt;/h2&gt;
&lt;p&gt;进程必须用exit系统调用终止，这使得内核有机会将该进程使用的资源放回系统。该调用的入口点是 &lt;code&gt;sys_exit&lt;/code&gt; 函数，需要一个错误码作为其参数，以便退出进程，最终调用&lt;code&gt;do_exit&lt;/code&gt;函数实现，该函数实现就是将各个引用计数器减1。如果引用计数器归0就将相应的内存区域返还给内存管理模块。&lt;/p&gt;
&lt;h1 id=&#34;调度器的实现&#34;&gt;调度器的实现&lt;/h1&gt;
&lt;p&gt;内存中保存了对每个进程的唯一描述，通过若干结构与其他进程连接起来，调度器任务便是程序之间共享CPU时间，创造并执行的错觉，该任务分为两个不同部分：一个涉及调度策略，另一个涉及上下文切换。&lt;/p&gt;
&lt;h2 id=&#34;概观&#34;&gt;概观&lt;/h2&gt;
&lt;p&gt;内核必须提供一种方法，在进程之间尽可能公平地共享CPU时间，而同时又要考虑不同的任务优先级。&lt;code&gt;schedule&lt;/code&gt;函数是理解调度操作的起点，该函数定义在&lt;code&gt;kernel/sched.c&lt;/code&gt;中，是内核代码最常用的函数之一。&lt;/p&gt;
&lt;h1 id=&#34;完全公平调度类&#34;&gt;完全公平调度类&lt;/h1&gt;
&lt;h1 id=&#34;实时调度类&#34;&gt;实时调度类&lt;/h1&gt;
&lt;h1 id=&#34;调度器增强&#34;&gt;调度器增强&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-启动协议</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-boot-protocol/</link>
        <pubDate>Thu, 22 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-boot-protocol/</guid>
        <description>&lt;p&gt;Linux 是非常出色的操作系统，通过阅读内核源码，能够清楚的理解现代操作系统的构架和任意细节，但 Linux 内核代码非常庞大，而且有很多与硬件相关的细节，阅读代码有些吃力，不过只要了解内核代码的构架，可对自己迷惑的部分单独分析。&lt;/p&gt;
&lt;p&gt;我在这里对我分析的部分做一个记录，一来防止以后遗忘，二来把分析过程写出来能更加清楚的理解内核。分析的内核版本为 2.6.34，可从 这里 下载，或者使用 lxr 在线阅读代码。&lt;/p&gt;
&lt;p&gt;Linux源码 arch 目录下是构架相关的代码，其中有x86，arm等不同平台的实现，这里仅看x86平台，boot目录是系统启动部分代码，我将会逐一分析启动代码。&lt;/p&gt;
&lt;p&gt;2.6.34 版本较之以前有了很大的变动，内核启动过程需要大量的汇编操作，这个版本尽量去除汇编，仅仅在必须的地方提供汇编提供接口，供c代码调用。&lt;/p&gt;
&lt;p&gt;先来看引导协议部分代码， arch/x86/boot/header.S&lt;/p&gt;
&lt;p&gt;在之前BIOS中断部分讲过引导程序，位于启动介质0柱面0磁道1扇区的512字节，以0x55AA结尾，header.S中也同样含有这段代码，但是仅仅输出几行文字，并没有做实质性操作，Linux内核把引导的工作交付给专业的引导程序如grub、lilo，BIOS启动时首先加载grub程序，grub作为引导程序根据配置再去加载相应的内核。如此一来便需要grub和内核之间遵循一定的协议，协议文档位于 linux-2.6.34\Documentation\x86\boot.txt，可以作为参考。&lt;/p&gt;
&lt;p&gt;header.S开始的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	.code16
	.section &amp;quot;.bstext&amp;quot;, &amp;quot;ax&amp;quot;

	.global bootsect_start
bootsect_start:

	# Normalize the start address
	ljmp	$BOOTSEG, $start2

start2:
	movw	%cs, %ax
	movw	%ax, %ds
	movw	%ax, %es
	movw	%ax, %ss
	xorw	%sp, %sp
	sti
	cld

	movw	$bugger_off_msg, %si

msg_loop:
	lodsb
	andb	%al, %al
	jz	bs_die
	movb	$0xe, %ah
	movw	$7, %bx
	int	$0x10
	jmp	msg_loop

bs_die:
	# Allow the user to press a key, then reboot
	xorw	%ax, %ax
	int	$0x16
	int	$0x19

	# int 0x19 should never return.  In case it does anyway,
	# invoke the BIOS reset code...
	ljmp	$0xf000,$0xfff0

	.section &amp;quot;.bsdata&amp;quot;, &amp;quot;a&amp;quot;
bugger_off_msg:
	.ascii	&amp;quot;Direct booting from floppy is no longer supported.\r\n&amp;quot;
	.ascii	&amp;quot;Please use a boot loader program instead.\r\n&amp;quot;
	.ascii	&amp;quot;\n&amp;quot;
	.ascii	&amp;quot;Remove disk and press any key to reboot . . .\r\n&amp;quot;
	.byte	0

	# Kernel attributes; used by setup.  This is part 1 of the
	# header, from the old boot sector.

	.section &amp;quot;.header&amp;quot;, &amp;quot;a&amp;quot;
	.globl	hdr
hdr:
setup_sects:	.byte 0			/* Filled in by build.c */
root_flags:	.word ROOT_RDONLY
syssize:	.long 0			/* Filled in by build.c */
ram_size:	.word 0			/* Obsolete */
vid_mode:	.word SVGA_MODE
root_dev:	.word 0			/* Filled in by build.c */
boot_flag:	.word 0xAA55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分是完整的引导区代码，这段代码有三个段，.bstext .bsdata .header，由编译脚本setup.ld可以看到，.header是编译到497地址，除去一些变量，到boot_flag: .word 0xAA55刚好位于512字节，是一个引导扇区的长度。.bsdata 段仅定义了一个字符串，指明boot方式不再支持。&lt;/p&gt;
&lt;p&gt;来看下代码部分 .bstext 段，首先由start2初始化一些变量，&lt;code&gt;msg_loop&lt;/code&gt;调用int $0×10输出文字，bs_die部分首先调用int $0×16输入一个字符，然后调用int $0×19重启系统。&lt;/p&gt;
&lt;p&gt;可以看到这里的引导程序并没有做什么操作，也不会被执行到，真正的代码再之后才开始，之前说过内核的引导是靠grub等引导程序，他们之间有一定的协议，协议有一个协议头，再看header.S之后的代码都是一些变量的定义，所以得先看一下协议头到底是什么，在boot.txt文档中有以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The header looks like:

Offset	Proto	Name		Meaning
/Size

01F1/1	ALL(1	setup_sects	The size of the setup in sectors
01F2/2	ALL	root_flags	If set, the root is mounted readonly
01F4/4	2.04+(2	syssize		The size of the 32-bit code in 16-byte paras
01F8/2	ALL	ram_size	DO NOT USE - for bootsect.S use only
01FA/2	ALL	vid_mode	Video mode control
01FC/2	ALL	root_dev	Default root device number
01FE/2	ALL	boot_flag	0xAA55 magic number
0200/2	2.00+	jump		Jump instruction
0202/4	2.00+	header		Magic signature &amp;quot;HdrS&amp;quot;
0206/2	2.00+	version		Boot protocol version supported
...
0258/8	2.10+	pref_address	Preferred loading address
0260/4	2.10+	init_size	Linear memory required during initialization
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说的正是协议头的定义，这里的01F1/1前面表示地址，后面表示大小，01F1十进制为497，刚好与.header段的起始地址相同，看来，.header段名副其实，正是启动协议的头部信息，一直到236行的init_size定义为止。头部内容的详细信息在boot.txt文件中已有详细解释，不过现在还不需要知道，头部大部分信息由grub填充，供操作系统使用。后面会看到内核获取这些信息。&lt;/p&gt;
&lt;p&gt;好了，header.S后面的.entrytext段就是真正的内核入口了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	movw	$0x0000, %ax		# Reset disk controller
	movb	$0x80, %dl		# All disks
	int	$0x13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里调用BIOS的13号中断重置硬盘。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	movw	$__bss_start, %di
	movw	$_end+3, %cx
	xorl	%eax, %eax
	subw	%di, %cx
	shrw	$2, %cx
	rep; stosl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__bss_start&lt;/code&gt;是bss段的起始地址，_end为结束位置，这两个符号定义于setup.ld脚本，这段代码既是对此段清零。&lt;/p&gt;
&lt;p&gt;接下来调用main函数 calll main，这里的main是c函数，定义于main.c。&lt;/p&gt;
&lt;p&gt;之后有符号&lt;code&gt;setup_bad&lt;/code&gt;，调用puts输出”No setup signature found…\n”，最后定义了一个函数die，执行休息指令hlt的死循环。&lt;/p&gt;
&lt;p&gt;最后再来看main函数中的开始部分代码 linux-2.6.34\arch\x86\boot\main.c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void main(void)
{
	/* First, copy the boot header into the &amp;quot;zeropage&amp;quot; */
	copy_boot_params();

	/* End of heap check */
	init_heap();
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到main首先调用copy_boot_params函数，在29行有其定义，其中关键的一句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;memcpy(&amp;amp;boot_params.hdr, &amp;amp;hdr, sizeof hdr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hdr 是引导协议头部0x1f1地址处，即刚才分析的.header段开始的标号，&lt;code&gt;boot_params&lt;/code&gt;为结构体&lt;code&gt;boot_params&lt;/code&gt;的实例，存储启动参数相关信息，结构定义于arch/x86/include/asm/bootparam.h:85，成员hdr定义为&lt;code&gt;struct setup_header hdr;&lt;/code&gt;而&lt;code&gt;setup_header&lt;/code&gt;结构定义于相同文件的24行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct setup_header {
	__u8	setup_sects;
	__u16	root_flags;
	__u32	syssize;
	__u16	ram_size;
#define RAMDISK_IMAGE_START_MASK	0x07FF
#define RAMDISK_PROMPT_FLAG		0x8000
#define RAMDISK_LOAD_FLAG		0x4000
	__u16	vid_mode;
	__u16	root_dev;
	__u16	boot_flag;
	__u16	jump;
	__u32	header;
	__u16	version;
	__u32	realmode_swtch;
	__u16	start_sys;
	__u16	kernel_version;
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到其中的成员正是引导协议头部，拷贝代码正是把grub填充的启动信息复制到结构实例boot_params.hdr中，以便在c程序中使用。&lt;/p&gt;
&lt;p&gt;最后总结一下grub的引导过程，grub被BIOS载入内存并获得控制权后，读取配置信息/boot/grub.conf，载入实模式代码到0×090000，并根据内核镜像的前512字节中的.header信息，将大内核载入到内存，并交控制权于内核执行。载入内存地址的计算公式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;is_bzImage = (protocol &amp;gt;= 0x0200) &amp;amp;&amp;amp; (loadflags &amp;amp; 0x01);
load_address = is_bzImage ? 0x100000 : 0x10000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里通过分析header.S，对引导协议做了一些说明，更详尽的说明在文档 Documentation\x86\boot.txt，可随时对其查阅。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-VFS</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-vfs-source/</link>
        <pubDate>Wed, 21 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-vfs-source/</guid>
        <description>&lt;p&gt;Linux 文件系统有着复杂的结构，仅仅概念就有file，dentry，inode，vfsmount，super_block等等，还有他们之间的关联，细节虽然繁多，但只要抓住主干框架，其他的细节通过阅读源码都可顺利成章的理解。这里Linux运行平台版本和分析的源码都以linux-2.6.36.2作为基准，其他相近版本的差别很小。也很容易理解。这里先归纳一下 Linux 文件系统的概念和机制。&lt;/p&gt;
&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;之前已经提到，Linux 文件系统的概念繁多，这里做一些简短的介绍，不会清楚解释每一个细节，只会去“感性”的解释，程序虽然是一种很理性化的东西，但想以一个更高的层次去看他，必须对其有所“感觉”。&lt;/p&gt;
&lt;h2 id=&#34;分层&#34;&gt;分层&lt;/h2&gt;
&lt;p&gt;Linux 秉承了 Unix 的 KISS 原则：Keep It Simple, Stupid！简洁的一个最主要体现就是：万物皆文件。不论是虚拟文件，或是驱动设备，对用户态程序而言都与操作普通文件方式无异（也有少数设备操作例外，比如网络设备）。这种机制的实现得益于VFS，VFS作为一个中间层，抽象底层驱动的差异。万物皆文件的思想与Java中的万物皆对象的思想相同，都是面向对象的体现，所不同的是，万物皆文件是从更高层次进行抽象，VFS仅仅为一个接口层，底层的文件系统或者设备驱动都是接口的实现，这便是多态的思想，只不过C++的类多态机制是细节上的多态，而Linux的多态却是系统级别的多态；类级别的多态容易跌入细节的泥沼，而系统级别的面向对象实现可以合理的为体系分层，使实现更为清晰，虽然面向对象，但仍保持 Simple，Linux 虽然使用纯 C 实现，却是体现面向对象思想的典范。&lt;/p&gt;
&lt;p&gt;VFS 作为一个接口层，需要对上层提供统一的调用接口，同时又要为底层提供实现接口，以致VFS需要引入一些概念。&lt;/p&gt;
&lt;h2 id=&#34;inode&#34;&gt;inode&lt;/h2&gt;
&lt;p&gt;内核使用 inode 表示文件信息数据，最重要的是存储了文件操作的集合 file_operations 和 inode 集合 &lt;code&gt;inode_operations&lt;/code&gt; ，这里的操作集合全部是函数指针，作为抽象接口，具体函数由底层设备提供。&lt;code&gt;file_operations&lt;/code&gt; 实现文件内容操作，如read、write等等，&lt;code&gt;inode_operations&lt;/code&gt; 实现 inode 本身操作，如mkdir, link 等等，另外，inode并非硬盘中的实体，仅存在于内存。&lt;/p&gt;
&lt;h2 id=&#34;file&#34;&gt;file&lt;/h2&gt;
&lt;p&gt;inode 对所有进程可见，仍有一套进程相关的结构，files_struct保存打开文件信息，其中包含 file 结构，file 结构包含文件读写偏移。另外进程还保存一套文件系统信息 fs_struct。&lt;/p&gt;
&lt;h2 id=&#34;dentry&#34;&gt;dentry&lt;/h2&gt;
&lt;p&gt;dentry 为目录缓存，包含目录对应 inode，以及 dentry_operations，以及 d_subdirs 子文件子目录列表。&lt;/p&gt;
&lt;h2 id=&#34;file_system_type&#34;&gt;file_system_type&lt;/h2&gt;
&lt;p&gt;file_system_type 用来表示文件系统，比如 ext2，ext3 结构，所有文件系统组成链表，新文件系统使用 &lt;code&gt;register_filesystem&lt;/code&gt; 向内核注册，函数只是简单的把 &lt;code&gt;file_system_type&lt;/code&gt; 插入链表，其中最关键的成员就是 get_sb，得到 &lt;code&gt;super_block&lt;/code&gt; 结构。&lt;/p&gt;
&lt;h2 id=&#34;super_block&#34;&gt;super_block&lt;/h2&gt;
&lt;p&gt;super_block 储存了文件系统本身和挂载点有关信息，设备块大小，所有inode链表。&lt;/p&gt;
&lt;h2 id=&#34;vfsmount&#34;&gt;vfsmount&lt;/h2&gt;
&lt;p&gt;对于挂接点，还需保存一个 vfsmount 结构，保存了挂接信息，每一个挂接点都包含一个 vfsmount 结构实体。vfsmount 和 &lt;code&gt;super_block&lt;/code&gt; 对与挂接点来说，都是唯一的。&lt;/p&gt;
&lt;h2 id=&#34;path&#34;&gt;path&lt;/h2&gt;
&lt;p&gt;path 包含 vfsmount 和 dentry 结构。&lt;/p&gt;
&lt;h2 id=&#34;nameidata&#34;&gt;nameidata&lt;/h2&gt;
&lt;p&gt;nameidata 结构用于查找，想查找函数传递参数，并保存结果，包括 dentry 和 vfsmount 结构。&lt;/p&gt;
&lt;h1 id=&#34;sys_mount-实现&#34;&gt;sys_mount 实现&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sys_mount&lt;/code&gt; 展现了文件系统加载的所有细节，为学习文件系统提供一个很好的切入点，首先来看 &lt;code&gt;sys_mount&lt;/code&gt; 的函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 源码中的原型
SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,
		char __user *, type, unsigned long, flags, void __user *, data)

# 根据宏推演开来展现原型
#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)

#define SYSCALL_DEFINEx(x, sname, ...)				\
	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__

#define __SYSCALL_DEFINEx(x, name, ...)					\
	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__)

#define __SC_DECL1(t1, a1)	t1 a1
#define __SC_DECL2(t2, a2, ...) t2 a2, __SC_DECL1(__VA_ARGS__)
#define __SC_DECL3(t3, a3, ...) t3 a3, __SC_DECL2(__VA_ARGS__)
#define __SC_DECL4(t4, a4, ...) t4 a4, __SC_DECL3(__VA_ARGS__)
#define __SC_DECL5(t5, a5, ...) t5 a5, __SC_DECL4(__VA_ARGS__)

# 最终展开宏之后的原型为
asmlinkage long sys_mount(char __user * dev_name, char __user * dir_name,	\
		char __user * type, unsigned long flags, void __user * data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数 dev_name 是设备名，如/dev/sda1；dir_name 是目标挂接点路径，如/mnt/target/；type 是文件系统类型，如ext2、ext3等；flags 是mount标志；data是附加选项值。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;sys_mount&lt;/code&gt;的字符串参数都是 &lt;code&gt;__user&lt;/code&gt; 内存，所以在 sys_mount 开始处，首先使用&lt;code&gt;copy_mount_string&lt;/code&gt;等函数把用户空间的字串复制到内核空间。之后再去调用 &lt;code&gt;do_mount&lt;/code&gt; 完成具体的操作。&lt;code&gt;do_mount&lt;/code&gt; 的原型与 &lt;code&gt;sys_mount&lt;/code&gt; 相对应，仅是参数全部已经转换成内核空间的地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long do_mount(char *dev_name, char *dir_name, char *type_page,
		  unsigned long flags, void *data_page)
{
	/** 省略无关部分 */

	/* ... and get the mountpoint */
	retval = kern_path(dir_name, LOOKUP_FOLLOW, &amp;amp;path);
	if (retval)
		return retval;

	retval = security_sb_mount(dev_name, &amp;amp;path,
				   type_page, flags, data_page);
	if (retval)
		goto dput_out;

	/** 省略flags判断分支 */

		retval = do_new_mount(&amp;amp;path, type_page, flags, mnt_flags,
				      dev_name, data_page);
dput_out:
	path_put(&amp;amp;path);
	return retval;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;do_mount&lt;/code&gt; 的主干是非常清晰的，开始省去一些参数校验代码，紧接着调用 &lt;code&gt;kern_path&lt;/code&gt; 根据 &lt;code&gt;dir_name&lt;/code&gt; 指示的路径名获取其 path 结构，&lt;code&gt;security_sb_mount&lt;/code&gt; 做一些安全校验工作，如果没有设置，这个函数为空，否则去调用 &lt;code&gt;security_ops-&amp;gt;sb_mount&lt;/code&gt; 成员实现。这里不去研究 LSM 安全模块，省去这个函数的分析。紧接着根据flags进行判断，决定是重新加载，或者移动，或者更改文件系统，这里仅跟加载新的 mount 作为分析对象，其他部分类似。最后使用&lt;code&gt;path_put&lt;/code&gt;回收path资源。&lt;/p&gt;
&lt;p&gt;这里可以看书，&lt;code&gt;do_mount&lt;/code&gt;其实也只是一个分发函数，首先获得path，然后调用各分支的mount函数，接下来分析 &lt;code&gt;kern_path&lt;/code&gt; 和 &lt;code&gt;do_new_mount&lt;/code&gt; 函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int kern_path(const char *name, unsigned int flags, struct path *path)
{
	struct nameidata nd;
	int res = do_path_lookup(AT_FDCWD, name, flags, &amp;amp;nd);
	if (!res)
		*path = nd.path;
	return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kern_path&lt;/code&gt; 很明显，构建一个 nameidata 对象，使用 &lt;code&gt;do_path_lookup&lt;/code&gt; 函数由路径名 name 得到 nameidata 对象，path 仅是 nameidata 对象的一个成员，把这个成员返回给上层。也就是 &lt;code&gt;kern_path&lt;/code&gt; 调用了更为广泛的 &lt;code&gt;do_path_lookup&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int do_path_lookup(int dfd, const char *name,
				unsigned int flags, struct nameidata *nd)
{
	int retval = path_init(dfd, name, flags, nd);
	if (!retval)
		retval = path_walk(name, nd);
	if (unlikely(!retval &amp;amp;&amp;amp; !audit_dummy_context() &amp;amp;&amp;amp; nd-&amp;gt;path.dentry &amp;amp;&amp;amp;
				nd-&amp;gt;path.dentry-&amp;gt;d_inode))
		audit_inode(name, nd-&amp;gt;path.dentry);
	if (nd-&amp;gt;root.mnt) {
		path_put(&amp;amp;nd-&amp;gt;root);
		nd-&amp;gt;root.mnt = NULL;
	}
	return retval;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;do_path_lookup&lt;/code&gt; 又去调用了 &lt;code&gt;path_init&lt;/code&gt; 和 &lt;code&gt;path_walk&lt;/code&gt; 函数实现功能，&lt;code&gt;path_init&lt;/code&gt; 代码很易懂，根据路径名 name 获取当前相对 name 的 nameidata 结构，如果 name 是以/开始的绝对路径，&lt;code&gt;nameidata-&amp;gt;path&lt;/code&gt; 即为根，否则，如果name是相对路径，nameidata-&amp;gt;path 为当前路径的path，也就是不管name是相对路径还是绝对的，对此时的 nameidata 来讲都可以认为是相对路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;path_walk&lt;/code&gt; 便是根据 nameidata 找到相对路径 name 的 path 节点。&lt;code&gt;path_walk&lt;/code&gt; 本身也没有做这件事，只是把参数又传递给 &lt;code&gt;link_path_walk&lt;/code&gt; 去具体操作，&lt;code&gt;link_path_walk&lt;/code&gt; 的操作便复杂了许多，需要处理各种奇怪的路径名，这里先无视这段复杂的代码，继续向后分析，至少已经知道 &lt;code&gt;link_path_walk&lt;/code&gt; 所实现的功能，不怕他写的复杂，就怕你猜不到他在做什么。&lt;/p&gt;
&lt;p&gt;如此便已清楚 &lt;code&gt;kern_path&lt;/code&gt; 的功能，接下来看 &lt;code&gt;do_new_mount&lt;/code&gt; 的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int do_new_mount(struct path *path, char *type, int flags,
			int mnt_flags, char *name, void *data)
{
	struct vfsmount *mnt;

	if (!type)
		return -EINVAL;

	/* we need capabilities... */
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	lock_kernel();
	mnt = do_kern_mount(type, flags, name, data);
	unlock_kernel();
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	return do_add_mount(mnt, path, mnt_flags, NULL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;do_new_mount&lt;/code&gt; 也分为两步，第一步调用 &lt;code&gt;do_kern_mount&lt;/code&gt; 创建 vfsmount 挂接点结构，之后调用 &lt;code&gt;do_add_mount&lt;/code&gt; 挂接 mnt 到文件系统树。再来一步一步分析，从 &lt;code&gt;do_kern_mount&lt;/code&gt; 开始：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct vfsmount *
do_kern_mount(const char *fstype, int flags, const char *name, void *data)
{
	struct file_system_type *type = get_fs_type(fstype);
	struct vfsmount *mnt;
	if (!type)
		return ERR_PTR(-ENODEV);
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) &amp;amp;&amp;amp; (type-&amp;gt;fs_flags &amp;amp; FS_HAS_SUBTYPE) &amp;amp;&amp;amp;
	    !mnt-&amp;gt;mnt_sb-&amp;gt;s_subtype)
		mnt = fs_set_subtype(mnt, fstype);
	put_filesystem(type);
	return mnt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;do_kern_mount&lt;/code&gt; 从主干来看，首先调用 &lt;code&gt;get_fs_type&lt;/code&gt; 得到文件系统的 &lt;code&gt;file_system_type&lt;/code&gt; 结构，之后调用 &lt;code&gt;vfs_kern_mount&lt;/code&gt; 生成 vfsmount 结构。&lt;code&gt;get_fs_type&lt;/code&gt; 所作工作比较简单，直接调用&lt;code&gt;__get_fs_type&lt;/code&gt;函数从当前已加载的 &lt;code&gt;file_systems&lt;/code&gt; 查找对应文件系统，如果未找到，便以文件系统名为模块名调用 request_module 加载模块，如果加载成功，对应模块会调用 &lt;code&gt;register_filesystem&lt;/code&gt; 把自己的 &lt;code&gt;file_system_type&lt;/code&gt; 结构插入 &lt;code&gt;file_systems&lt;/code&gt; 链表，&lt;code&gt;get_fs_type&lt;/code&gt;会再次进行查找。如果查找失败，便返回 NULL。&lt;/p&gt;
&lt;p&gt;在得到 &lt;code&gt;file_system_type&lt;/code&gt; 文件系统结构后，调用 &lt;code&gt;vfs_kern_mount&lt;/code&gt; 创建 mnt 挂接点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct vfsmount *
vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
{
	/** 省去无关代码 */
	mnt = alloc_vfsmnt(name);
	if (!mnt)
		goto out;

	if (flags &amp;amp; MS_KERNMOUNT)
		mnt-&amp;gt;mnt_flags = MNT_INTERNAL;

	/** 省去无关代码 */

	error = type-&amp;gt;get_sb(type, flags, name, data, mnt);
	if (error &amp;lt; 0) 		goto out_free_secdata; 	/** 省去 LSM 安全模块代码 */ 	mnt-&amp;gt;mnt_mountpoint = mnt-&amp;gt;mnt_root;
	mnt-&amp;gt;mnt_parent = mnt;
	up_write(&amp;amp;mnt-&amp;gt;mnt_sb-&amp;gt;s_umount);
	free_secdata(secdata);
	return mnt;

	/** 省去错误清理代码 */

	return ERR_PTR(error);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过抽取函数的骨干，可以清楚看到函数所作操作，首先 alloc_vfsmnt 为 vfsmount 结构分配空间，并初始化成员。再调用对应文件系统的 file_system_type 成员 get_sb 填充 mnt结构。分配空间并初始化代码并无关键之处，而 get_sb 函数却是相应文件系统的实现，比如 ext2 的 ext2_get_sb 函数。&lt;/p&gt;
&lt;p&gt;先不去研究文件系统的具体实现，这与VFS无关，&lt;code&gt;do_kern_mount&lt;/code&gt; 便以分析完毕，所作功能便是为 vfsmount 分配空间，再去调用文件系统的 &lt;code&gt;get_sb&lt;/code&gt; 实现填充 vfsmount 结构。&lt;/p&gt;
&lt;p&gt;接下来查看 &lt;code&gt;do_add_mount&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int do_add_mount(struct vfsmount *newmnt, struct path *path,
		 int mnt_flags, struct list_head *fslist)
{
	int err;

	mnt_flags &amp;amp;= ~(MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL);

	down_write(&amp;amp;namespace_sem);
	/* Something was mounted here while we slept */
	while (d_mountpoint(path-&amp;gt;dentry) &amp;amp;&amp;amp;
	       follow_down(path))
		;
	err = -EINVAL;
	if (!(mnt_flags &amp;amp; MNT_SHRINKABLE) &amp;amp;&amp;amp; !check_mnt(path-&amp;gt;mnt))
		goto unlock;

	/* Refuse the same filesystem on the same mount point */
	err = -EBUSY;
	if (path-&amp;gt;mnt-&amp;gt;mnt_sb == newmnt-&amp;gt;mnt_sb &amp;amp;&amp;amp;
	    path-&amp;gt;mnt-&amp;gt;mnt_root == path-&amp;gt;dentry)
		goto unlock;

	err = -EINVAL;
	if (S_ISLNK(newmnt-&amp;gt;mnt_root-&amp;gt;d_inode-&amp;gt;i_mode))
		goto unlock;

	newmnt-&amp;gt;mnt_flags = mnt_flags;
	if ((err = graft_tree(newmnt, path)))
		goto unlock;

	if (fslist) /* add to the specified expiration list */
		list_add_tail(&amp;amp;newmnt-&amp;gt;mnt_expire, fslist);

	up_write(&amp;amp;namespace_sem);
	return 0;

unlock:
	up_write(&amp;amp;namespace_sem);
	mntput(newmnt);
	return err;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数开始调用 &lt;code&gt;d_mountpoint&lt;/code&gt; 和 &lt;code&gt;follow_down&lt;/code&gt; 查看是否已经有 mnt 挂接到 path 位置，之后便调用 &lt;code&gt;graft_tree&lt;/code&gt; 把 newmnt 挂接到 path 位置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int graft_tree(struct vfsmount *mnt, struct path *path)
{
	int err;
	if (mnt-&amp;gt;mnt_sb-&amp;gt;s_flags &amp;amp; MS_NOUSER)
		return -EINVAL;

	/** 检测是否文件夹 */
	if (S_ISDIR(path-&amp;gt;dentry-&amp;gt;d_inode-&amp;gt;i_mode) !=
	      S_ISDIR(mnt-&amp;gt;mnt_root-&amp;gt;d_inode-&amp;gt;i_mode))
		return -ENOTDIR;

	err = -ENOENT;
	mutex_lock(&amp;amp;path-&amp;gt;dentry-&amp;gt;d_inode-&amp;gt;i_mutex);

	/** 检测路径的标志，是否允许 mount */
	if (cant_mount(path-&amp;gt;dentry))
		goto out_unlock;

	/** 挂接 mnt */
	if (!d_unlinked(path-&amp;gt;dentry))
		err = attach_recursive_mnt(mnt, path, NULL);
out_unlock:
	mutex_unlock(&amp;amp;path-&amp;gt;dentry-&amp;gt;d_inode-&amp;gt;i_mutex);
	return err;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看来这里的关键点便是 &lt;code&gt;attach_recursive_mnt&lt;/code&gt; 函数，它挂接 mnt 到 path 路径上，甚至内核源码本身也为这个函数使用了很大篇幅的注释。此函数调用 &lt;code&gt;mnt_set_mountpoint&lt;/code&gt; ，增加目标挂接点 mounted 计数，最后调用 &lt;code&gt;commit_tree&lt;/code&gt; 把当前 mnt 添加至全局散列表和父文件系统的子文件系统链。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-中断和异常</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-interrupt-and-exception/</link>
        <pubDate>Tue, 20 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-interrupt-and-exception/</guid>
        <description>&lt;h1 id=&#34;中断和异常的定义&#34;&gt;中断和异常的定义&lt;/h1&gt;
&lt;p&gt;中断和异常其实都属于中断，中断分为同步中断和异步中断，同步中断指处理器发生的异常，如除0错误；异步中断指CPU外部事件引发，如IO设备中断，因为中断可以发生在任何时刻，与当前CPU时钟周期没有任何关系。&lt;/p&gt;
&lt;p&gt;为了描述简单，通常称异步中断为中断，同步中断为异常。&lt;/p&gt;
&lt;h1 id=&#34;中断分类&#34;&gt;中断分类：&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;faults类异常：系统可以恢复，需要重新执行导致异常的指令。
traps类型异常：系统可以恢复，用户取得系统服务的一种手段。
abort异常：不可恢复。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中断分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可屏蔽中断&lt;/li&gt;
&lt;li&gt;不可屏蔽中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断描述符表IDT用于存放中断和异常处理函数信息，其中中断描述符表中的每个表项由8个字节组成，叫门描述符。&lt;/p&gt;
&lt;p&gt;Linux内核中中断请求IRQ用数据结构 &lt;code&gt;struct irq_desc&lt;/code&gt; 表示。&lt;/p&gt;
&lt;p&gt;中断描述符表初始化，在&lt;code&gt;start_kernel&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;异常初始化 strap_init
中断初始化 init_IRQ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中断处理过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;驱动程序调用 request_irq请求中断号为irq的中断请求线的使用权
内核`common_interrrpt`调用`do_IRQ`
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;异常处理过程&#34;&gt;异常处理过程：&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;响应的处理程序执行
do_trap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;延时处理机制&lt;/p&gt;
&lt;p&gt;由于中断处理必须非常快，当系统穿过中断门后系统处于中断禁用状态，这时系统要么不能响应所有外部中断，要么不能响应当前中断源的中断，在这个过程中，会导致新的中断无法及时处理或者丢失中断请求。&lt;/p&gt;
&lt;p&gt;Linux内核提供的延时机制分为softirq，tasklet，work queue。&lt;/p&gt;
&lt;h1 id=&#34;softirq机制&#34;&gt;softirq机制：&lt;/h1&gt;
&lt;p&gt;softirq在内核中由结构体&lt;code&gt;softirq_action&lt;/code&gt;表示，内核预设的softirq存储于&lt;code&gt;softirq_vec&lt;/code&gt;数组中，初始化函数为：&lt;code&gt;open_softirq&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;系统运行过程中，会在合适的地方调用&lt;code&gt;local_softirq_pending&lt;/code&gt;检查是否游softirq需要处理，如果需要便调用函数do_softirq处理，这些检查点包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;中断处理退出函数irq_exit
内核线程ksoftirqd
内核网络子系统显示调用
local_bh_enable
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;tasklet延时处理机制&#34;&gt;tasklet延时处理机制：&lt;/h1&gt;
&lt;p&gt;tasklet在内核中的表示tasklet_struct，这个结构描述了处理函数等信息，该结构可以使用DECLARE_TASKLET或者DECLARE_TASKLET_DISABLED宏进行定义。在中断处理上半部会调用 tasklet_schedule函数激活下半部的处理。最终系统会调用tasklet_action处理任务。&lt;/p&gt;
&lt;p&gt;work queue延时处理：&lt;/p&gt;
&lt;p&gt;内核使用&lt;code&gt;workqueue_struct&lt;/code&gt;记录工作队列信息，每个具体work由结构&lt;code&gt;work_struct&lt;/code&gt;定义，初始化工作队列可以用函数&lt;code&gt;create_workqueue&lt;/code&gt;，激活工作队列使用&lt;code&gt;schedule_work&lt;/code&gt;，处理工作队列函数&lt;code&gt;run_workqueue&lt;/code&gt;。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linxu内核笔记-虚拟地址空间</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-virtual-address/</link>
        <pubDate>Tue, 20 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-virtual-address/</guid>
        <description>&lt;p&gt;在程序中打印变量地址时，往往再不同的程序中都可能打印相同的地址，显然他们并不是占用相同的物理空间，他们之所以地址相同，得益于内核提供的虚拟地址空间的机制。&lt;/p&gt;
&lt;p&gt;在进程结构 &lt;code&gt;task_struct&lt;/code&gt; 中包含一个&lt;code&gt;mm_struct&lt;/code&gt;实例，这个实例便保存的进程的虚拟地址空间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct mm_struct {
        struct vm_area_struct * mmap;           /* list of VMAs */
        struct rb_root mm_rb;
        struct vm_area_struct * mmap_cache;     /* last find_vma result */
        ...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vm_area_struct&lt;/code&gt;结构中存储映射的虚拟内存细节，每个&lt;code&gt;vm_area_struct&lt;/code&gt;节点即存储在单链表mmap中，又存储于红黑树&lt;code&gt;mm_rb&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;内核提供了若干函数对内存映射区域操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查找给定地址后的第一个区域  find_vma
确认边界区间是否在一个现存的vma区域 find_vma_intersection
区域合并 vma_merge
插入区域 insert_vm_struct
创建区域 get_unmapped_area
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;物理内存和虚拟地址的映射通过 &lt;code&gt;vm_area_struct&lt;/code&gt;中的函数指针&lt;code&gt;vm_operations_struct&lt;/code&gt;来对应，这里的映射函数不了解设备的具体信息，需要file的一个成员&lt;code&gt;address_space&lt;/code&gt;来补充，二者通常使用以下方式关联：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const struct vm_operations_struct generic_file_vm_ops = {
        .fault          = filemap_fault,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虚拟地址的映射可以通过系统调用 mmap和munmap。&lt;/p&gt;
&lt;p&gt;堆是进程中动态分配内存的内存区域，对程序员来说使用malloc便可分配内存，使用起来非常便捷，但是malloc在用户态做了很多操作，对底层地用来讲，仅仅使用brk来扩张和收缩堆。&lt;/p&gt;
&lt;p&gt;堆是连续的内存空间，扩张自下至上，&lt;code&gt;mm_struct&lt;/code&gt;中包含了起始和结束地址&lt;code&gt;start_brk&lt;/code&gt;和&lt;code&gt;brk&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外系统分配虚拟地址时并不会马上关联到文件或者内存，当用户实际访问内存时才会进行分配，访问虚拟地址空间，如果内存页尚未映射，便会产生缺页异常，由系统捕获，随后调用 do_page_fault进行内存映射，这是一个非常复杂的实现。&lt;/p&gt;
&lt;p&gt;另外，内核提供了一系列函数从内核空间和用户空间交换数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy_from_user
get_user
strncopy_from_user
put_user
copy_to_user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，每个进程都都有自己独立的虚拟空间，这里的硬件实现原理便是页表项，每个进程都有自己的一组页表项，fork进程时需要复制一份独立的页表项，这也是创建进程相对创建线程的瓶颈所在，如果一个进程独立的页表项很少，fork的性能会很好，如果有大量的页表项，fork的性能便不看忍受了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 内核调试</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-debugging/</link>
        <pubDate>Mon, 19 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-debugging/</guid>
        <description>&lt;h1 id=&#34;uml调试linux内核&#34;&gt;UML调试Linux内核&lt;/h1&gt;
&lt;p&gt;最近看了些Linux内核源码，之前认为最好的调试内核源码最好的方式使用Qemu虚拟机，结合GDB调试，虽然在网上也看到一些这种调试方式的弊端，但感觉虚拟机支持调试是最完美的事情，虽然Bochs更为灵活甚至内置调试器，但速度太慢。&lt;/p&gt;
&lt;p&gt;之 前一直觉得KGDB这种双机调试的方式很不完美，还必须使用一个调试机，不过在Windows下使用WinDbg调试虚拟机多了，感觉这种方式很合理，起 码被调试机当机的情况下，调试机还是活的。而且这样看上去很酷，而且比SoftICE这样“不稳定”的调试方式要好的多。&lt;/p&gt;
&lt;p&gt;这两天看到一种 UML（User Mode Linux）的调试方式，居然早已加入内核，我才听闻，真是落后时代啊。这种UML方式是把linux内核当作本地一个普通的应用程序执行，当然也很方便 调试，这个类似于Xen虚拟机。不过在64位Fedora上没有配好环境，在i386却很容易配置，打开控制台转到内核源码，例如&lt;code&gt;linux- 2.6.34&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;编译内核命令要在普通方式后加入构架um参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置内核
make menuconfig ARCH=um
# 编译内核
make linux ARCH=um
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译完成后会在源码根目录下生成可执行文件 linux。&lt;/p&gt;
&lt;p&gt;到这里似乎很简单，下面需要创建 Linux 根文件系统，也就是除内核以外的硬盘文件，这个根文件系统包括Linux文件组织数，以及启动系统所必须的一些辅助程序。&lt;/p&gt;
&lt;p&gt;一种方法就是手工制作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建一个2G的文件作为硬盘
dd if=/dev/zero of=rootfs.img bs=1M count=2048
# 格式化文件
mkfs.ext3 rootfs.img
# 映射此文件到主机文件夹
mount -o loop rootfs.img /mnt/temp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此便可通过拷贝文件到&lt;code&gt;/mnt/temp/&lt;/code&gt;目录，等同于拷贝文件到rootfs.img硬盘文件。这里可以直接通过主机的文件目录组织去构建跟文件系统，也可以直接安装一个linux到此目录。&lt;/p&gt;
&lt;p&gt;使用最简单的方式就是直接使用现成的根文件系统。在UML网站 &lt;a class=&#34;link&#34; href=&#34;http://user-mode-linux.sourceforge.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The User-mode Linux Kernel Home Page&lt;/a&gt; 有相关链接可以下载，比如下载 DSL-4.4-root_fs.bz2 文件，首先解压运行之：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bunzip2 DSL-4.4-root_fs.bz2
./linux ubda=DSL-4.4-root_fs

#登录之后出现root提示符
root@console[/]#
#关闭UML
root@console[/]# shutdown -h 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于根文件系统需要慢慢积累。&lt;/p&gt;
&lt;p&gt;接下来看看如何调试内核，由官方文档 &lt;a class=&#34;link&#34; href=&#34;http://user-mode-linux.sourceforge.net/hacking.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kernel Hacking with UML&lt;/a&gt; 所言，直接使用 gdb linux 便可调试，不过我在启动一开始便遇到段错误，单步运行居然还能继续，之后便陷入无休止的trap中。&lt;/p&gt;
&lt;p&gt;继续 google（最能找到答案的往往在国外的论坛，而且常常需要翻墙），最后找到两个设置，是SIGSEGV和SIGUSR1信号不中断继续运行，最终居然可以，这点让人百思不得其解，还是先看看现象如何：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gdb linux
(gdb) br start_kernel
Breakpoint 1 at 0x80493bb: file init/main.c, line 533.
(gdb) handle SIGSEGV pass nostop noprint
Signal        Stop      Print   Pass to program Description
SIGSEGV       No        No      Yes             Segmentation fault
(gdb) handle SIGUSR1 pass nostop noprint
Signal        Stop      Print   Pass to program Description
SIGUSR1       No        No      Yes             User defined signal 1
(gdb) r ubda=DSL-4.4-root_fs
Starting program: /home/cpp/fox/kernel/linux-2.6.34/linux ubda=DSL-4.4-root_fs
Locating the bottom of the address space ... 0x1000
Locating the top of the address space ... 0xc0000000
Core dump limits :
        soft - 0
        hard - NONE
Checking that ptrace can change system call numbers...OK
Checking syscall emulation patch for ptrace...OK
Checking advanced syscall emulation patch for ptrace...OK
Checking for tmpfs mount on /dev/shm...OK
Checking PROT_EXEC mmap in /dev/shm/...OK
Checking for the skas3 patch in the host:
  - /proc/mm...not found: No such file or directory
  - PTRACE_FAULTINFO...not found
  - PTRACE_LDT...not found
UML running in SKAS0 mode

Breakpoint 1, start_kernel () at init/main.c:533
533             smp_setup_prhandleocessor_id();
(gdb)

# 注释，gdb 启动参数的设置
(gdb) r arg1 arg2 ...
(gdb) set args arg1 arg2 ...
# handle 指定如何处理一个信号，详尽的解释可查阅帮助
(gdb) help handle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;居然一切顺利的断到了start_kernel，哈哈，不管如何，总算能够调试内核了。接下来还有UML虚拟机的网络配置，UML使用了一个取巧的方式就是利用 tun 和 iptables ，好在我也研究了大半年，明天继续。&lt;/p&gt;
&lt;p&gt;另外有个GDB调试的问题，明明遇到了SIGSEG，为什么还能继续呢？莫非这个信号是自己发出的？还有之后的SEGTRAP信号是怎么发出来的？要弄清楚这个问题，或许还得查阅UML代码。&lt;/p&gt;
&lt;h1 id=&#34;uml网络配置&#34;&gt;UML网络配置&lt;/h1&gt;
&lt;p&gt;UML支持多种方式的网络，一般使用tap/tun模拟UML虚拟机中的eth0驱动，仅仅这种方式也能分为桥接和NAT等等，手工配置网络也有助于理解网络的运行方式。&lt;/p&gt;
&lt;p&gt;根据官方文档 &lt;a class=&#34;link&#34; href=&#34;http://user-mode-linux.sourceforge.net/network.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Simple UML Networking&lt;/a&gt; 下载 &lt;code&gt;uml_utilities&lt;/code&gt; ，其实也就使用了一个工具 tunctl，这个工具很简单，就是启动 tun 驱动，首先得先查看是否加载 tun 驱动，当然首先需要有root权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看用户 ID （tunctl 使用）
[cpp@dark tunctl]$ id
uid=500(cpp) gid=500(cpp) groups=500(cpp) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

# 切换管理员权限
[cpp@dark tunctl]$ su
Password:

# 查看tun驱动是否加载
[root@dark tunctl]# lsmod | grep tun

# 没有则加载tun驱动
[root@dark tunctl]# modprobe tun

# 再次查看
[root@dark tunctl]# lsmod | grep tun
tun                    13014  0

# 查看普通用户是否有读写tun设备权限
[root@dark tunctl]# ls /dev/net/tun -l
crw-rw-rw-. 1 root root 10, 200 Dec  8 11:19 /dev/net/tun

# 启动tun，设置用户ID
# 随后驱动以tap模式启动，设备为 tap0
[root@dark tunctl]# ./tunctl -u 500
Set &#39;tap0&#39; persistent and owned by uid 500

# 查看所有网卡状态，可以看到已经有tap0接口
[root@dark tunctl]#ifconfig -a
eth1      Link encap:Ethernet  HWaddr 08:00:27:54:D1:F5
          inet addr:10.33.33.34  Bcast:10.255.255.255  Mask:255.0.0.0
          inet6 addr: fe80::a00:27ff:fe54:d1f5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:555523 errors:13 dropped:0 overruns:0 frame:0
          TX packets:70630 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:424000963 (404.3 MiB)  TX bytes:4827144 (4.6 MiB)
          Interrupt:19 Base address:0xd020

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:102 errors:0 dropped:0 overruns:0 frame:0
          TX packets:102 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:13444 (13.1 KiB)  TX bytes:13444 (13.1 KiB)

tap0      Link encap:Ethernet  HWaddr DA:47:96:23:59:AA
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

# 激活tap网卡并设置IP地址
[root@dark cpp]# ifconfig tap0 192.168.33.33 up

# 完毕后删除网卡可使用命令
[root@dark tunctl]# ./tunctl -d tap0

到这里已经设置好tun/tap网卡，接下来启动UML虚拟机并且配置网络：

# 启动UML虚拟机，设置网卡为tap
[cpp@dark linux-2.6.36]$ ./linux eth0=tuntap,tap0 ubda=Gentoo-10.0-AMD64-root_fs

# 启动过程中出现
eth0: broadcasting for a lease
eth0: timed out
# 说明并没有连通网络

# 启动虚拟机后检测网卡配置
eth0: broadcasting for a lease
eth0: timed out
eth0: trying to use old lease in `/var/lib/dhcpcd/dhcpcd-eth0.lease&#39;
localhost ~ # ifconfig
eth0      Link encap:Ethernet  HWaddr b2:9d:a5:12:b9:45
          inet addr:169.254.186.160  Bcast:169.254.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:1578 (1.5 KiB)
          Interrupt:5

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到UML虚拟机已经有网卡配置，但是并无法连通网络。连通网络有几种方式，像virtualbox等虚拟机的NAT和桥接等等，按照UML这种设计方式，应该可以配置出来任意类型，这里尝试配置桥接模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 设置IP路由转发
[root@dark linux-2.6.36]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
[root@dark linux-2.6.36]# echo 1 &amp;gt; /proc/sys/net/ipv4/conf/tap0/proxy_arp

# 创建网桥 （brctl 位于 bridge-utils 软件包）
[root@dark linux-2.6.36]# brctl addbr br0
# 把 eth1 和 tap0 加入网桥
[root@dark linux-2.6.36]# brctl addif br0 eth1
[root@dark linux-2.6.36]# brctl addif br0 tap0

# 修改br0网桥的网络配置并激活
[root@dark linux-2.6.36]# ifconfig eth1 10.33.33.35 up
[root@dark linux-2.6.36]# ifconfig tap0 10.33.33.36 up
[root@dark linux-2.6.36]# ifconfig br0 10.33.33.34 up

# 启动UML虚拟机，设置网卡为tap
[cpp@dark linux-2.6.36]$ ./linux eth0=tuntap,tap0 ubda=Gentoo-10.0-AMD64-root_fs

# 设置UML虚拟机网络配置
localhost ~ # ifconfig eth0 10.33.33.36 netmask 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过设置网桥后发现仍然无法连通本地10.33.33.35，却可以ping通远程机器地址，真是抓狂，抓包发现tap0网卡arp解 析有问题，进一步查看发现tap0网卡的mac地址与虚拟机内eth0网卡mac地址不同，也就是UML内部重新创建一个网卡而并没有直接使用tap0， 只是通过tap0收发数据，但为什么远程机器可以接受但是本地地址无法接受呢？本地网卡把10.33.33.36当成了本机tap0，而外网地址把 10.33.33.36当成了UML虚拟机，故能连通，也就是UML虚拟机跟主机tap0并不相同，是两个独立的机器，把UML虚拟机设置为 10.33.33.37，发现所有机器都可以连通。这样就把UML虚拟机桥接到网络上了。&lt;/p&gt;
&lt;p&gt;现在设置NAT网络，把系统网络状态恢复到开始， 重新设置tap驱动，地址为192.168.33.33，启动虚拟机，设置ip地址为 192.168.33.34，这样 192.168.33.* 就相当于一个小局域网，192.168.33.34 通过 192.168.33.33 转发，设置完毕以后二者便可通信，也省去了桥接的麻烦，只是需要操纵 iptables。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在 UML 虚拟机内设置默认路由
localhost ~ # route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.33.33
# 查看路由表，看到已经添加了 default 网关为 192.168.33.33
localhost ~ # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.33.0    *               255.255.255.0   U     0      0        0 eth0
loopback        *               255.0.0.0       U     0      0        0 lo
default         192.168.33.33   0.0.0.0         UG    0      0        0 eth0

# 设置IP路由转发
[root@dark linux-2.6.36]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward

# 设置SNAT源地址转换 10.33.33.34 为eth1地址
[root@dark linux-2.6.36]# iptables -t nat -A POSTROUTING -o eth1 -j SNAT --to-source 10.33.33.34

# 如果此时不通，可检查iptables的其他规则和UML与主机的路由表配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样便可做成NAT的效果，比桥接方式简单的多，只是需要知道iptables的用法。当然以上配置每次重启将会消失，可以写到配置开机自动设置。&lt;/p&gt;
&lt;h1 id=&#34;qemu调试linux内核&#34;&gt;Qemu调试Linux内核&lt;/h1&gt;
&lt;p&gt;通过UML可以方便的在本机调试Linux内核，UML是一种特殊的虚拟机，另外一种更为灵活的虚拟机是Qemu，Qemu是一种完全仿真虚拟机， 可以在i386平台仿真任意其他处理器构架，而且支持GDB调试，这里尝试一下使用Qemu调试Linux内核，Qemu参数-kernel可以直接指定 内核启动，这与UML有相似之处。&lt;/p&gt;
&lt;p&gt;首先需要编译安装Qemu，这里并没有什么疑惑之处，直接从官方网站下载源码，使用Linux最常用的编译命令即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认选项会编译所有处理器构架虚拟机
# 可以 ./configure --help 查看编译特定平台的配置

cpp@dark:~/qemu-0.12.4$ ./configure --target-list=i386-softmmu
cpp@dark:~/qemu-0.12.4$ make
cpp@dark:~/qemu-0.12.4$ make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来以默认选项编译内核，不过巨崩溃的是内核默认没有DEBUG_INFO选项，所以虽然能在导出符号部分断下来，但是没有源码，所以需要选则Compile the kernel with debug info选项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认选项
cpp@dark:~/linux-2.6.34$ make defconfig
# 配置菜单，选择调试信息
cpp@dark:~/linux-2.6.34$ make menuconfig
# 编译内核
cpp@dark:~/linux-2.6.34$ make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用Qemu加载内核启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cpp@dark:~/linux-2.6.34$ qemu -s -S -kernel arch/x86/boot/bzImage -hda rootfs.img -append &amp;quot;root=/dev/sda&amp;quot;
# 其中一些选项的解释如下
# -s 监听tcp:1234端口以等待GDB连接
# -S 虚拟机启动后停止，以便GDB连接后调试启动过程
# -kernel 压缩内核
# -hda 硬盘
# -appand 启动参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里系统很容易启动不了，如果系统由于VFS加载错误无法启动，首先尝试启动参数root=/dev/sda为root=/dev /hda，hda是IDE硬盘标识，sda为SCSI硬盘，这要看内核识别成哪种，如果仍然不行，那要检测rootfs.img根文件系统的格式跟内核所 支持的格式是否匹配，2.6.34支持ext3格式，如果格式错误，可以利用 Linux 内核调试1 里的方法，自己手工创建一个ext3格式的文件，然后mount到临时文件，把其他根文件系统全部拷贝进去即可。&lt;/p&gt;
&lt;p&gt;这 样启动Qemu之后，发现系统一片黑屏，这里因为Qemu启动参数被设置为禁止，Qemu本身具有显示窗口和控制窗口，利用 Ctrl+Alt+2 进入控制台，c命令继续虚拟机，Ctrl+Alt+1 返回显示窗口，Qemu的控制台可以控制很多选项，从这点来看要比VMware等要灵活一些，UML本身也支持运行时控制。&lt;/p&gt;
&lt;p&gt;接下来使用GDB启动虚拟机，当系统停止在启动之后时，用GDB加载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 启动GDB，GDB加载未压缩内核
cpp@dark:~/linux-2.6.34$ gdb vmlinux
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;i486-slackware-linux&amp;quot;...
(gdb)

# 设置断点
(gdb) br start_kernel
Breakpoint 1 at 0xc172f5d4: file init/main.c, line 533.

# 连接Qemu监听端口1234
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
[New Thread 1]
0x0000fff0 in ?? ()

# 继续Qemu虚拟机执行
(gdb) c
Continuing.

# 内核解压之后很快便到达断点
Breakpoint 1, start_kernel () at init/main.c:533
533             smp_setup_processor_id();
(gdb)

# 接下来便可任意调试内核
(gdb) list
528     asmlinkage void __init start_kernel(void)
529     {
530             char * command_line;
531             extern struct kernel_param __start___param[], __stop___param[];
532
533             smp_setup_processor_id();
534
535             /*
536              * Need to run as early as possible, to initialize the
537              * lockdep hash:
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Qemu由于是完全仿真实现，所以可以在任意平台调试其他构架内核，理论上甚至可以在Windows平台交叉编译Linux内核，再去由Qemu加载调试（交叉编译比较麻烦，需要先编译目标构架的binutil，而后链接内核）。&lt;/p&gt;
&lt;h1 id=&#34;uml和qemu调试内核模块&#34;&gt;UML和Qemu调试内核模块&lt;/h1&gt;
&lt;p&gt;这次来看如何调试内核模块，也就是驱动程序，模块的调试跟普通程序略有不同，不论是内核还是普通应用程序，在连接之后便以得知代码将要加载的位置，用户态程序有虚拟地址映射机制，而内核独占物理内存。内核运行与共享的内核地址空间，所以不能使用相同的线性地址，只能由内核加载模块时指定起始地址，模块中都以此为偏移运行。所以内核的调试不能使用普通的方式，需要知道模块的加载地址。&lt;/p&gt;
&lt;p&gt;而且Qemu的调试原理与UML相似，也可用相同的方法进行模块的调试，这里仅以UML模块调试举例&lt;/p&gt;
&lt;p&gt;首先需要完成一个内核模块，这里可以照搬之前的 Linux 内核调试 ，保存源文件为go.c，完成Makefile和编译工作，内核源码以编译UML的内核为准：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Makefile 内容
obj-m := go.o

# 编译命令
[cpp@dark go]$ make -C /home/cpp/fox/linux-2.6.36 M=$PWD modules ARCH=um

接下来启动带网络的UML，拷贝go.ko模块文件到UML虚拟机中，之后启动GDB：

# 查看 linux 进程 ID
[cpp@dark linux-2.6.36]$ ps -A | grep linux
 7333 pts/0    00:00:38 linux
 7340 pts/0    00:00:00 linux
 7341 pts/0    00:00:00 linux
 7342 pts/0    00:00:00 linux
 7343 pts/0    00:00:00 linux
 7481 pts/0    00:00:00 linux
 7546 pts/0    00:00:00 linux
 9864 pts/0    00:00:00 linux
 9866 pts/0    00:00:00 linux
 9868 pts/0    00:00:00 linux

# 启动 GDB
[cpp@dark linux-2.6.36]$ gdb linux
GNU gdb (GDB) Fedora (7.1-18.fc13)
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-redhat-linux-gnu&amp;quot;.
For bug reporting instructions, please see:...
Reading symbols from /home/cpp/fox/linux-2.6.36/linux...done.

# attach 到 linux 进程，attach第一个进程
(gdb) attach 7333

# 忽略段错误
(gdb) handle SIGSEGV pass nostop noprint

# 对 sys_init_module 设置断点，截获模块加载事件
(gdb) br sys_init_module
Breakpoint 1 at 0x60052421: file kernel/module.c, line 2696.

# 继续执行
(gdb) c
Continuing.

# 在虚拟机中加载 go.ko 模块
localhost ~ # insmod go.ko

# 主机GDB截获断点
Breakpoint 1, sys_init_module (umod=0x603030, len=124282,
    uargs=0x603010) at kernel/module.c:2696
2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb)
# 模块加载 load_module 调用结果
(gdb) n 2691 {
(gdb) n 2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb) n 2700 mod = load_module(umod, len, uargs);
(gdb) n 2701 if (IS_ERR(mod))
(gdb) print mod
$1 = (struct module *) 0x628482b0

# 从 include/linux/module.h 查看 module.h结构
# struct module_sect_attrs *sect_attrs; 为模块的段属性
# 查看模块名
(gdb) print mod-&amp;gt;name
$2 = &amp;quot;go&amp;quot;, &#39;\000&#39;
# 查看模块段个数
(gdb) print mod-&amp;gt;sect_attrs-&amp;gt;nsections
$3 = 11
# 查看第一个段名
(gdb) print mod-&amp;gt;sect_attrs-&amp;gt;attrs[0]-&amp;gt;name
$4 = 0x61daa3a0 &amp;quot;.note.gnu.build-id&amp;quot;
# 找到 .text 段，并显示基址
(gdb) print mod-&amp;gt;sect_attrs-&amp;gt;attrs[1]-&amp;gt;name
$5 = 0x61daa3c0 &amp;quot;.text&amp;quot;
(gdb) print /x mod-&amp;gt;sect_attrs-&amp;gt;attrs[1]-&amp;gt;address
$6 = 0x62848000
# 加载符号，使用 GDB 的 add-symbol-file 命令加载模块符号到基址
(gdb) add-symbol-file go/go.ko 0x62848000 add symbol table from file &amp;quot;go/go.ko&amp;quot; at .text_addr = 0x62848000 (y or n) y Reading symbols from /home/cpp/fox/linux-2.6.36/go/go.ko...done.

# 设置模块断点
(gdb) br simple_read Breakpoint 2 at 0x62848028: file /home/cpp/fox/linux-2.6.36/go/go.c, line 21.
# 继续运行
(gdb) c Continuing.

# UML 虚拟机中操作模块 localhost ~
# cat /dev/simple

# 主机断点生效 Breakpoint 2, simple_read (pfile=0x61c74180, buf=0x60d000

, size=32768, ppos=0x61e0bec0) at /home/cpp/fox/linux-2.6.36/go/go.c:21 21 { (gdb) # 查看信息并调试 (gdb) n 22 if (copy_to_user(buf, “test data\n”, 10)) (gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然加载符号时还可以查看 .data 段和 .bss 段的基址，加载go.ko时同时可以设置二者的基址，以便可以调试全局变量等等，初看起来这个过程比较复杂，其实就是通过调试内核加载位置来确定模块最终将要加载的基址，而后通过机制加载模块符号。&lt;/p&gt;
&lt;p&gt;这个复杂的过程如果每次都需要手动处理是非常烦人的一件事，好在GDB本身有脚本扩展（甚至可执行Python脚本），来简化这个过程，这里来试着写一个简单的打印模块section名字和基址的脚本。&lt;/p&gt;
&lt;p&gt;GDB脚本运行可以由两种方式，一种是在GDB启动时，在当前目录查找.gdbinit文件解释执行，另一种在GDB运行期间使用 source script-file 命令来执行，脚本的说明可查阅文档，以下是简单的打印段信息的脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define modsec
        set $index = 0
        while $index &amp;lt; mod-&amp;gt;sect_attrs-&amp;gt;nsections
                printf &amp;quot;Name\t%s\tAddress\t0x%x\n&amp;quot;, mod-&amp;gt;sect_attrs-&amp;gt;attrs[$index]-&amp;gt;name, mod-&amp;gt;sect_attrs-&amp;gt;attrs[$index]-&amp;gt;address
                set $index = $index + 1
        end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是加载并执行脚本效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 加载脚本
(gdb) source modsec
(gdb) c
Continuing.

# 在虚拟机中加载 go.ko 模块
# 并单步执行到 mod = load_module(umod, len, uargs);
Breakpoint 1, sys_init_module (umod=0x603030, len=124282,
    uargs=0x603010) at kernel/module.c:2696
2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb) n
2691 {
(gdb) n
2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb) n
2700 mod = load_module(umod, len, uargs);
(gdb) n
2701 if (IS_ERR(mod))
# 调用定义命令打印段
(gdb) modsec
Name .note.gnu.build-id Address 0x6286f09c
Name .text Address 0x6286f000
Name .exit.text Address 0x6286f050
Name .init.text Address 0x62872000
Name .rodata.str1.1 Address 0x6286f0c0
Name .eh_frame Address 0x6286f118
Name .data Address 0x6286f1e0
Name .gnu.linkonce.this_module Address 0x6286f2b0
Name .bss Address 0x6286f490
Name .symtab Address 0x62872098
Name .strtab Address 0x628725c0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此便可稍微方便一点的打印所有段名和段基址，如果添加其他脚本扩展，可以更加方便且高效的调试Linux内核。&lt;/p&gt;
&lt;h1 id=&#34;使用kgdb双机调试&#34;&gt;使用KGDB双机调试&lt;/h1&gt;
&lt;p&gt;虽然使用UML或者Qemu可以调试Linux内核，但UML和Qemu毕竟是一个模拟，调试硬件驱动总是用虚拟硬件总不成事，而且Qemu据传闻 对于时钟和中断的处理也有问题，所以对于处理真实硬件的问题，最完美的调试方式就是双机调试，被调试内核在完全真实的环境中运行，排除虚拟机制的不稳定因 素，而且使用内核自带的KGDB机制，更具有可靠性，类似Windows下的WinDbg调试方式。这里使用VirtualBox虚拟机进行调试，但所提 及的方法完全适用于诸如VMWare、Qemu虚拟机或者真实机器，只是相关的串口配置方式有些许不同而已。&lt;/p&gt;
&lt;p&gt;首先需要编译配置KGDB选项的内核，编译方式也比较简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置内核选项
[cpp@dark linux-2.6.34]$ make menucofnig
# Kernel hacking  ---&amp;gt;
# 		[*] Compile the kernel with debug info
# 		[*] KGDB: kernel debugging with remote gdb  ---&amp;gt;

# 编译
[cpp@dark linux-2.6.34]$ make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译完成之后需要在目标机器部署自己的内核，需要修改grub.conf，或者lilo的配置，这决定于Linux使用哪种引导程序，这里修改grub.conf，首先拷贝编译好未压缩内核镜像至目标机器boot分区，命名为linux-2.6.34。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置文件路径 /boot/grub/grub.conf
# 默认启动内核
default 0
# 选择超时时间
timeout 30

# 添加以下内容，以增加一个新的启动项
title Linux 2.6.34 (Debug)
root (hd0,0)
kernel /boot/linux-2.6.34 root=/dev/sdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于lilo，修改配置文件/etc/lilo.conf，之后必须使用lilo -C /etc/lilo.conf使配置生效。&lt;/p&gt;
&lt;p&gt;启 动系统后，首先出现grub引导画面，选择Debug内核启动，不论真机还是虚拟机，时常有系统无法启动的问题，是因为内核配置过小，最基本的启动都无法 支持，如果出现找不到sdb1类似错误，需要检查sdb1是否正确，IDE/ATA硬盘以h打头，为hda等，SATA和SCIS以s打头，为sda等 等，后缀a，b分别为第几块硬盘，sda为第一块，sdb为第二块，其后的数字1、2指明第几个分区，另外需要检查的是硬盘驱动是否正确安装，这个可参阅 Linux安装配置说明，结合google，应该能够解决。&lt;/p&gt;
&lt;p&gt;能够启动系统后，在目标Linux内核启动选项append命令 ro kgdboc=ttyS0,115200 kgdbwait，如此目标机器启动到一定时机停止，出现kgdb: Waiting for connection from remote gdb…的字句，这样对于目标机器的配置已经完成，再来看主机配置，启动gdb配置串口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 加载 vmlinux
cpp@dark:~/linux-2.6.34$ gdb vmlinux
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;i486-slackware-linux&amp;quot;...

# 设置远程端口 波特率
(gdb) set remotebaud 115200
# 连接远程串口
(gdb) target remote /dev/pts/3
Remote debugging using /dev/pts/3
kgdb_register_io_module (new_kgdb_io_ops=)
    at kernel/kgdb.c:1749
1749            wmb(); /* Sync point after breakpoint */

# 至此便可任意调试
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里串口我使用的是 /dev/pts/3 是因为我在linux下使用virtualbox虚拟机的管道串口，再利用socat虚拟串口，有条件的可以直接利用主机串口，这里的设备便成为 /dev/ttyS0，使用socat 虚拟串口的命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vboxS0 为virtualbox的串口管道
cpp@dark:~/kernel/socat-2.0.0-b4$ ./socat -d -d /tmp/vboxS0 pty:1
2010/12/10 23:24:14 socat[3962.3082070656] N opening connection to AF=1 &amp;quot;/tmp/vboxS0&amp;quot;
2010/12/10 23:24:14 socat[3962.3082070656] N successfully connected from local address AF=1 &amp;quot;\x04\b\x94\x18\x@C\xAE\xB4\x@7\xE2\xA7\a&amp;quot;
2010/12/10 23:24:14 socat[3962.3082070656] N successfully connected via
2010/12/10 23:24:14 socat[3962.3082070656] N PTY is /dev/pts/3
2010/12/10 23:24:14 socat[3962.3082070656] N starting data transfer loop with FDs [3,3] and [4,4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此便可使用kgdb进行串口双机调试，这里使用linux主机和虚拟机实现，当然相同的思路可以很容易知道如何进行两个虚拟机或者两个真实机调试。&lt;/p&gt;
&lt;p&gt;kgdb 也支持网络调试，使用tcp协议，但是串口应该是最理想的方式，如果需要调试网络程序，再通过网络传输调试指令，会不会混乱呢？关于kgdb，在 linux内核源码的文档部分 /linux-2.6.34/Documentation/DocBook/kgdb.tmpl ，有一分文档说明，配置时可参阅之。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 内核 slab 分配器</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-slab-allocator/</link>
        <pubDate>Sun, 18 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-slab-allocator/</guid>
        <description>&lt;h1 id=&#34;slab-介绍&#34;&gt;slab 介绍&lt;/h1&gt;
&lt;p&gt;内存分配与释放向来是程序设计中的难点，在C语言中有malloc可以方便使用，但还是有更多的针对具体业务的实现。内存分配需要考虑分配效率和内存使用率的平衡，当用户申请一块内存，程序需要在空闲内存中查找合适的内存块返回，这里可以选择一个最快获取的算法（first-fit），或者最优选择（best-fit）。二者往往无法两全。另外需要考虑一个根本性的问题就是内存碎片，释放内存时往往与申请顺序不同，会在内存中留下大量的空洞，当有大量不连续的小内存即碎片出现时，便会产生空闲内存很多但是无法分配大块内存的情况。对于操作系统，需要长时间运行，内存碎片的问题便显得非常突出了。&lt;/p&gt;
&lt;p&gt;Linux内核一种分配内存的方式是alloc_pages，使用伙伴算法，但这个只适应于按页分配，如果需要几个字节的内存都分配4k，显然会是极大的浪费，所以内核又提供了一种小内存的分配方式，称之为slab，另外还有两种可选的分配方式，slob和slub，slob是为了在嵌入式环境中使用，slub在一些大型设备中币slab有更优秀的性能。但作为程序开发者来说，无需关心内核选用了哪种分配方式，三者具有相同的接口，调用者可以忽略其中的差别。&lt;/p&gt;
&lt;p&gt;因为在内核中需要频繁分配同类型的对象，比如频繁分配socket，task_struct等结构体对象，slab一个核心思想就是一个slab分配器只分配一种对象，这样做的好处便是每个slab只分配等大小的内存，能够很好的兼顾效率和内存碎片的问题，当然slab最终也是通过alloc_pages按页分配的内存。&lt;/p&gt;
&lt;h2 id=&#34;直观认识&#34;&gt;直观认识&lt;/h2&gt;
&lt;p&gt;先来通过命令直观的了解一下slab的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /proc/slabinfo
slabinfo - version: 2.1
# name                 : tunables    : slabdata   
kmalloc_dma-512        8      8    512    8    1 : tunables    0    0    0 : slabdata      1      1      0
UDPLITEv6              0      0    704   11    2 : tunables    0    0    0 : slabdata      0      0      0
UDPv6                 11     11    704   11    2 : tunables    0    0    0 : slabdata      1      1      0
...
kmalloc-8          13156  13312      8  512    1 : tunables    0    0    0 : slabdata     26     26      0
kmalloc-192          352    420    192   21    1 : tunables    0    0    0 : slabdata     20     20      0
kmalloc-96         14293  14322     96   42    1 : tunables    0    0    0 : slabdata    341    341      0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以很直观的看到每种对象的slab分配情况，从名称不难看出每种slab的作用，从名字kmalloc-8等也能猜测出这是调用kmalloc时分配的内存，内存也是按照一定规则递增分配。&lt;/p&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;p&gt;slab分配器的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/keep/2014/0_kernel-slab-design.gif&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;slab allocator&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;每种具体的内存分配器都由kmem_cache表示，多个kmem_cache组成分配器链，kmem_cache又由三部分组成，slabs_full表示已经完全分配出去的slab，slabs_partial表示部分分配，slabs_empty表示未进行分配。具体的实现原理分析可以放到最后，这里可以查看一下如何使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义一个slab实例
struct struct kmem_cache * test_cache;
// 创建一个新缓存
struct kmem_cache *kmem_cache_create(const char *, size_t, size_t,
                        unsigned long,
                        void (*)(void *));
// 销毁缓存
void kmem_cache_destroy(struct kmem_cache *); 
// 分配内存
void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
// 释放内存
void kmem_cache_free(struct kmem_cache *, void *);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用法例子&#34;&gt;用法例子&lt;/h2&gt;
&lt;p&gt;接下来可以写一段代码来体验一下slab的用法，这里在 Linux字符设备框架 的基础上添加代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;linux/init.h&amp;gt; 
#include&amp;lt;linux/module.h&amp;gt; 
 
#include&amp;lt;linux/fs.h&amp;gt; 
#include&amp;lt;linux/types.h&amp;gt; 
#include&amp;lt;linux/cdev.h&amp;gt; 
#include&amp;lt;linux/mm.h&amp;gt; 
#include&amp;lt;linux/sched.h&amp;gt; 
#include&amp;lt;asm/io.h&amp;gt; 
#include&amp;lt;asm/uaccess.h&amp;gt; 
#include&amp;lt;asm/system.h&amp;gt; 
 
#include&amp;lt;linux/device.h&amp;gt; 
 
#define OBJECT_SIZE        27 
#define OBJECT_NUM        10 
dev_t devno; 
struct class * simple_class; 
static struct cdev cdev; 
 
struct kmem_cache * cppbreak_cache; 
 
struct cache_object { 
    void * object; 
    struct list_head list; 
}; 
 
LIST_HEAD(head); 
 
ssize_t simple_write(struct file * filp, 
    const char __user * buf, size_t size, loff_t * ppos) 
{ 
    char command[OBJECT_SIZE] = {}; 
    int num = 0; 
    int i = 0; 
    if (size &amp;gt;= OBJECT_SIZE || size &amp;lt; 3) { 
        return -EFAULT; 
    } 
    if (copy_from_user(command, buf, size)) 
        return -EFAULT; 
    command[size] = &#39;0&#39;; 
 
    printk(&amp;quot;Cache name is %s\n&amp;quot;, kmem_cache_name(cppbreak_cache)); 
    printk(&amp;quot;Cache object size is %d\n&amp;quot;, kmem_cache_size(cppbreak_cache)); 
 
    num = simple_strtol(command + 2, NULL, 10); 
 
    printk(&amp;quot;command is %s, num=%d\n&amp;quot;, command, num); 
    if (command[0] == &#39;i&#39;) { 
        for (i = 0; i &amp;lt; num; i++) { 
            struct cache_object * object = (struct cache_object *)kmem_cache_alloc(cppbreak_cache, GFP_KERNEL); 
            list_add_tail(&amp;amp;object-&amp;gt;list, &amp;amp;head); 
        } 
    } 
    else if (command[0] == &#39;d&#39;) { 
        for (i = 0; i &amp;lt; num &amp;amp;&amp;amp; !list_empty(&amp;amp;head); i++) { 
            struct cache_object * object = 
                (struct cache_object *)list_entry( 
                    head.next, 
                    struct cache_object, 
                    list); 
            list_del(&amp;amp;object-&amp;gt;list); 
            kmem_cache_free(cppbreak_cache, object); 
        } 
    } 
    else { 
        return -EFAULT; 
    } 
    return size; 
} 
 
int simple_open(struct inode * pnode, struct file * pfile) 
{ 
    printk(KERN_INFO &amp;quot;open simple\n&amp;quot;); 
    return 0; 
} 
 
int simple_release(struct inode * pnode, struct file * pfile) 
{ 
    printk(KERN_INFO &amp;quot;close simple\n&amp;quot;); 
    return 0; 
} 
 
static struct file_operations simple_op =  
{ 
    .owner = THIS_MODULE, 
    .write = simple_write, 
    .open = simple_open, 
    .release = simple_release, 
}; 
 
static int __init initialization(void) 
{ 
    int result; 
 
    result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;quot;simple&amp;quot;); 
    if (result &amp;lt; 0) 
        return result; 
 
    cdev_init(&amp;amp;cdev, &amp;amp;simple_op); 
    result = cdev_add(&amp;amp;cdev, devno, 1); 
 
    simple_class = class_create(THIS_MODULE, &amp;quot;simple&amp;quot;); 
    device_create(simple_class, NULL, devno, NULL, &amp;quot;simple&amp;quot;); 
 
    printk(KERN_INFO &amp;quot; init simple\n&amp;quot;); 
 
    cppbreak_cache = kmem_cache_create(&amp;quot;cppbreak&amp;quot;, OBJECT_SIZE, 0, SLAB_HWCACHE_ALIGN, NULL); 
    if (cppbreak_cache == NULL) { 
        printk(KERN_INFO &amp;quot; kmem_cache_create failed\n&amp;quot;); 
        return -10; 
    } 
    printk(KERN_INFO &amp;quot; kmem_cache_create succ\n&amp;quot;); 
    return result; 
} 
 
static void __exit cleanup(void) 
{ 
    if (cppbreak_cache) { 
        kmem_cache_destroy(cppbreak_cache); 
        printk(KERN_INFO &amp;quot; kmem_cache_destroy succ\n&amp;quot;); 
    } 
    device_destroy(simple_class, devno); 
    class_destroy(simple_class); 
 
    cdev_del(&amp;amp;cdev); 
    unregister_chrdev_region(devno, 1); 
    printk(KERN_INFO &amp;quot; cleanup simple\n&amp;quot;); 
} 
 
module_init(initialization); 
module_exit(cleanup); 
 
MODULE_AUTHOR(&amp;quot;cppbreak@gmail.com&amp;quot;); 
MODULE_DESCRIPTION(&amp;quot;slab tester&amp;quot;); 
MODULE_VERSION(&amp;quot;V0.1&amp;quot;); 
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的代码比较简单，modprobe 模块时创建一个文件系统节点和slab分配器，之后便可在&lt;code&gt;echo “i n” &amp;gt; /dev/simple&lt;/code&gt; 来分配n个object，&lt;code&gt;echo “d n” &amp;gt; /dev/simple&lt;/code&gt; 来释放n个object。关于内核链表的应用，可以查看 内核数据结构-链表。&lt;/p&gt;
&lt;p&gt;使用modprobe加载内核之后，便可看到 /proc/slabinfo 增加了 &lt;code&gt;cppbreak_slab&lt;/code&gt; 节点，可以看到&lt;code&gt;object_size&lt;/code&gt;信息，之后便可通过添加节点删除节点来查看响应的分配数值变化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost module]# insmod simple.ko
[root@localhost module]# cat /proc/slabinfo | grep cppbreak
cppbreak               0      0     32  112    1 : tunables  120   60    0 : slabdata      0      0      0
[root@localhost module]# echo &amp;quot;i 10&amp;quot; &amp;gt; /dev/simple 
[root@localhost module]# cat /proc/slabinfo | grep cppbreak
cppbreak              10    112     32  112    1 : tunables  120   60    0 : slabdata      1      1      0
[root@localhost module]# echo &amp;quot;d 10&amp;quot; &amp;gt; /dev/simple 
[root@localhost module]# cat /proc/slabinfo | grep cppbreak
cppbreak               5    112     32  112    1 : tunables  120   60    0 : slabdata      1      1      0
[root@localhost module]#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里便介绍了slab的调用方法，具体的细节和实现过程需要下篇分解了。&lt;/p&gt;
&lt;h1 id=&#34;slab-实现&#34;&gt;slab 实现&lt;/h1&gt;
&lt;p&gt;slab 除了作为内存分配器以外，还有一个重要的功能便是做CPU的高速缓存，slab会把当前cpu释放的对象保存在对应cpu的数组上，这样如果下次还是这个cpu分配相同的对象，直接从对应数组返回，这里利用了cpu的告诉缓存，cpu刚释放的空间仍然存在于它的高速缓存中的概率会很大。&lt;/p&gt;
&lt;p&gt;分析slab的具体实现。首先可以浏览一下关键数据结构 kmem_cache 的实现（注意这里结构体的定义有三个分别是slab，slub，slob的实现，slab的实现位于文件 include/linux/slab_def.h）&lt;/p&gt;
&lt;h2 id=&#34;第一部分kmem_cache-结构体&#34;&gt;第一部分：kmem_cache 结构体&lt;/h2&gt;
&lt;p&gt;根据内核代码注释，kmem_cache分为6个部分，第一部分是 Cache tunables&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
/* 1) Cache tunables. Protected by cache_chain_mutex */
        unsigned int batchcount;
        unsigned int limit;
        unsigned int shared;

        unsigned int buffer_size;
        u32 reciprocal_buffer_size;
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;batchcount 表示在per-CPU列表为空的情况下，从缓存的slab获取对象的数目。limit指定per-CPU列表中保存的对象最大数目，如果超过该值，内核会将batchcount个对象返回到slab。这里的参数便是与cpu高速缓存相关的控制参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buffer_size&lt;/code&gt;表示缓存管理对象的长度。&lt;/p&gt;
&lt;h2 id=&#34;第二部分&#34;&gt;第二部分：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 2) touched by every alloc &amp;amp; free from the backend */
        unsigned int flags;             /* constant flags */
        unsigned int num;               /* # of objs per slab */
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;num 是每个slab中的object数量。&lt;/p&gt;
&lt;h2 id=&#34;第三部分&#34;&gt;第三部分：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 3) cache_grow/shrink */
        /* order of pgs per slab (2^n) */
        unsigned int gfporder;

        /* force GFP flags, e.g. GFP_DMA */
        gfp_t allocflags;

        size_t colour;                  /* cache colouring range */
        unsigned int colour_off;        /* colour offset */
        struct kmem_cache *slabp_cache;
        unsigned int slab_size;
        unsigned int dflags;            /* dynamic flags */

        /* constructor func */
        void (*ctor)(void *obj);
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里于分配相关的参数，主要的参数是颜色范围。&lt;/p&gt;
&lt;h2 id=&#34;第四部分&#34;&gt;第四部分：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 4) cache creation/removal */
        const char *name;
        struct list_head list;
        int refcount;
        int object_size;
        int align;
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分存储了缓存的名称和缓存的list_head节点。&lt;/p&gt;
&lt;h2 id=&#34;第五部分&#34;&gt;第五部分&lt;/h2&gt;
&lt;p&gt;主要是统计之用，开启了&lt;code&gt;CONFIG_DEBUG_SLAB&lt;/code&gt;宏才会生效，与slab分配算法无关。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 5) statistics */
        unsigned long num_active;
        unsigned long num_allocations;
        unsigned long high_mark;
        unsigned long grown;
        unsigned long reaped;
        unsigned long errors;
        unsigned long max_freeable;
        unsigned long node_allocs;
        unsigned long node_frees;
        unsigned long node_overflow;
        atomic_t allochit;
        atomic_t allocmiss;
        atomic_t freehit;
        atomic_t freemiss;

        /*
         * If debugging is enabled, then the allocator can add additional
         * fields and/or padding to every object. size contains the total
         * object size including these internal fields, the following two
         * variables contain the offset to the user object and its size.
         */
        int obj_offset;
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第六部分&#34;&gt;第六部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 6) per-cpu/per-node data, touched during every alloc/free */
        /*
         * We put array[] at the end of kmem_cache, because we want to size
         * this array to nr_cpu_ids slots instead of NR_CPUS
         * (see kmem_cache_init())
         * We still use [NR_CPUS] and not [1] or [0] because cache_cache
         * is statically defined, so we reserve the max number of cpus.
         */
        struct kmem_list3 **nodelists;
        struct array_cache *array[NR_CPUS];
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后这部分是per-CPU相关变量，array很容易理解，既是每个cpu对应的数组。另外一个成员nodelists存储了 &lt;code&gt;slabs_partia&lt;/code&gt;l，&lt;code&gt;slabs_full&lt;/code&gt;，&lt;code&gt;slabs_free&lt;/code&gt;链表，并记录链表空闲节点等信息，这个结构体便是给per-CPU数组提供object的缓存池，注意这里是一个指针的指针，是 &lt;code&gt;kmem_list3&lt;/code&gt; 的二维数组，其中第一个维度是与cpu最接近的内存块索引。&lt;/p&gt;
&lt;h1 id=&#34;创建过程&#34;&gt;创建过程&lt;/h1&gt;
&lt;p&gt;接下来看&lt;code&gt;kmem_cache&lt;/code&gt;节点的创建过程，&lt;code&gt;kmem_cache_create&lt;/code&gt; 分为几个部分：&lt;/p&gt;
&lt;h2 id=&#34;一检查参数的合理性&#34;&gt;一、检查参数的合理性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if (!name || in_interrupt() || (size &amp;lt; BYTES_PER_WORD) ||             size &amp;gt; KMALLOC_MAX_SIZE) {
        printk(KERN_ERR &amp;quot;%s: Early error in slab %s\n&amp;quot;, __func__,
                        name);
        BUG();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看名字是否为空，分配大小是否大于分配的最大值KMALLOC_MAX_SIZE，是否小于CPU字长等，之后进行了去重检测，防止创建相同名称的缓存。&lt;/p&gt;
&lt;h2 id=&#34;二计算对齐&#34;&gt;二、计算对齐&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if (size &amp;amp; (BYTES_PER_WORD - 1)) {
        size += (BYTES_PER_WORD - 1);
        size &amp;amp;= ~(BYTES_PER_WORD - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照处理器字长对其。之后根据flag 的ARCH参数计算对齐。&lt;/p&gt;
&lt;h2 id=&#34;三分配缓存结构&#34;&gt;三、分配缓存结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cachep = kmem_cache_zalloc(&amp;amp;cache_cache, gfp);
if (!cachep)
        goto oops;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cache_cache 是缓存的slab分配器，这里创建出一个新的cache实例，存入cachep，这里就会出现一个问题，便是mem_cache的创建需要调用alloc，但是cache_cache是如何分配出来的呢，这里涉及到slab的初始化问题，之后再讨论。&lt;/p&gt;
&lt;h2 id=&#34;四确定slab头的存储位置&#34;&gt;四、确定slab头的存储位置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if ((size &amp;gt;= (PAGE_SIZE &amp;gt;&amp;gt; 3)) &amp;amp;&amp;amp; !slab_early_init &amp;amp;&amp;amp;
    !(flags &amp;amp; SLAB_NOLEAKTRACE))
        /*
         * Size is large, assume best to place the slab management obj
         * off-slab (should allow better packing of objs).
         */
        flags |= CFLGS_OFF_SLAB;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果object大小大于页帧的八分之一，则将管理数据放到slab之外。&lt;/p&gt;
&lt;h2 id=&#34;五calculate_slab_order&#34;&gt;五、calculate_slab_order&lt;/h2&gt;
&lt;p&gt;现在已经确定缓存对象的size，现在需要估算slab的长度，函数&lt;code&gt;calculate_slab_order&lt;/code&gt;通过对象size，align和flags计算slab应该使用多少页帧，如果页帧过少则存储的对象过少，增加分配管理的开销，如果页帧过多，则空间过于浪费。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (gfporder = 0; gfporder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数循环中gfporder为页帧数量，对指定的页帧，通过函数cache_estimate计算能够存储的数量num以及浪费的空间remainder，计算的公式为： PAGE_SIZE &amp;laquo; gfporder = head + num * size + left_over。
如果对象存储在slab之外，则&lt;code&gt;head（mgmt_size）&lt;/code&gt;为0，如果对象存储于slab之内，则 &lt;code&gt;head = sizeof(struct slab) + num*sizeof(kmem_bufctl_t)&lt;/code&gt;。接着&lt;code&gt;calculate_slab_order&lt;/code&gt;之后便是循环退出的各种条件。&lt;/p&gt;
&lt;h2 id=&#34;六着色&#34;&gt;六、着色&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cachep-&amp;gt;colour_off = cache_line_size();
/* Offset must be a multiple of the alignment. */
if (cachep-&amp;gt;colour_off &amp;lt; align)                 cachep-&amp;gt;colour_off = align;
cachep-&amp;gt;colour = left_over / cachep-&amp;gt;colour_off;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;colour_off&lt;/code&gt; 计算颜色偏移，colour颜色数量，紧接着初始化函数对cache的变量赋值。&lt;/p&gt;
&lt;h2 id=&#34;七setup_cpu_cache&#34;&gt;七、setup_cpu_cache&lt;/h2&gt;
&lt;p&gt;调用enable_cpucache初始化per-CPU变量。&lt;/p&gt;
&lt;h2 id=&#34;八加入全局链表&#34;&gt;八、加入全局链表&lt;/h2&gt;
&lt;p&gt;函数的最后加入全局链表&lt;code&gt;cache_chain&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来看缓存分配过程，&lt;code&gt;kmem_cache_alloc&lt;/code&gt;，函数调用&lt;code&gt;__cache_alloc&lt;/code&gt; -&amp;gt; &lt;code&gt;____cache_alloc&lt;/code&gt; 完成主要功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ac = cpu_cache_get(cachep);
if (likely(ac-&amp;gt;avail)) {
        STATS_INC_ALLOCHIT(cachep);
        ac-&amp;gt;touched = 1;
        objp = ac-&amp;gt;entry[--ac-&amp;gt;avail];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果per-CPU缓存能够使用，则直接从cpu缓存中返回对象。否则通过函数 cache_alloc_refill 从slab中分配。cache_alloc_refill 的作用主要从slab中获取batchcount个对象放入per-CPU缓存。&lt;/p&gt;
&lt;p&gt;这里涉及到另外一个问题，如果当前slab空闲缓存不足，需调用 cache_grow 函数重新分配新的slab节点。
cache_grow 执行时首先计算颜色值，颜色值加一，如果超过最大值，则返回从0开始，这里的颜色值主要是一个偏移。&lt;/p&gt;
&lt;p&gt;slab所需的内存使用是&lt;code&gt;kmem_getpages&lt;/code&gt;从伙伴系统分配的，如果slab头存储在slab之外，则调用 &lt;code&gt;alloc_slabmgmt&lt;/code&gt;函数分配所需要的空间。&lt;/p&gt;
&lt;p&gt;最后对slab对象初始化之后添加到nodelists的free链表中。&lt;/p&gt;
&lt;p&gt;分配完毕如果对象对象释放，使用函数 &lt;code&gt;kmem_cache_free&lt;/code&gt;，释放过程如果per-CPU中尚有剩余位置，讲对象放入对应数组中，如果没有，则释放到对应的nodelists中。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核数据结构</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-data-structure/</link>
        <pubDate>Sat, 17 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-data-structure/</guid>
        <description>&lt;h1 id=&#34;内核链表&#34;&gt;内核链表&lt;/h1&gt;
&lt;p&gt;Linux内核有一些基本的数据结构，这些数据结构是Linux实现的基础，对于链表相信大家都不陌生，但是Linux内核中的链表与平常平常我们所使用的链表略有不同，第一次遇到或许会感到困惑。&lt;/p&gt;
&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;p&gt;先来看一个链表的节点，对于一个节点，分为两部分，一部分是数据，另一部分是串联数据的指针。Linux链表节点的定义如下(以下代码皆为3.5版本)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// include/linux/types.h
struct list_head {
        struct list_head *next, *prev;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的定义有些奇怪，因为仅有前后节点的指针，并没有数据，就像一串链子，只有线没有线上的珠子，肯定是无法使用，那Linux内核如何把这些“珠子”附着到线上的呢？&lt;/p&gt;
&lt;p&gt;来看一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struce simple {
	int data;
	struct list_head list;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;simple结构体的list成员指向下一个或者上一个simple的list，这样便把节点串联起来了，data作为“珠子”附着在list线上，但这样仍然有一个问题，list成员仅仅指向下一个simple的list成员，那从list成员如何得到simple节点的地址呢？&lt;/p&gt;
&lt;p&gt;答案是根据list成员的地址以及list成员在simple的位置便可以计算出simple对象的地址，这样有些繁琐，Linux提供了一个宏，可以简化这个过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// include/linux/list.h
/**
 * list_entry - get the struct for this entry
 * @ptr:        the &amp;amp;struct list_head pointer.
 * @type:       the type of the struct this is embedded in.
 * @member:     the name of the list_struct within the struct.
 */
#define list_entry(ptr, type, member) \
        container_of(ptr, type, member)

// include/linux/kernel.h
#define container_of(ptr, type, member) ({                      \
        const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})

#undef offsetof
#ifdef __compiler_offsetof
#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &amp;amp;((TYPE *)0)-&amp;gt;MEMBER)
#endif
#endif /* __KERNEL__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;list_entry&lt;/code&gt;直接调用了&lt;code&gt;container_of&lt;/code&gt;，&lt;code&gt;container_of&lt;/code&gt;分为两句，&lt;code&gt;((type *)0)-&amp;gt;member&lt;/code&gt;可以获得member在结构体type中的偏移，假设有一个结构体在地址0的位置，那么成员的地址便是成员对结构体的偏移，typeof是gcc的扩展，用于获取变量的类型，&lt;code&gt;offsetof(type,member)&lt;/code&gt; 获取member成员在type中的偏移，然后使用member成员的指针ptr（复制成&lt;code&gt;__mptr&lt;/code&gt;）减去偏移，即是结构体的地址。在我们的例子中，从list成员的地址获取simple结构的地址如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;simple * p = list_entry(ptr, struct simple, list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样便解决了从&lt;code&gt;list_head&lt;/code&gt;上获取附着的数据的问题。接下来需要解决对链表的增删改查的问题：&lt;/p&gt;
&lt;h2 id=&#34;初始化链表&#34;&gt;初始化链表&lt;/h2&gt;
&lt;p&gt;初始化链表有两种方法，LIST_HEAD_INIT和LIST_HEAD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }

#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
        list-&amp;gt;next = list;
        list-&amp;gt;prev = list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个指向自身的节点。&lt;/p&gt;
&lt;h2 id=&#34;插入节点&#34;&gt;插入节点&lt;/h2&gt;
&lt;p&gt;在节点后插入新节点&lt;code&gt;list_add_tail&lt;/code&gt;，和在节点前插入新节点&lt;code&gt;list_add&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
        __list_add(new, head, head-&amp;gt;next);
}

/**     
 * list_add_tail - add a new entry
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
        __list_add(new, head-&amp;gt;prev, head);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;__list_add&lt;/code&gt; 只是普通的链表操作，并无特别之处，可参见Linux源码查看实现。&lt;/p&gt;
&lt;h2 id=&#34;删除节点&#34;&gt;删除节点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;static inline void list_del(struct list_head *entry)
{
        __list_del(entry-&amp;gt;prev, entry-&amp;gt;next);
        entry-&amp;gt;next = LIST_POISON1;
        entry-&amp;gt;prev = LIST_POISON2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__list_del&lt;/code&gt; 把entry从链表中删除，之后把entry链表指针复制成非空指针（如果使用会出现段错误）&lt;/p&gt;
&lt;h2 id=&#34;检查是否空链表&#34;&gt;检查是否空链表&lt;/h2&gt;
&lt;p&gt;判断一个链表是否为空，只需要看头节点是否指向自己便可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline int list_empty(const struct list_head *head)
{
        return head-&amp;gt;next == head;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;遍历链表&#34;&gt;遍历链表&lt;/h2&gt;
&lt;p&gt;遍历是这几种操作中最为复杂的，有四个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define list_for_each(pos, head) \
        for (pos = (head)-&amp;gt;next; pos != (head); pos = pos-&amp;gt;next)

#define list_for_each_prev(pos, head) \
        for (pos = (head)-&amp;gt;prev; pos != (head); pos = pos-&amp;gt;prev)

#define list_for_each_entry(pos, head, member)                          \
        for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member);      \
             &amp;amp;pos-&amp;gt;member != (head);    \
             pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))

#define list_for_each_entry_reverse(pos, head, member)                  \
        for (pos = list_entry((head)-&amp;gt;prev, typeof(*pos), member);      \
             &amp;amp;pos-&amp;gt;member != (head);    \
             pos = list_entry(pos-&amp;gt;member.prev, typeof(*pos), member))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;list_for_each&lt;/code&gt; 和 &lt;code&gt;list_for_each_prev&lt;/code&gt; 较为简单，一个向后遍历，另一个向前遍历，&lt;code&gt;list_for_each_entry&lt;/code&gt;和&lt;code&gt;list_for_each_entry_reverse&lt;/code&gt;功能相似，不过不是对&lt;code&gt;list_head&lt;/code&gt;操作，而是直接对结构体操作，如我们这里的simple结构。根据之前的叙述也不难理解函数实现，只是在&lt;code&gt;list_head&lt;/code&gt;上调用了&lt;code&gt;list_entry&lt;/code&gt;获取了完整结构。&lt;/p&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;千言万语不如一个例子来的直观，我们通过一个简单的例子说明一下如何使用内核链表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/list.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

struct simple {
    int data;
    struct list_head list;
};

int main()
{
    int i = 0;
    struct simple * p;
    struct list_head * pos;
    LIST_HEAD(head);
    for (i = 0; i &amp;lt; 10; i++) {
        p = (struct simple*)malloc(sizeof(struct simple));
        p-&amp;gt;data = i * 10;
        list_add_tail(&amp;amp;p-&amp;gt;list, &amp;amp;head);
    }

    list_for_each_entry(p, &amp;amp;head, list) {
        printf(&amp;quot;for %d\n&amp;quot;, p-&amp;gt;data);
    }

    while (!list_empty(&amp;amp;head)) {
        pos = head.next;
        p = (struct simple*)list_entry(pos,
                struct simple, list);
        list_del(pos);
        printf(&amp;quot;del %d\n&amp;quot;, p-&amp;gt;data);
        free(p);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译参数为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcc -D__KERNEL__ -I/usr/src/linux-headers-3.2.0-27-generic/include/ -I/usr/src/linux-headers-3.2.0-27-generic/arch/ia64/include/ simple.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中头文件中都是内核函数，需要宏&lt;code&gt;__KERNEL__&lt;/code&gt;，否则大部分定义会被忽略。&lt;/p&gt;
&lt;h1 id=&#34;hash表&#34;&gt;Hash表&lt;/h1&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;链表虽然是最常见的数据结构，但实际使用中，由于链表的检索能力较差，更多的是作为队列和栈结构使用，如果需要查询，比如通过pid查找进程，通过描述符查找inode，就需要用到检索更快的数据结构——Hash表。
先来看Hash节点的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct hlist_head {
	struct hlist_node *first;
};
struct hlist_node {
	struct hlist_node *next, **pprev;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;hlist_head&lt;/code&gt; 为头结点，与链表不同的是还需要一个节点的概念 &lt;code&gt;hlist_node&lt;/code&gt;，他们之间的关系如图：&lt;/p&gt;
&lt;p&gt;左侧是定长数组，每个节点是 &lt;code&gt;hlist_head&lt;/code&gt; ，其中first指向 &lt;code&gt;hlist_node&lt;/code&gt; 节点，&lt;code&gt;hlist_node&lt;/code&gt;又组成一列链表，&lt;code&gt;hlist_node&lt;/code&gt;的链表结构跟 &lt;code&gt;list_head&lt;/code&gt;不同之处在于 &lt;code&gt;hlist_node&lt;/code&gt; 的 pprev 指向了 前一个节点的指针地址。&lt;/p&gt;
&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;
&lt;p&gt;Hash表使用起来也非常简单，首先通过hash函数计算目标值，得到一个索引，在&lt;code&gt;hlist_head&lt;/code&gt;数组中找到相应位置，再插入链表。Hash的链表Linux也提供了多种操作方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define INIT_HLIST_HEAD(ptr) ((ptr)-&amp;gt;first = NULL)
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h);
static inline void hlist_add_before(struct hlist_node *n, 
		struct hlist_node *next)
static inline void hlist_add_after(struct hlist_node *n, 
		struct hlist_node *next)
static inline void hlist_move_list(struct hlist_head *old,
		struct hlist_head *new);

#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
#define hlist_for_each(pos, head) \     
        for (pos = (head)-&amp;gt;first; pos ; pos = pos-&amp;gt;next)
#define hlist_for_each_entry(tpos, pos, head, member)                    \
        for (pos = (head)-&amp;gt;first;                                        \
             pos &amp;amp;&amp;amp;                                                      \
                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
             pos = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;INIT_HLIST_HEAD&lt;/code&gt; —— 初始化链表；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_add_head&lt;/code&gt; —— 在链表头插入节点；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_add_before&lt;/code&gt; —— 在一个节点之前插入；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_add_after&lt;/code&gt; —— 在一个节点之后插入；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_entry&lt;/code&gt; —— 同list_entry；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_for_each&lt;/code&gt; —— 相关的一系列函数进行链表的遍历，与普通双向链表操作相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了Hash表中链表的操作，还有一个重要的元素是Hash函数，Hash函数的好坏直接影响Hash表的性能，Hash函数一般来讲跟具体要实现的业务相关，include/linux/jhash.h下实现了几个不同用途的Hash函数，另外，Linux还给出一个简单的Hash函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline u32 hash_32(u32 val, unsigned int bits)
{
        /* On some cpus multiply is faster, on others gcc will do shifts */
        u32 hash = val * GOLDEN_RATIO_PRIME_32;

        /* High bits are more random, so use them. */
        return hash &amp;gt;&amp;gt; (32 - bits);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数把32位整数Hash成bits位的整数，另外还有 &lt;code&gt;hash_64&lt;/code&gt; 等等Hash函数。&lt;/p&gt;
&lt;h2 id=&#34;实例-1&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;最后再来通过一个简单的例子看一下Hash表的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/list.h&amp;gt;
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/hash.h&amp;gt;

struct simple_hash
{
    int data;
    struct hlist_node node;
};

struct hlist_head * phash = NULL;

static int __init initialization(void)
{
    int i,k;
    struct hlist_head * phead;
    struct hlist_node * pnode;
    struct simple_hash * p;

    printk(KERN_INFO &amp;quot; init simple start\n&amp;quot;);

    phash = (struct hlist_head*)kmalloc(sizeof(struct hlist_head) * 0xFF, GFP_KERNEL);
    for (i = 0; i &amp;lt; 0xFF; i++) {
        INIT_HLIST_HEAD(&amp;amp;phash[i]);
    }
    for (i = 0; i &amp;lt; 10; i++) {
        p = (struct simple_hash*)kmalloc(sizeof(struct simple_hash), GFP_KERNEL);
        k = i * 13;

        p-&amp;gt;data = k;
        INIT_HLIST_NODE(&amp;amp;p-&amp;gt;node);

        printk(KERN_INFO &amp;quot;insert %d\n&amp;quot;, k);
        phead = &amp;amp;phash[hash_32(k, 8)];
        hlist_add_head(&amp;amp;p-&amp;gt;node, phead);
    }
    k = 3 * 13;
    phead = &amp;amp;phash[hash_32(k, 8)];
    printk(KERN_INFO &amp;quot;search %d\n&amp;quot;, k);
    hlist_for_each_entry(p, pnode, phead, node) {
        if (p-&amp;gt;data == k) {
            printk(KERN_INFO &amp;quot; find it\n&amp;quot;);
        }
    }

    printk(KERN_INFO &amp;quot;init simple end\n&amp;quot;);
    return 0;
}

static void __exit cleanup(void)
{
    int i;
    struct hlist_head * phead = NULL;
    struct simple_hash * p = NULL;
    printk(KERN_INFO &amp;quot;cleanup simple\n&amp;quot;);

    if (phash == NULL) {
        return;
    }

    for (i = 0; i &amp;lt; 0xFF; i++) {
        phead = &amp;amp;phash[i];
        while (!hlist_empty(phead)) {
            p = hlist_entry(phead-&amp;gt;first, struct simple_hash, node);
            printk(KERN_INFO &amp;quot;delete %d&amp;quot;, p-&amp;gt;data);
            hlist_del(&amp;amp;p-&amp;gt;node);
            kfree(p);
        }
    }
    kfree(phead);
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;cppbreak cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.1&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的代码是一个简单的Linux内核，关于如何写一个简单的Linux内核，可以参阅 Linux字符设备驱动框架&lt;/p&gt;
&lt;h1 id=&#34;红黑树&#34;&gt;红黑树&lt;/h1&gt;
&lt;h2 id=&#34;定义-1&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;Hash表虽然检索复杂度只需要O(1)，但是性能依赖于Hash函数，不合适的Hash函数会导致性能极其低下，而且需要预分配Hash头结点的空间，扩展性和性能稳定性都是问题，所以Linux内核另外还有一套快速插入查询的数据结构——红黑树。&lt;/p&gt;
&lt;p&gt;红黑树是一种平衡二叉树，二叉树查找效率是O(logn)，但对于某些极端情况下，一个分支的节点远高于另一个分支，处于不平衡状态下的二叉树性能很差，极端情况跟链表相同。所以出现很多保持二叉树平衡的方法，其中一种便是红黑树，红黑树在二叉树的基础上又规定了一些规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性质1：节点是红色或黑色。&lt;/li&gt;
&lt;li&gt;性质2：根节点是黑色。&lt;/li&gt;
&lt;li&gt;性质3：每个叶节点是黑色的。&lt;/li&gt;
&lt;li&gt;性质4：每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)&lt;/li&gt;
&lt;li&gt;性质5：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;红黑树的性质保证了从根节点到任何一个叶子节点的长度都不会相差两倍以上，只要在增删的过程中保持红黑树的性质，也便保持了树的平衡性。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;红黑树在内核中的实现位于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;linux/lib/rbtree.c
linux/include/linux/rbtree.h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;头文件 rbtree.h 中有红黑树节点的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct rb_node
{
	unsigned long  rb_parent_color;
#define RB_RED          0
#define RB_BLACK        1
	struct rb_node *rb_right;
	struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));
/* The alignment might seem pointless, but allegedly CRIS needs it */

struct rb_root
{
	struct rb_node *rb_node;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到红黑树同链表一样，都没有数据块的定义，因为C语言中没有模版，这样实现能使数据结构跟具体的业务分离，&lt;code&gt;rb_root&lt;/code&gt; 中仅有一个 rb_node 域，rb_node中有颜色和左右节点的指针，都很容易理解。&lt;/p&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;p&gt;节点的初始化操作，节点默认被置为红色：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline void rb_init_node(struct rb_node *rb)
{
	rb-&amp;gt;rb_parent_color = 0;
	rb-&amp;gt;rb_right = NULL;
	rb-&amp;gt;rb_left = NULL;
	RB_CLEAR_NODE(rb);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;增删操作&#34;&gt;增删操作&lt;/h2&gt;
&lt;p&gt;红黑树的增加删除操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// node为已插入的节点，函数检查树的平衡性并修正
void rb_insert_color(struct rb_node *node, struct rb_root *root);
// 删除节点
void rb_erase(struct rb_node *node, struct rb_root *root);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于二叉树需要比较数据区域的大小，这里仅仅有节点是不够的，所以插入操作需要调用者比较插入，然后调用&lt;code&gt;rb_insert_color&lt;/code&gt;调整树的平衡性，&lt;code&gt;rb_erase&lt;/code&gt;可以直接删除，另外搜索操作也需要用户根据二叉树的性质自己处理，在头文件rbtree.h开头的注释给了一个使用的例子，这里再试着写一个简单的例子：&lt;/p&gt;
&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/rbtree.h&amp;gt;

struct simple
{
    int data;
    struct rb_node node;
};

struct simple * search_simple(struct rb_root * root, int data)
{
    struct simple * p;
    struct rb_node * pnode = root-&amp;gt;rb_node;
    while (pnode)
    {
        p = rb_entry(pnode, struct simple, node);
        if (data &amp;lt; p-&amp;gt;data) {
            pnode = pnode-&amp;gt;rb_left;
        } else if (data &amp;gt; p-&amp;gt;data){
            pnode = pnode-&amp;gt;rb_right;
        } else {
            return p;
        }
    }
    return NULL;
}

struct simple * insert_simple(struct rb_root * root,
        int data, struct simple * new)
{
    struct simple * p = NULL;
    struct rb_node ** pnode = &amp;amp;root-&amp;gt;rb_node;
    struct rb_node * parent = NULL;
    while (*pnode)
    {
        parent = *pnode;
        p = rb_entry(parent, struct simple, node);
        if (data &amp;lt; p-&amp;gt;data) {
            pnode = &amp;amp;(*pnode)-&amp;gt;rb_left;
        } else if (data &amp;gt; p-&amp;gt;data){
            pnode = &amp;amp;(*pnode)-&amp;gt;rb_right;
        } else {
            return p;
        }
    }
    rb_link_node(&amp;amp;new-&amp;gt;node, parent, pnode);
    rb_insert_color(&amp;amp;new-&amp;gt;node, root);
    return p;
}

struct rb_root g_root = RB_ROOT;

static int __init initialization(void)
{
    int i;
    struct simple * p;
    for (i = 0; i &amp;lt; 10; i++) {
        p = (struct simple *)kmalloc(sizeof (struct simple),
                GFP_KERNEL);
        p-&amp;gt;data = i * 10;
        rb_init_node(&amp;amp;p-&amp;gt;node);
        insert_simple(&amp;amp;g_root, i * 10, p);
        printk(KERN_INFO &amp;quot;insert %d\n&amp;quot;, i * 10);
    }
    p = search_simple(&amp;amp;g_root, 30);
    if (p != NULL) {
        printk(KERN_INFO &amp;quot;find it\n&amp;quot;);
    }

    return 0;
}

static void __exit cleanup(void)
{
    struct simple * p;
    struct rb_node * pnode = rb_first(&amp;amp;g_root);
    while (pnode != NULL) {
        p = rb_entry(pnode, struct simple, node);        
        printk(KERN_INFO &amp;quot;delete %d\n&amp;quot;, p-&amp;gt;data);
        rb_erase(pnode, &amp;amp;g_root);
        kfree(p);
        pnode = rb_first(&amp;amp;g_root);
    }
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;cppbreak cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.1&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序编译运行请参考 Linux字符设备驱动框架。&lt;/p&gt;
&lt;h1 id=&#34;radix-tree&#34;&gt;Radix Tree&lt;/h1&gt;
&lt;h2 id=&#34;定义-2&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;Linux内核实现了大量的数据结构，其中树结构除了前面提到的红黑树以外，还有一种很有意思的树-Radix Tree，翻译为基数树。Radix Tree也是一种key-value结构，要说最快速的key-value查找结构，非数组莫属，只需一次定位便可找到目标值，其缺点是需要占用过多的内存空间，如果连续的key中大多数都是空值，空间的利用率会非常低，如一个整数范围的key，value占一个字节也需要4G的存储，当key非常稀疏的情况下，无疑是一种浪费，Radix Tree的解决方式是分级，简单来说，如果按照整数的尾数分为2级，第一级需要10个指针即可，尾数为0的key映射到第一个指针上，第一个指针再指向存储数组，这样如果只有0-4的key，便可不需要给5-9的指针分配空间，可节省一半的空间。当然这只是简单的例子，内核的Radix Tree更为精炼。&lt;/p&gt;
&lt;h2 id=&#34;实现-1&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;Linux内核的根据Radix Tree的高度把key分为若干段，如下图所示，每段长度固定为&lt;code&gt;RADIX_TREE_MAP_SHIFT&lt;/code&gt;，树高度可通过&lt;code&gt;radix_tree_extend&lt;/code&gt;扩展，key的每一段分别指定了每一层的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/keep/2014/0_radix-tree.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Radix Tree&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;接下来可以看一些处理细节：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct radix_tree_node {
	unsigned int    height;         /* Height from the bottom */
	unsigned int    count;
	union {
		struct radix_tree_node *parent; /* Used when ascending tree */
		struct rcu_head rcu_head;       /* Used when freeing node */
	};
	void __rcu      *slots[RADIX_TREE_MAP_SIZE];
	unsigned long   tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;radix_tree_node&lt;/code&gt; 是基数树的节点定义，其中最主要的字段是 &lt;code&gt;RADIX_TREE_MAP_SIZE&lt;/code&gt; 大小的数组 slots，其中可以指向下一层节点或者叶子节点 item。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct radix_tree_root {
	unsigned int            height;
	gfp_t                   gfp_mask;
	struct radix_tree_node  __rcu *rnode;
};

#define RADIX_TREE_INIT(mask)   {                                       \
	.height = 0,                                                    \
	.gfp_mask = (mask),                                             \
	.rnode = NULL,                                                  \
}

#define RADIX_TREE(name, mask) \
struct radix_tree_root name = RADIX_TREE_INIT(mask)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;radix_tree_root&lt;/code&gt; 是根节点类型，记录了数高度 height 和第一层节点rnode，&lt;code&gt;RADIX_TREE_INIT&lt;/code&gt;宏对根节点初始化。&lt;/p&gt;
&lt;p&gt;接下来看基数树的核心，如何插入节点和如何查找节点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int radix_tree_insert(struct radix_tree_root *root,
				unsigned long index, void *item)
{
	/** 省略 */
	/* Make sure the tree is high enough.  */
	if (index &amp;gt; radix_tree_maxindex(root-&amp;gt;height)) {
		error = radix_tree_extend(root, index);
		if (error)
			return error;
	}

	slot = indirect_to_ptr(root-&amp;gt;rnode);

	height = root-&amp;gt;height;
	shift = (height-1) * RADIX_TREE_MAP_SHIFT;

	offset = 0;                     /* uninitialised var warning */
	while (height &amp;gt; 0) {
		if (slot == NULL) {
			/* Have to add a child node.  */
			if (!(slot = radix_tree_node_alloc(root)))
				return -ENOMEM;
			slot-&amp;gt;height = height;
			slot-&amp;gt;parent = node;
			if (node) {
				rcu_assign_pointer(node-&amp;gt;slots[offset], slot);
				node-&amp;gt;count++;
			} else
				rcu_assign_pointer(root-&amp;gt;rnode, ptr_to_indirect(slot));
		}

		/* Go a level down */
		offset = (index &amp;gt;&amp;gt; shift) &amp;amp; RADIX_TREE_MAP_MASK;
		node = slot;
		slot = node-&amp;gt;slots[offset];
		shift -= RADIX_TREE_MAP_SHIFT;
		height--;
	}

	/** 省略 */
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;篇幅关系简略了代码，代码首先使用 &lt;code&gt;radix_tree_maxindex&lt;/code&gt; 计算树高度是否能够存储 index，不行就调用 &lt;code&gt;radix_tree_extend&lt;/code&gt; 扩展树高度，紧接着根据key的每个字段定位节点，直到到达树叶子节点，如果树节点未分配空间，则调用 &lt;code&gt;radix_tree_node_alloc&lt;/code&gt; 分配，最后再把 item 挂接到叶子节点上，完成插入操作。&lt;/p&gt;
&lt;p&gt;基数树查找操作为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void *radix_tree_lookup_element(struct radix_tree_root *root,
			unsigned long index, int is_slot);

void *radix_tree_lookup(struct radix_tree_root *root, unsigned long index)
{
	return radix_tree_lookup_element(root, index, 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;radix_tree_lookup_element&lt;/code&gt; 查找过程与插入操作类似，比较容易理解。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux系统调用</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-system-call/</link>
        <pubDate>Fri, 16 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-system-call/</guid>
        <description>&lt;p&gt;操作系统管理软硬件资源，用户进程只能直接或间接的通过系统调用访问系统资源，而用户进程与内核运行于不同的权限空间，需要进行用户态到内核态的转变，这一转变是通过系统中断实现。现以getpid为例：&lt;/p&gt;
&lt;p&gt;在用户态通过API接口编程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main()
{
    return printf(&amp;quot;pid is %d\n&amp;quot;, getpid()) &amp;gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getpid 为应用编程接口(API)函数，提供统一标准接口，实现是通过系统调用获得进程ID。
系统调用函数由唯一的调用号标识，x86构架下在文件 arch/x86/include/asm/unistd.h 指定，实现文件根据32位系统与64为系统的不同分别实现在相同目录的unistd_32.h和unistd_64.h文件，现通过64位系统分析，32位系统原理相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define __NR_getpid                             39
__SYSCALL(__NR_getpid, sys_getpid)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到getpid系统调用号为 39， 当然这在不同的系统上并不一定相同，getpid API函数的封装正是封装了种种不同。&lt;/p&gt;
&lt;p&gt;系统初始化时创建名为 &lt;code&gt;sys_call_table&lt;/code&gt; 的表项，其中存储了系统调用函数，而&lt;code&gt;__NR_*&lt;/code&gt;调用号正是表项索引，&lt;code&gt;sys_call_table&lt;/code&gt;的定义 32构架位于 &lt;code&gt;arch/x86/kernel/syscall_table_32.S&lt;/code&gt;，&lt;code&gt;sys_call_table&lt;/code&gt; 为起始地址依次存储一系列函数地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::
ENTRY(sys_call_table)
	.long sys_restart_syscall	/* 0 - old &amp;quot;setup()&amp;quot; system call, used for restarting */
	.long sys_exit
	.long ptregs_fork
	.long sys_read
	.long sys_write
	.long sys_open		/* 5 */
	.long sys_close
	.long sys_waitpid
	.long sys_creat
	.long sys_link
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;64位构架位于&lt;code&gt;arch/x86/kernel/syscall_64.c&lt;/code&gt;，这里干脆定义成了一个&lt;code&gt;sys_call_ptr_t&lt;/code&gt;类型数组，其初始化由宏&lt;code&gt;__SYSCALL&lt;/code&gt;完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
	/*
	*Smells like a like a compiler bug -- it doesn&#39;t work
	*when the &amp;amp; below is removed.
	*/
	[0 ... __NR_syscall_max] = &amp;amp;sys_ni_syscall,
#include &amp;lt;asm/unistd_64.h&amp;gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统调用时，根据 &lt;code&gt;sys_call_table[__NR_getpid]&lt;/code&gt; 获得 &lt;code&gt;sys_getpid&lt;/code&gt; 地址调用之。如此，我们便可通过修改 &lt;code&gt;sys_call_table&lt;/code&gt; 的初始化和&lt;code&gt;__NR_*&lt;/code&gt;的定义来增加自己的系统调用和修改原来系统调用的执行方式。&lt;/p&gt;
&lt;p&gt;倘若增加我们自己的系统调用，那接下来一问题是我们如何调用？getpid函数由glibc库封装，接下来需要看如何直接调用该内核函数。当然，通过源码可以看到getpid的实现即为 &lt;code&gt;sys_getpid&lt;/code&gt; 函数，但因为调用需要进行特权级的转变，所以直接调用&lt;code&gt;sys_getpid&lt;/code&gt;函数是行不通的。&lt;/p&gt;
&lt;p&gt;在Linux内核 2.6.20 以前，是存在一系列宏方便调用的，不同参数调用&lt;code&gt;_syscall0&lt;/code&gt;,&lt;code&gt;_syscall1&lt;/code&gt;,&lt;code&gt;_syscall2&lt;/code&gt;等等，但是据说为了防止内核漏洞取消了这些宏，当然，从 2.6.19 拷贝出这些宏的实现，还是可以使用的，这里只是简单说明一下原理即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 摘自2.6.20内核源码 include/asm-x86_64/unistd.h */
#define __syscall &amp;quot;syscall&amp;quot;
...
#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile (__syscall \
	: &amp;quot;=a&amp;quot; (__res) \
	: &amp;quot;0&amp;quot; (__NR_##name) : __syscall_clobber ); \
__syscall_return(type,__res); \

/* 摘自2.6.20内核源码 include/asm-i386/unistd.h */
#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile (&amp;quot;int $0x80&amp;quot; \
        : &amp;quot;=a&amp;quot; (__res) \
        : &amp;quot;0&amp;quot; (__NR_##name)); \
__syscall_return(type,__res); \
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，64位系统使用 syscall 指令进行系统调用，32系统使用 int 0×80指令。以64位系统举例，直接调用getpid的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main()
{
	pid_t pid = 0;
	asm (
		&amp;quot;syscall&amp;quot; \
		: &amp;quot;=a&amp;quot;(pid) \
		: &amp;quot;0&amp;quot;(39) \
	);
	printf(&amp;quot;pid is %d\n&amp;quot;, pid);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此一来，我们便可通过通过syscall指令或者int指令调用我们自己定义的系统函数。&lt;/p&gt;
&lt;p&gt;更进一步，再调用syscall指令之后，系统进行用户态向内核态转变，这个过程分为两部分，一部分是硬件支持，即cpu所作操作，另一部分，是软件支持，位于 &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt; 和 &lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt; 文件的&lt;code&gt;system_call&lt;/code&gt;，这里暂不分析。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 设备驱动轮询编程</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-driver-select-implement/</link>
        <pubDate>Thu, 15 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-driver-select-implement/</guid>
        <description>&lt;p&gt;Linux系统下网络模型数select最为常用，当然，select只是检测文件系统数据状态，并不只局限于网络编程，select的功能需要底层驱动提供支持，其中核心应用即为&lt;a class=&#34;link&#34; href=&#34;./linux-kernel-waiting-queue/&#34; &gt;等待队列&lt;/a&gt;，其他模型，如poll和epoll，对驱动来说并无区别，驱动只是返回数据状态而已。&lt;/p&gt;
&lt;p&gt;那在驱动层面是如何支持select的呢？驱动需要实现&lt;code&gt;file_operations&lt;/code&gt;结构中的poll函数指针，其实现也非常简单，只是&lt;code&gt;poll_wait&lt;/code&gt;函数的调用，原型如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int (*poll) (struct file *, struct poll_table_struct *);
void poll_wait(struct file *filp, wait_queue_head_t *queue, poll_table * wait);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是poll_wait函数不会像它名字一样处于wait状态，仅供上层查询之用。其编程基本框架也比较固定，现修改 &lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/linux-character-driver.html&#34; &gt;字符驱动&lt;/a&gt; 中的simple程序，实现poll回调函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int simple_poll (struct file * filp, struct poll_table_struct * wait)
{
	unsigned int mask = 0;
	poll_wait(filp, &amp;amp;simple_queue, wait);

	if (len &amp;gt; 0)
	{
		mask |= POLLIN | POLLRDNORM;
	}

	return mask;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每次read之后都把len赋值为0，调用write把len赋值为数据长，poll中只需判断len，如果len大于0，则返回可读，整理之后，整个程序代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;

#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/cdev.h&amp;gt;
#include &amp;lt;linux/mm.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;
#include &amp;lt;asm/io.h&amp;gt;
#include &amp;lt;asm/uaccess.h&amp;gt;
#include &amp;lt;asm/system.h&amp;gt;

#include &amp;lt;linux/device.h&amp;gt;
#include &amp;lt;linux/poll.h&amp;gt;

dev_t devno;
struct class * simple_class;
static struct cdev cdev;

wait_queue_head_t simple_queue;

char test_data[255];
int len = 0;

unsigned int simple_poll (struct file * filp, struct poll_table_struct * wait)
{
	unsigned int mask = 0;
	poll_wait(filp, &amp;amp;simple_queue, wait);

	if (len &amp;gt; 0)
	{
		mask |= POLLIN | POLLRDNORM;
	}

	return mask;
}

ssize_t simple_read(struct file * pfile,
	char __user * buf, size_t size, loff_t * ppos)
{
	int ret = len;
	len = 0;
	if (copy_to_user(buf, test_data, ret))
		return -EFAULT;
	else
		return ret;
}

ssize_t simple_write(struct file * pfile, const char __user * buf, size_t count, loff_t * ppos)
{
	if (count &amp;gt; 255)
	{
		return -EFAULT;
	}

	if (!copy_from_user(test_data, buf, count))
	{
		len = count;
		wake_up(&amp;amp;simple_queue);
	}
	return len;
}

int simple_open(struct inode * pnode, struct file * pfile)
{
	printk(KERN_INFO &amp;quot;open simple\n&amp;quot;);
	return 0;
}

int simple_release(struct inode * pnode, struct file * pfile)
{
	printk(KERN_INFO &amp;quot;close simple\n&amp;quot;);
	return 0;
}

static struct file_operations simple_op = 
{
	.owner = THIS_MODULE,
	.read = simple_read,
	.open = simple_open,
	.release = simple_release,
	.write = simple_write,
	.poll = simple_poll,
};

static int __init initialization(void)
{
	int result;

	result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;quot;simple&amp;quot;);
	if (result &amp;lt; 0)
		return result;

	cdev_init(&amp;amp;cdev, &amp;amp;simple_op);
	result = cdev_add(&amp;amp;cdev, devno, 1);

	simple_class = class_create(THIS_MODULE, &amp;quot;simple&amp;quot;);
	device_create(simple_class, NULL, devno, NULL, &amp;quot;simple&amp;quot;);

	printk(KERN_INFO &amp;quot; init simple\n&amp;quot;);

	init_waitqueue_head(&amp;amp;simple_queue);

	return result;
}

static void __exit cleanup(void)
{
	device_destroy(simple_class, devno);
	class_destroy(simple_class);

	cdev_del(&amp;amp;cdev);
	unregister_chrdev_region(devno, 1);
	printk(KERN_INFO &amp;quot; cleanup simple\n&amp;quot;);
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;alloc cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.1&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户态使用select测试程序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/select.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
int main()
{
	int fd, ret;
	char data[255];
	fd_set set;

	fd = open(&amp;quot;/dev/simple&amp;quot;, O_RDONLY | O_NONBLOCK);
	while (fd != -1)
	{
		FD_ZERO(&amp;amp;set);
		FD_SET(fd, &amp;amp;set);
		select(fd + 1, &amp;amp;set, 0, 0, 0);
		if (FD_ISSET(fd, &amp;amp;set))
		{
			printf(&amp;quot;simple can read\n&amp;quot;);
			ret = read(fd, data, 255);
			data[ret] = 0;
			printf(&amp;quot;\t%s\n&amp;quot;, data);
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终效果，加载驱动之后，使用uesr程序select，会进入阻塞状态，当再另一个终端下写入数据 echo “simple” &amp;gt; /dev/simple 后程序解除阻塞，输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
[root@cpphost driver]# ./a.out 
simple can read
	simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，简单的几行代码就可让设备驱动支持select模型，复杂而又繁琐的工作都有系统内核处理掉了。&lt;/p&gt;
&lt;p&gt;受好奇心驱使，可能会想系统是如何处理select请求的，select是个系统调用，最后会走到内核的&lt;code&gt;do_select&lt;/code&gt;函数，位于fs/select.c，代码结构大致如下（仅留下框架）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int do_select(int n, fd_set_bits *fds, struct timespec *end_time)
{
	...
	struct poll_wqueues table;
	poll_table *wait;
	...
	poll_initwait(&amp;amp;table);
	...
	for (;;) {
		...
		for (i = 0; i &amp;lt; n; ++rinp, ++routp, ++rexp) {
			...
			for (j = 0; j &amp;lt; __NFDBITS; ++j, ++i, bit &amp;lt;f_op;
					mask = DEFAULT_POLLMASK;
					if (f_op &amp;amp;&amp;amp; f_op-&amp;gt;poll) {
						wait_key_set(wait, in, out, bit);
						/* 这里，调用了f_op的poll函数，即我们的实现 */
						mask = (*f_op-&amp;gt;poll)(file, wait);
					}
					...
					if ((mask &amp;amp; POLLIN_SET) &amp;amp;&amp;amp; (in &amp;amp; bit)) {
						res_in |= bit;
						retval++;
						wait = NULL;
					}
					if ((mask &amp;amp; POLLOUT_SET) &amp;amp;&amp;amp; (out &amp;amp; bit)) {
						res_out |= bit;
						retval++;
						wait = NULL;
					}
					if ((mask &amp;amp; POLLEX_SET) &amp;amp;&amp;amp; (ex &amp;amp; bit)) {
						res_ex |= bit;
						retval++;
						wait = NULL;
					}
				}
			}
			if (res_in)
				*rinp = res_in;
			if (res_out)
				*routp = res_out;
			if (res_ex)
				*rexp = res_ex;
			/* 这里进行调度 */
			cond_resched();
		}
		...
		/* 超时处理 */
		if (!poll_schedule_timeout(&amp;amp;table, TASK_INTERRUPTIBLE,
					   to, slack))
			timed_out = 1;
	}
	/* 释放table */
	poll_freewait(&amp;amp;table);

	return retval;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大致结构也很清晰，进入select时，首先初始化一个等待变量wait，对每一个描述符循环调用对应的poll回调函数，驱动中poll函数又把wait加入自己的等待队列，这样当有数据时，可以及时唤醒select，poll回调返回后，select检查返回的mask，是否有数据可读写，如果都没有，则调用&lt;code&gt;cond_resched();&lt;/code&gt;进入等待，等待超时或者write唤醒等待队列。&lt;/p&gt;
&lt;p&gt;这个过程也验证了select是遍历每个描述符，当描述符增多时导致效率线性下降，所以有了更为先进的 epoll 模型，具体实现可以参考 &lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/linux-kernel-epoll.html&#34; &gt;epoll源码分析&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 内核等待队列解析</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-waiting-queue/</link>
        <pubDate>Wed, 14 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-waiting-queue/</guid>
        <description>&lt;p&gt;在阅读Tun驱动时看到，有一些类似 &lt;code&gt;add_wait_queue&lt;/code&gt; 的函数，这些函数正是执行等待队列的相关操作，要说等待队列还得从内核进程调度说起，内核调度系统内进程，分配时间片，但是有些进程如从网卡中读数据，在网卡有数据到达之前进程处于阻塞状态，如果此时给相应进程分配时间片做调度，无疑是浪费系统资源，所以系统内每个进程都有自己的状态标志 task-&amp;gt;state，这些状态定义于文件 include/linux/sched.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define TASK_RUNNING            0
#define TASK_INTERRUPTIBLE      1
#define TASK_UNINTERRUPTIBLE    2
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内核只会调用标志是 &lt;code&gt;TASK_RUNNING&lt;/code&gt; 的进程，如果需要等待资源，可以设置自己的进程标志为 &lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt; （可中断）或者 &lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt; （不可中断），然后调用 schedule();放弃CPU，此进程就不会被内核调度了，但随之而来的问题是，如果进程所需资源可以使用，如何唤醒进程呢，这就要依赖于等待队列了，进程在放弃控制权之前，把自己加入一个队列中，当所需条件满足，其他进程便可wakeup该队列，修改进程状态为 &lt;code&gt;TASK_RUNNING&lt;/code&gt;，等待进程便可顺利往下执行了。&lt;/p&gt;
&lt;p&gt;与等待队列相关的操作有如下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 等待队列头声明 */
wait_queue_head_t simple_queue;

/* 初始化等待队列头 */
init_waitqueue_head(&amp;amp;simple_queue);

/* 定义等待队列项 */
DECLARE_WAITQUEUE (name, tsk);

/* 添加删除等待项 */
void fastcall add_wait_queue(wait_queue_head_t * q, wait_queue_t * wait);
void fastcall remove_wait_queue(wait_queue_head_t * q, wait_queue_t * wait);

/* 唤醒等待头中的所有项 */
void wake_up(wait_queue_head_t * queue);
void wake_up_interruptible(wait_queue_head_t * queue);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合这些函数，再往simple驱动里添加一些简单的机制支持等待。在 &lt;code&gt;simple_read&lt;/code&gt; 函数中修改当前进程状态，加入等待队列后，放弃控制权，另加入 &lt;code&gt;simple_write&lt;/code&gt; 函数唤醒队列。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;linux/init.h&amp;gt;
#include&amp;lt;linux/module.h&amp;gt;

#include&amp;lt;linux/fs.h&amp;gt;
#include&amp;lt;linux/types.h&amp;gt;
#include&amp;lt;linux/cdev.h&amp;gt;
#include&amp;lt;linux/mm.h&amp;gt;
#include&amp;lt;linux/sched.h&amp;gt;
#include&amp;lt;asm/io.h&amp;gt;
#include&amp;lt;asm/uaccess.h&amp;gt;
#include&amp;lt;asm/system.h&amp;gt;

#include&amp;lt;linux/device.h&amp;gt;

dev_t devno;
struct class * simple_class;
static struct cdev cdev;

wait_queue_head_t simple_queue;

char test_data[255];
int len;

ssize_t simple_read(struct file * pfile,
    char __user * buf, size_t size, loff_t * ppos)
{
    /* 定义一个等待项，添加到等待队列，并设置进程状态后放弃执行权 */
    DECLARE_WAITQUEUE (simple_item, current);
    add_wait_queue(&amp;amp;simple_queue, &amp;amp;simple_item);
    current-&amp;gt;state = TASK_INTERRUPTIBLE;
    schedule();
    /* 被唤醒以后，从队列中移除 */
    remove_wait_queue(&amp;amp;simple_queue, &amp;amp;simple_item);

    if (copy_to_user(buf, test_data, len))
        return -EFAULT;
    else
        return len;
}

ssize_t simple_write(struct file * pfile, const char __user * buf, size_t count, loff_t * ppos)
{
    if (count &amp;gt; 255)
    {
        return -EFAULT;
    }

    if (!copy_from_user(test_data, buf, count))
    {
        len = count;
        /* 唤醒等待队列中所有进程 */
        wake_up(&amp;amp;simple_queue);
    }
    return len;
}

int simple_open(struct inode * pnode, struct file * pfile)
{
    printk(KERN_INFO &amp;quot;open simple\n&amp;quot;);
    return 0;
}

int simple_release(struct inode * pnode, struct file * pfile)
{
    printk(KERN_INFO &amp;quot;close simple\n&amp;quot;);
    return 0;
}

static struct file_operations simple_op =
{
    .owner = THIS_MODULE,
    .read = simple_read,
    .open = simple_open,
    .release = simple_release,
    .write = simple_write,
};

static int __init initialization(void)
{
    int result;

    result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;quot;simple&amp;quot;);
    if (result &amp;lt; 0)
        return result;

    cdev_init(&amp;amp;cdev, &amp;amp;simple_op);
    result = cdev_add(&amp;amp;cdev, devno, 1);

    simple_class = class_create(THIS_MODULE, &amp;quot;simple&amp;quot;);
    device_create(simple_class, NULL, devno, NULL, &amp;quot;simple&amp;quot;);

    printk(KERN_INFO &amp;quot; init simple\n&amp;quot;);

    init_waitqueue_head(&amp;amp;simple_queue);

    return result;
}

static void __exit cleanup(void)
{
    device_destroy(simple_class, devno);
    class_destroy(simple_class);

    cdev_del(&amp;amp;cdev);
    unregister_chrdev_region(devno, 1);
    printk(KERN_INFO &amp;quot; cleanup simple\n&amp;quot;);
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;alloc cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.2&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加载模块 insmod simple.ko 后，使用cat读取数据，cat /dev/simple， 会发现进程处于等待状态，不会输出任何信息，新打开一个终端，输入echo “test” &amp;gt; /dev/simple执行写操作，cat便会输出数据，紧接着再次处于等待状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insmod simple.ko
cat /dev/simple        ---&amp;gt;    进程等待
first            ---&amp;gt;    echo &amp;quot;first&amp;quot; &amp;gt; /dev/simple
cool            ---&amp;gt;    echo &amp;quot;cool&amp;quot; &amp;gt; /dev/simple
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>select/poll 源码分析</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-epoll/</link>
        <pubDate>Tue, 13 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-epoll/</guid>
        <description>&lt;p&gt;select/poll模型一直是Linux长期以来使用较多的服务器模型，自从2.6内核引入epoll模型以后，我们又有了一种更加有效的服务器模型，一直以来都耳闻epoll模型对比select模型的优点，赞誉之声一片，他如何高效，高效到什么程度，还是一知半解，在之前的一篇博客，我简要分析了select模型代码，的确正如前人所言，使用轮询方式处理连接，这里我讲分析epoll模型的框架，体会其高效。&lt;/p&gt;
&lt;p&gt;这里先简略说明一下epoll的使用流程，其使用或许比select模型更为简洁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;epoll_create(size);

while (...)
{
	/* 等待就绪连接 */
	epoll_wait( ... );

	/* 如有新连接，构造epoll_event结构体后 */
	epoll_ctl( ... EPOLL_CTL_ADD ... );
	/* 如有断开连接 */
	epoll_ctl( ... EPOLL_CTL_DEL ... );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从使用角度出发，先来看&lt;code&gt;epoll_create&lt;/code&gt;函数的实现，用户态声明&lt;code&gt;int epoll_create(int size);&lt;/code&gt;对应的系统调用代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::
SYSCALL_DEFINE1(epoll_create, int, size)
{
	if (size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;sys_epoll_create&lt;/code&gt;仅仅检测size是否小于0，之后直接调用&lt;code&gt;sys_epoll_create1&lt;/code&gt;，也就是说size在2.6.34版本中是没有使用的，通过查阅代码，发现&lt;code&gt;sys_epoll_create1&lt;/code&gt;是在2.6.27版本中加入的，但是之前的几个版本也仅仅只是输出日志时使用，没有回溯查看真正废弃改值是在哪个版本，总之真正的实现是位于&lt;code&gt;sys_epoll_create1&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SYSCALL_DEFINE1(epoll_create1, int, flags)
{
	int error;
	struct eventpoll *ep = NULL;

	/* Check the EPOLL_* constant for consistency.  */
	BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);

	if (flags &amp;amp; ~EPOLL_CLOEXEC)
		return -EINVAL;
	/*
	 * Create the internal data structure (&amp;quot;struct eventpoll&amp;quot;).
	 */
	error = ep_alloc(&amp;amp;ep);
	if (error &amp;lt; 0)
		return error;
	/*
	 * Creates all the items needed to setup an eventpoll file. That is,
	 * a file structure and a free file descriptor.
	 */
	error = anon_inode_getfd(&amp;quot;[eventpoll]&amp;quot;, &amp;amp;eventpoll_fops, ep,
				 O_RDWR | (flags &amp;amp; O_CLOEXEC));
	if (error &amp;lt; 0)
		ep_free(ep);

	return error;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码结构比较清晰，调用&lt;code&gt;ep_alloc&lt;/code&gt;分配一个eventpoll结构，调用&lt;code&gt;anon_inode_getfd&lt;/code&gt;创建一个文件节点和文件描述符，并返回文件描述符，这个文件描述符供epoll自己使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
		struct epoll_event __user *, event)
{
	int error;
	struct file *file, *tfile;
	struct eventpoll *ep;
	struct epitem *epi;
	struct epoll_event epds;

	...
	/* 从file结构私有数据取出ep_alloc分配的结构 */
	ep = file-&amp;gt;private_data;

	mutex_lock(&amp;amp;ep-&amp;gt;mtx);

	/*
	 * Try to lookup the file inside our RB tree, Since we grabbed &amp;quot;mtx&amp;quot;
	 * above, we can be sure to be able to use the item looked up by
	 * ep_find() till we release the mutex.
	 */
	epi = ep_find(ep, tfile, fd);

	error = -EINVAL;
	switch (op) {
	case EPOLL_CTL_ADD:
		if (!epi) {
			epds.events |= POLLERR | POLLHUP;
			error = ep_insert(ep, &amp;amp;epds, tfile, fd);
		} else
			error = -EEXIST;
		break;
	case EPOLL_CTL_DEL:
		if (epi)
			error = ep_remove(ep, epi);
		else
			error = -ENOENT;
		break;
	case EPOLL_CTL_MOD:
		if (epi) {
			epds.events |= POLLERR | POLLHUP;
			error = ep_modify(ep, epi, &amp;amp;epds);
		} else
			error = -ENOENT;
		break;
	}
	mutex_unlock(&amp;amp;ep-&amp;gt;mtx);

error_tgt_fput:
	fput(tfile);
error_fput:
	fput(file);
error_return:

	return error;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去除错误检测，剩下的代码也比较清晰，首先取出&lt;code&gt;epoll_create1&lt;/code&gt;分配的eventpoll结构ep，然后使用&lt;code&gt;ep_find&lt;/code&gt;在ep中查找当前操作的文件描述符，接下来有个判断，分不同操作进行，如果是&lt;code&gt;EPOLL_CTL_ADD&lt;/code&gt;，则调&lt;code&gt;ep_insert&lt;/code&gt;插入文件描述符，如果是&lt;code&gt;EPOLL_CTL_DEL&lt;/code&gt;则调用&lt;code&gt;ep_remove&lt;/code&gt;删除文件描述符，修改则用&lt;code&gt;ep_modify&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;姑且先忽略ep操作的函数，直接去看epoll_wait的实现，以明确流程。
&lt;code&gt;epoll_wait&lt;/code&gt;实现与1321行，不过其中所作操作非常简单：从file结构中取出eventpoll结构，直接调用&lt;code&gt;ep_poll&lt;/code&gt;，我们需要着重分析&lt;code&gt;ep_poll&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
		   int maxevents, long timeout)
{
	int res, eavail;
	unsigned long flags;
	long jtimeout;
	wait_queue_t wait;

	...

	res = 0;
	if (list_empty(&amp;amp;ep-&amp;gt;rdllist)) {
		/*
		 * We don&#39;t have any available event to return to the caller.
		 * We need to sleep here, and we will be wake up by
		 * ep_poll_callback() when events will become available.
		 */
		init_waitqueue_entry(&amp;amp;wait, current);
		wait.flags |= WQ_FLAG_EXCLUSIVE;
		__add_wait_queue(&amp;amp;ep-&amp;gt;wq, &amp;amp;wait);

		for (;;) {
			/*
			 * We don&#39;t want to sleep if the ep_poll_callback() sends us
			 * a wakeup in between. That&#39;s why we set the task state
			 * to TASK_INTERRUPTIBLE before doing the checks.
			 */
			set_current_state(TASK_INTERRUPTIBLE);
			if (!list_empty(&amp;amp;ep-&amp;gt;rdllist) || !jtimeout)
				break;
			if (signal_pending(current)) {
				res = -EINTR;
				break;
			}

			spin_unlock_irqrestore(&amp;amp;ep-&amp;gt;lock, flags);
			jtimeout = schedule_timeout(jtimeout);
			spin_lock_irqsave(&amp;amp;ep-&amp;gt;lock, flags);
		}
		__remove_wait_queue(&amp;amp;ep-&amp;gt;wq, &amp;amp;wait);

		set_current_state(TASK_RUNNING);
	}

	...

	if (!res &amp;amp;&amp;amp; eavail &amp;amp;&amp;amp;
	    !(res = ep_send_events(ep, events, maxevents)) &amp;amp;&amp;amp; jtimeout)
		goto retry;

	return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于篇幅限制去除一些不影响大致流程的代码，剩下的居然异常简单，首先用&lt;code&gt;list_empty&lt;/code&gt;判断&lt;code&gt;ep-&amp;gt;rdllist&lt;/code&gt;链表是否为空，rdllist是就绪的文件链表，如果不为空可以直接返回给上层，如果不为空，则等待，等待的方式也比较清晰，把自己加入到ep-&amp;gt;wq等待队列中，然后&lt;code&gt;schedule_timeout(jtimeout);&lt;/code&gt;放弃运行权即可，完成后使用&lt;code&gt;ep_send_events&lt;/code&gt;把结果返回给上层。&lt;/p&gt;
&lt;p&gt;原本以为epoll会同select一样，把核心代码放到wait函数中，想不到此函数草草了事，除了查看链表是否为空和休息，基本什么也没有做，看来epoll之所以比select效率高的原因尽在于此。但现在的问题是，谁去填充队列rdllist，谁去唤醒该进程？看来还得从之前忽略了的ep_insert函数入手。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
		     struct file *tfile, int fd)
{
	int error, revents, pwake = 0;
	unsigned long flags;
	struct epitem *epi;
	struct ep_pqueue epq;

	if (unlikely(atomic_read(&amp;amp;ep-&amp;gt;user-&amp;gt;epoll_watches) &amp;gt;=
		     max_user_watches))
		return -ENOSPC;
	if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))
		return -ENOMEM;

	/* Item initialization follow here ... */
	INIT_LIST_HEAD(&amp;amp;epi-&amp;gt;rdllink);
	INIT_LIST_HEAD(&amp;amp;epi-&amp;gt;fllink);
	INIT_LIST_HEAD(&amp;amp;epi-&amp;gt;pwqlist);
	epi-&amp;gt;ep = ep;
	ep_set_ffd(&amp;amp;epi-&amp;gt;ffd, tfile, fd);
	epi-&amp;gt;event = *event;
	epi-&amp;gt;nwait = 0;
	epi-&amp;gt;next = EP_UNACTIVE_PTR;

	/* Initialize the poll table using the queue callback */
	epq.epi = epi;
	init_poll_funcptr(&amp;amp;epq.pt, ep_ptable_queue_proc);

	/*
	 * Attach the item to the poll hooks and get current event bits.
	 * We can safely use the file* here because its usage count has
	 * been increased by the caller of this function. Note that after
	 * this operation completes, the poll callback can start hitting
	 * the new item.
	 */
	revents = tfile-&amp;gt;f_op-&amp;gt;poll(tfile, &amp;amp;epq.pt);

	/*
	 * We have to check if something went wrong during the poll wait queue
	 * install process. Namely an allocation for a wait queue failed due
	 * high memory pressure.
	 */
	error = -ENOMEM;
	if (epi-&amp;gt;nwait &amp;lt; 0) 		goto error_unregister; 	/* Add the current item to the list of active epoll hook for this file */ 	spin_lock(&amp;amp;tfile-&amp;gt;f_lock);
	list_add_tail(&amp;amp;epi-&amp;gt;fllink, &amp;amp;tfile-&amp;gt;f_ep_links);
	spin_unlock(&amp;amp;tfile-&amp;gt;f_lock);

	/*
	 * Add the current item to the RB tree. All RB tree operations are
	 * protected by &amp;quot;mtx&amp;quot;, and ep_insert() is called with &amp;quot;mtx&amp;quot; held.
	 */
	ep_rbtree_insert(ep, epi);

	/* We have to drop the new item inside our item list to keep track of it */
	spin_lock_irqsave(&amp;amp;ep-&amp;gt;lock, flags);

	/* If the file is already &amp;quot;ready&amp;quot; we drop it inside the ready list */
	if ((revents &amp;amp; event-&amp;gt;events) &amp;amp;&amp;amp; !ep_is_linked(&amp;amp;epi-&amp;gt;rdllink)) {
		list_add_tail(&amp;amp;epi-&amp;gt;rdllink, &amp;amp;ep-&amp;gt;rdllist);

		/* Notify waiting tasks that events are available */
		if (waitqueue_active(&amp;amp;ep-&amp;gt;wq))
			wake_up_locked(&amp;amp;ep-&amp;gt;wq);
		if (waitqueue_active(&amp;amp;ep-&amp;gt;poll_wait))
			pwake++;
	}

	spin_unlock_irqrestore(&amp;amp;ep-&amp;gt;lock, flags);

	atomic_inc(&amp;amp;ep-&amp;gt;user-&amp;gt;epoll_watches);

	/* We have to call this outside the lock */
	if (pwake)
		ep_poll_safewake(&amp;amp;ep-&amp;gt;poll_wait);

	return 0;

error_unregister:
	...	/* 清理代码 */
	return error;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里首先使用 &lt;code&gt;kmem_cache_alloc&lt;/code&gt; 分配了一个 &lt;code&gt;epitem *epi&lt;/code&gt; 结构，&lt;code&gt;epi-&amp;gt;ep = ep;&lt;/code&gt;并把ep指针赋值给它的成员，紧接着，又使用&lt;code&gt;epq.epi = epi;&lt;/code&gt;把epi赋值给&lt;code&gt;ep_pqueue epq;&lt;/code&gt;结构成员。这里嵌套了几层结构，ep-&amp;gt;epi-&amp;gt;epq，关系比较复杂，我们只关心核心的东西，分析流程。&lt;/p&gt;
&lt;p&gt;后面init_poll_funcptr(&amp;amp;epq.pt, ep_ptable_queue_proc);函数定义于include/linux/poll.h文件，代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)
{
	pt-&amp;gt;qproc = qproc;
	pt-&amp;gt;key   = ~0UL; /* all events enabled */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅仅是给epq的pt成员设置回调函数，千万注意这里的回调应用，epoll的实现就是依赖于内核和驱动的层层回调，后面将会说到。&lt;/p&gt;
&lt;p&gt;再来看&lt;code&gt;ep_insert&lt;/code&gt;的代码，之后紧接着调用了目标文件驱动的poll回调，把刚才设置好的epq.pt传入驱动之中：&lt;code&gt;tfile-&amp;gt;f_op-&amp;gt;poll(tfile,&amp;amp;epq.pt)&lt;/code&gt;。如果再这里停止跟进，往下进行，发现该函数之后的代码无非是错误判断或者各种结构之间的纠结。唯一一点有用的代码就是这句：&lt;code&gt;wake_up_locked(&amp;amp;ep-&amp;gt;wq)&lt;/code&gt;。其中&lt;code&gt;ep-&amp;gt;wq&lt;/code&gt;正是&lt;code&gt;epoll_wait&lt;/code&gt;函数等待的队列，不过此情况仅仅是在驱动poll函数直接返回数据的情况下。真正触发点应该还在驱动对epq.pt的操作。&lt;/p&gt;
&lt;p&gt;之前的文章写过驱动中对poll的实现，无非调用 &lt;code&gt;poll_wait&lt;/code&gt; 函数，实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
{
	if (p &amp;amp;&amp;amp; wait_address)
	p-&amp;gt;qproc(filp, wait_address, p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对照&lt;code&gt;init_poll_funcptr&lt;/code&gt;的代码，我们可以很清楚的发现，其实最终驱动是回调了&lt;code&gt;init_poll_funcptr&lt;/code&gt;中设置的qproc函数！返回到&lt;code&gt;ep_insert&lt;/code&gt;中，可以看到设置的qproc函数名为 &lt;code&gt;ep_ptable_queue_proc&lt;/code&gt;，所以还是不得不再分析此函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,
				 poll_table *pt)
{
	struct epitem *epi = ep_item_from_epqueue(pt);
	struct eppoll_entry *pwq;

	if (epi-&amp;gt;nwait &amp;gt;= 0 &amp;amp;&amp;amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {
		init_waitqueue_func_entry(&amp;amp;pwq-&amp;gt;wait, ep_poll_callback);
		pwq-&amp;gt;whead = whead;
		pwq-&amp;gt;base = epi;
		add_wait_queue(whead, &amp;amp;pwq-&amp;gt;wait);
		list_add_tail(&amp;amp;pwq-&amp;gt;llink, &amp;amp;epi-&amp;gt;pwqlist);
		epi-&amp;gt;nwait++;
	} else {
		/* We have to signal that an error occurred */
		epi-&amp;gt;nwait = -1;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;乍一看函数代码并不多，不过又创建出一个结构&lt;code&gt;eppoll_entry&lt;/code&gt;，并调用&lt;code&gt;init_waitqueue_func_entry&lt;/code&gt;初始化等待的回调函数。再使用&lt;code&gt;pwq-&amp;gt;base = epi&lt;/code&gt;保存了epi地址，接下来执行正常的&lt;code&gt;add_wait_queue&lt;/code&gt;操作，加入等待队列。期待的结果就是设备数据就绪时，驱动&lt;code&gt;wake_up&lt;/code&gt;等待队列，可以回调加入的函数&lt;code&gt;ep_poll_callback&lt;/code&gt;，要想进一步研究，可以查看相关代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 函数init_waitqueue_func_entry仅仅初始化func回调函数 */
static inline void init_waitqueue_func_entry(wait_queue_t *q,
				wait_queue_func_t func)
{
	q-&amp;gt;flags = 0;
	q-&amp;gt;private = NULL;
	q-&amp;gt;func = func;
}

#define wake_up(x)                      __wake_up(x, TASK_NORMAL, 1, NULL)

void __wake_up(wait_queue_head_t *q, unsigned int mode,
			int nr_exclusive, void *key)
{
	unsigned long flags;

	spin_lock_irqsave(&amp;amp;q-&amp;gt;lock, flags);
	__wake_up_common(q, mode, nr_exclusive, 0, key);
	spin_unlock_irqrestore(&amp;amp;q-&amp;gt;lock, flags);
}

static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,
			int nr_exclusive, int wake_flags, void *key)
{
	wait_queue_t *curr, *next;

	list_for_each_entry_safe(curr, next, &amp;amp;q-&amp;gt;task_list, task_list) {
		unsigned flags = curr-&amp;gt;flags;

		/* 最终到达这里调用刚才设置的回调函数 */
		if (curr-&amp;gt;func(curr, mode, wake_flags, key) &amp;amp;&amp;amp;
				(flags &amp;amp; WQ_FLAG_EXCLUSIVE) &amp;amp;&amp;amp; !--nr_exclusive)
			break;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以知道的是，&lt;code&gt;epoll_wait&lt;/code&gt;处于等待并且设备准备完成，会调用&lt;code&gt;ep_poll_callback&lt;/code&gt;函数，一切的矛头都指向&lt;code&gt;ep_poll_callback&lt;/code&gt;，大致可以猜测，增加就绪队列rdllist元素、唤醒&lt;code&gt;epoll_wait&lt;/code&gt;函数都应在此函数中实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)
{
	int pwake = 0;
	unsigned long flags;
	struct epitem *epi = ep_item_from_wait(wait);
	struct eventpoll *ep = epi-&amp;gt;ep;

	spin_lock_irqsave(&amp;amp;ep-&amp;gt;lock, flags);

	...

	/* If this file is already in the ready list we exit soon */
	if (!ep_is_linked(&amp;amp;epi-&amp;gt;rdllink))
		list_add_tail(&amp;amp;epi-&amp;gt;rdllink, &amp;amp;ep-&amp;gt;rdllist);

	/*
	 * Wake up ( if active ) both the eventpoll wait list and the -&amp;gt;poll()
	 * wait list.
	 */
	if (waitqueue_active(&amp;amp;ep-&amp;gt;wq))
		wake_up_locked(&amp;amp;ep-&amp;gt;wq);
	if (waitqueue_active(&amp;amp;ep-&amp;gt;poll_wait))
		pwake++;

out_unlock:
	spin_unlock_irqrestore(&amp;amp;ep-&amp;gt;lock, flags);

	/* We have to call this outside the lock */
	if (pwake)
		ep_poll_safewake(&amp;amp;ep-&amp;gt;poll_wait);

	return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;粗略看下代码感觉此函数不负众望，首先&lt;code&gt;struct epitem *epi = ep_item_from_wait(wait)&lt;/code&gt;从wait中获取epi结构，并取得ep，&lt;code&gt;list_add_tail(&amp;amp;epi-&amp;gt;rdllink, &amp;amp;ep-&amp;gt;rdllist);&lt;/code&gt;把加入到ep的就绪队列rdllist中，而后&lt;code&gt;wake_up_locked(&amp;amp;ep-&amp;gt;wq)&lt;/code&gt;唤醒&lt;code&gt;epoll_wait&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里还有些细节，如果记得清楚，刚才是把wait变量赋值到结构epi的成员，这里确从wait中取出结构体的地址，这是Linux内核常用手段，依赖于宏container_of，此宏定义于include/linux/kernel.h，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define container_of(ptr, type, member) ({                      \
        const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对c语言来说，结构体并没有太多的秘密，无非是内存的组合，typeof( ((type *)0)-&amp;gt;member ) 在编译期构造一个member成员类型，指针指向ptr，之后减去member在类型type中的偏移即为type结构地址。&lt;/p&gt;
&lt;p&gt;分析到这里，我们可以看到，epoll模型并没有对每一个文件描述符遍历，仅仅当描述符对应设备就绪时，回调epoll，加入就绪队列唤醒epoll_wait，当文件描述符增多时，效率不会同select一样线性下降，由于select会轮询所有设备，可能大多数设备是没有数据的，在文件描述符较少情况下倒是显不出什么，当有成千上万描述符并且大量描述符处于空闲状态时，对效率的损耗是相当惊人的。所以epoll为我们提供了一种更加有效便捷的方式去管理如此多的描述符。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>tun/tap 驱动源码分析</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-tap-tun-driver/</link>
        <pubDate>Mon, 12 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-tap-tun-driver/</guid>
        <description>&lt;p&gt;tun/tap驱动程序是Linux平台虚拟网卡驱动程序，驱动加载后会建立网络接口tun0，与其他网卡驱动不同的是，tun驱动并不会把到达的数据包发送出去，而是会暂时存储于队列之中，用户态进程可以通过read，write读写网络数据包，实质上此驱动是一种把网络数据包直接定向至用户态进程的一种方式。用户态进程充当网络的角色，通过read接受网卡数据包，write发送数据包给网卡。&lt;/p&gt;
&lt;p&gt;此驱动运行时可设置tun模式和tap模式，tun模式能取到IP数据包，无法获得ARP数据，而tap模式取到的是以太包，可以得到链路层以上的一切数据包。&lt;/p&gt;
&lt;p&gt;由于项目需要使用tun驱动，而又不想不求甚解，从而阅读了驱动代码，想对此做一些记录，可以使自己理解的更为透彻，虽然代码并不多，但是涉及内核态编程，倘若追根溯源，恐怕需读完Linux协议栈代码了。&lt;/p&gt;
&lt;p&gt;我阅读的代码取自Linux 2.6.34内核源码，路径 drivers\net\tun.c&lt;/p&gt;
&lt;p&gt;驱动入口点，Linux驱动入口点不同Windows平台，入口函数都是DriverEntry，Linux平台需要通过&lt;code&gt;module_init&lt;/code&gt;宏指定入口点（当然最终宏也会统一把函数转化成&lt;code&gt;init_module&lt;/code&gt;作为入口点），当执行modprobe加载内核模块时由内核调用，&lt;code&gt;module_exit&lt;/code&gt;宏指定清理函数，当执行rmmod时由内核调用。另外，通过 &lt;code&gt;MODULE_*&lt;/code&gt; 一系列宏记录作者，驱动描述，以及协议信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module_init(tun_init);
module_exit(tun_cleanup);
MODULE_DESCRIPTION(DRV_DESCRIPTION);
MODULE_AUTHOR(DRV_COPYRIGHT);
MODULE_LICENSE(&amp;quot;GPL&amp;quot;);
MODULE_ALIAS_MISCDEV(TUN_MINOR);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指明了驱动程序的基本信息，&lt;code&gt;MODULE_DESCRIPTION&lt;/code&gt;声明驱动描述，&lt;code&gt;MODULE_AUTHOR&lt;/code&gt;声明作者，在程序开始已有定义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define DRV_DESCRIPTION	&amp;quot;Universal TUN/TAP device driver&amp;quot;
#define DRV_COPYRIGHT	&amp;quot;(C) 1999-2004 Max Krasnyansky &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TUN_MINOR 位于文件 include/linux/miscdevice.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define TUN_MINOR 200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来看初始化和清理函数的实现，初始化函数所作工作非常简单，主要功能是建立一个设备节点供用户态进程控制
&lt;code&gt;ret = misc_register(&amp;amp;tun_miscdev);&lt;/code&gt;
函数&lt;code&gt;misc_register&lt;/code&gt;注册一个字符设备，所注册信息位于tun_miscdev结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static struct miscdevice tun_miscdev = {
	.minor = TUN_MINOR,
	.name = &amp;quot;tun&amp;quot;,
	.nodename = &amp;quot;net/tun&amp;quot;,
	.fops = &amp;amp;tun_fops,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用过后会在/dev下以 nodename 为名创建节点，即/dev/net/tun，用户进程可通过open函数打开并操作驱动，操作驱动函数由 tun_fops 指定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const struct file_operations tun_fops = {
	.owner	= THIS_MODULE,
	.llseek = no_llseek,
	.read  = do_sync_read,
	.aio_read  = tun_chr_aio_read,
	.write = do_sync_write,
	.aio_write = tun_chr_aio_write,
	.poll	= tun_chr_poll,
	.unlocked_ioctl	= tun_chr_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl = tun_chr_compat_ioctl,
#endif
	.open	= tun_chr_open,
	.release = tun_chr_close,
	.fasync = tun_chr_fasync
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里操作都是字符设备操作，用户open设备节点/dev/net/tun时内核调用&lt;code&gt;tun_chr_open&lt;/code&gt;回调，这里函数都与用户态操作相对应，用户对设备调用read，write时最终会回调至此，这也是字符设备驱动编程规范。用户态核心操作都在这几个函数当中了。&lt;/p&gt;
&lt;p&gt;现逐条分析每个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.llseek = no_llseek&lt;/code&gt; : &lt;code&gt;no_llseek&lt;/code&gt;为内核函数，实现也十分简单，直接返回-ESPIPE，就是说用户态对设备文件调用lseek就会出Illegal seek错。
字符设备，块设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.read = do_sync_read&lt;/code&gt; :
&lt;code&gt;do_sync_read&lt;/code&gt; 也是内核函数，直接调用aio_read异步读写函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.aio_read = tun_chr_aio_read&lt;/code&gt; :
&lt;code&gt;tun_chr_aio_read&lt;/code&gt; -&amp;gt; &lt;code&gt;tun_do_read&lt;/code&gt; -&amp;gt; &lt;code&gt;skb_dequeue&lt;/code&gt; 以非阻塞方式从接收队列 &lt;code&gt;tun&lt;/code&gt;-&amp;gt;&lt;code&gt;socket.sk&lt;/code&gt;-&amp;gt;&lt;code&gt;sk_receive_queue&lt;/code&gt; 取出一个网络包返给用户态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.write = do_sync_write&lt;/code&gt; :
同&lt;code&gt;aio_read&lt;/code&gt;，调用&lt;code&gt;aio_write&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.aio_write = tun_chr_aio_write&lt;/code&gt; :
&lt;code&gt;tun_chr_aio_write&lt;/code&gt; -&amp;gt; &lt;code&gt;tun_get_user&lt;/code&gt; -&amp;gt; &lt;code&gt;netif_rx_ni&lt;/code&gt; ，netif_rx_ni函数为内核函数，最终调用netif_rx返包给TCP/IP协议栈，Linux系统网络数据包都是以sk_buff结构存在，这里函数大部分都是构造此结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.poll = tun_chr_poll :
tun_chr_poll 调用 poll_wait 实现poll功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.unlocked_ioctl = tun_chr_ioctl :
tun_chr_ioctl -&amp;gt; __tun_chr_ioctl 就是垃圾桶函数ioctl的实现了，所有对驱动程序的操控基本都实现于此函数。函数处理各种不同命令，使用switch-case处理不同命令号，设置硬件地址获取信息等等，关键部分在命令TUNSETIFF，处理在switch之前，这个命令设置基本信息并启动驱动程序的网卡部分。TUNSETIFF 命令最终实现于 tun_set_iff 函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.open = tun_chr_open :
tun_chr_open 当用户调用，此函数仅仅分配自定义结构tun_file，存至文件节点私有数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.release = tun_chr_close :
tun_chr_close 与 open 操作相反，释放结构体，以及结构体之中的子结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.fasync = tun_chr_fasync&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是tun驱动中字符驱动部分，其中省略了细节，如等待队列等内容，跟内核机制有关，我想再另一篇文章中单独总结更好。&lt;/p&gt;
&lt;p&gt;网卡驱动部分&lt;/p&gt;
&lt;p&gt;初始化工作在函数 &lt;code&gt;tun_set_iff&lt;/code&gt; 中
&lt;code&gt;alloc_netdev&lt;/code&gt; 分配网络设备 -&amp;gt; &lt;code&gt;tun_net_init&lt;/code&gt; 初始化网络设备 -&amp;gt; &lt;code&gt;register_netdevice&lt;/code&gt; 注册网络设备
其中自定义函数 &lt;code&gt;tun_net_init&lt;/code&gt; 关键部分如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (tun-&amp;gt;flags &amp;amp; TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev-&amp;gt;netdev_ops = &amp;amp;tun_netdev_ops;

		/* ... */
	case TUN_TAP_DEV:
		dev-&amp;gt;netdev_ops = &amp;amp;tap_netdev_ops;
		/* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序查看设置模式，若是tun模式，设置回调函数为 &lt;code&gt;tun_netdev_ops&lt;/code&gt;， 若是tap模式，设置回调函数为 &lt;code&gt;tap_netdev_ops&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;先来分析 &lt;code&gt;tun_netdev_ops&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const struct net_device_ops tun_netdev_ops = {
	.ndo_uninit		= tun_net_uninit,
	.ndo_open		= tun_net_open,
	.ndo_stop		= tun_net_close,
	.ndo_start_xmit		= tun_net_xmit,
	.ndo_change_mtu		= tun_net_change_mtu,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同字符设备驱动的范式，网络驱动也是设置一系列回调函数，当有数据传输时调用相应回调。&lt;/p&gt;
&lt;p&gt;.ndo_open = tun_net_open
open 函数调用 netif_start_queue(dev); 通知上层开始接受数据包&lt;/p&gt;
&lt;p&gt;.ndo_stop = tun_net_close
close 函数调用 netif_stop_queue(dev); 通知上层停止接受数据包&lt;/p&gt;
&lt;p&gt;.ndo_start_xmit = tun_net_xmit
当有数据包到达时调用 tun_net_xmit 函数，通知网卡发送数据包，函数处理数据包时调用 skb_queue_tail 把数据包压入接收队列 tun-&amp;gt;socket.sk-&amp;gt;sk_receive_queue&lt;/p&gt;
&lt;p&gt;.ndo_change_mtu = tun_net_change_mtu
改变网卡mtu，控制数据帧大小。&lt;/p&gt;
&lt;p&gt;分析 tap 模式下操作回调 &lt;code&gt;tap_netdev_ops&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const struct net_device_ops tap_netdev_ops = {
	.ndo_uninit		= tun_net_uninit,
	.ndo_open		= tun_net_open,
	.ndo_stop		= tun_net_close,
	.ndo_start_xmit		= tun_net_xmit,
	.ndo_change_mtu		= tun_net_change_mtu,
	.ndo_set_multicast_list	= tun_net_mclist,
	.ndo_set_mac_address	= eth_mac_addr,
	.ndo_validate_addr	= eth_validate_addr,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中大部分函数都同 tun 模式相同，因为这些函数都无需关心数据包是否含有以太头。而&lt;code&gt;tun_net_mclist&lt;/code&gt;仅实现为空函数，&lt;code&gt;eth_mac_addr&lt;/code&gt;和&lt;code&gt;eth_validate_addr&lt;/code&gt;操作函数直接回调系统默认函数，此模式下并无新回调函数出现。&lt;/p&gt;
&lt;p&gt;虽然Linux系统是用纯C语言写的，但是其中到处充斥着面向对象的思想，分析驱动程序首先理清结构，以及结构对应的方法，对字符设备驱动对象，file存储数据，&lt;code&gt;file_operations&lt;/code&gt;回调是其方法；网络设备对象也是如此。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux字符设备驱动开发</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-character-driver/</link>
        <pubDate>Sun, 11 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-character-driver/</guid>
        <description>&lt;h1 id=&#34;什么是字符驱动&#34;&gt;什么是字符驱动？&lt;/h1&gt;
&lt;p&gt;所谓驱动程序，本质上讲是硬件接口，因为操作系统不可能实现每种硬件的接口，所以只对厂商提供接口，只要厂商实现这些接口，就可被操作系统调用，Linux系统驱动程序分为字符设备驱动和块设备驱动，所谓字符设备驱动就是例如键盘驱动，只能顺次读取数据，块设备驱动入硬盘等，可以随机分块读取。而有些程序虽然符合驱动程序规范，但却不真正驱动硬件，而是对操作系统功能的扩充，也称作内核模块。所以驱动程序和内核模块本质上讲属于同一种类别。&lt;/p&gt;
&lt;h1 id=&#34;如何实现&#34;&gt;如何实现？&lt;/h1&gt;
&lt;p&gt;操作系统对字符设备驱动提供 file_operations 结构，该结构成员大部分都是回调函数（以下代码摘自Linux 2.6.34内核源码）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_operations&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;owner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llseek&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aio_read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kiocb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iovec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aio_write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kiocb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iovec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readdir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;filldir_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;poll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;poll_table_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ioctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlocked_ioctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compat_ioctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vm_area_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;fl_owner_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fsync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dentry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datasync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aio_fsync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kiocb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datasync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fasync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sendpage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_unmapped_area&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;check_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splice_write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splice_read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setlease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作为驱动程序，只需要实现部分回调函数，注册该结构体，用户态进程便可通过系统调用open，read等调用相应回调函数指针。&lt;/p&gt;
&lt;p&gt;首先，系统提供若干宏声明驱动程序的属性，如，入口，作者，描述信息等等。&lt;/p&gt;
&lt;p&gt;初始化程序原型为 &lt;code&gt;static int __init initialization(void);&lt;/code&gt;若初始化成功则返回0，否则返回错误码。
清理函数原型为&lt;code&gt;static void __exit cleanup(void);&lt;/code&gt;其中&lt;code&gt;__init __exit&lt;/code&gt;是指定代码段属性的宏，当然也可不指定此属性。&lt;/p&gt;
&lt;p&gt;另外宏MODULE_AUTHOR指明作者等等&lt;/p&gt;
&lt;p&gt;实现该函数后便可通过宏指明入口点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最简单的驱动程序就是仅仅实现这两个函数，文件simple.c如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;linux/init.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__init&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; init simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__exit&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; cleanup simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_AUTHOR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;alloc cppbreak@gmail.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_DESCRIPTION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;A simple linux kernel module&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_VERSION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;V0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Dual BSD/GPL&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;驱动的编译需要写Makefile文件，内容如下
&lt;code&gt;obj-m := simple.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译时需指定Linux内核源码所处位置：
&lt;code&gt;make -C /usr/src/linux M=$PWD modules&lt;/code&gt;
其中/usr/src/linux为当前内核源码目录，&lt;code&gt;$PWD&lt;/code&gt;为驱动程序所处目录，&lt;code&gt;PWD&lt;/code&gt;为当前目录。&lt;/p&gt;
&lt;p&gt;执行成功后，会生成&lt;code&gt;simple.ko&lt;/code&gt;文件，此文件即为驱动程序。&lt;/p&gt;
&lt;p&gt;加载驱动程序可执行 insmod simple.ko 卸载驱动执行 rmmod simple
命令 lsmod 可以查看目前系统加载的驱动程序，modinfo simple.ko 查看程序的基本信息，输出即为程序声明信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	filename:       simple.ko
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	license:        Dual BSD/GPL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	version:        V0.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	description:    A simple linux kernel module
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	author:         alloc cppbreak@gmail.com
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	srcversion:     95E3CE3AB899900656E9CAD
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	depends:        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	vermagic:       2.6.33.3-85.fc13.x86_64 SMP mod_unload
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在程序中调用了两次printk，为内核输出函数，这里的输出不会显示到控制台，只会输出到内核，可以通过读取&lt;code&gt;/proc/kmsg&lt;/code&gt;文件查看信息，或者调用dmesg命令查看，此为内核跟踪错误的重要手段。KERN_INFO宏只是一个数字字符串，含义为日志级别，可以通过&lt;code&gt;echo num &amp;gt; /proc/sys/kernel/printk&lt;/code&gt; 来控制输出信息的级别。&lt;/p&gt;
&lt;p&gt;当然，只有此两个函数只能正常加载卸载驱动程序，并没有任何意义，下面通过注册回调函数来实现字符设备的功能，只举一个简单的例子，实现&lt;code&gt;open&lt;/code&gt;,&lt;code&gt;read&lt;/code&gt;,&lt;code&gt;close&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;根据file_operations结构成员的原型，这里我们需要实现如下回调：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;open和close函数为了简单起见不做任何处理，只是简单的输出kernel信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pnode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;open simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pnode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;close simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于read函数，因为需要把内核态的数据返回到用户态，而二者是具有堆栈隔离的，需要借助几个函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;copy_from_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;copy_to_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;copy_from_user 是把用户态数据from拷贝至内核态内存to中，coyp_to_user与之相反，返回结果为不能被复制的字节数，如果成功，则返回0，对于内核编程，错误处理非常重要，因为一微不足道的错误就可能导致系统崩溃，所以对于函数调用，要异常小心，需要区分每一个传入参数，以及判断每一个函数返回值，read函数可以实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ppos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;copy_to_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;test data&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EFAULT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到这里回调函数都已实现，但用户态进程如何才能访问驱动呢？这还得从初始化内核时说起，要访问一个设备，需要进行三个基本操作：
第一，对于一个设备驱动，需要分配一个设备号来唯一标识；
第二，需要注册回调函数至文件系统，以便上层回调；
第三，需要创建一个设备节点，挂接至/dev/下，这样用户层就可类似打开文件驱动方式打开设备驱动了。&lt;/p&gt;
&lt;p&gt;由以上三点，重写设备初始化函数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__init&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;cm&#34;&gt;/* 分配设备号 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;alloc_chrdev_region&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;devno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;simple&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;cm&#34;&gt;/* 注册回调函数 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;cdev_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cdev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;simple_op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cdev_add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cdev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;devno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;cm&#34;&gt;/* 创建设备节点 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;simple_class&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;class_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;THIS_MODULE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;simple&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;device_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;simple_class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;devno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;simple&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; init simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然，在exit函数中，需要对分配的资源逐一释放，整理之后代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/init.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/module.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/fs.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/types.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/cdev.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/mm.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/sched.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;asm/io.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;asm/uaccess.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;asm/system.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/device.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dev_t devno;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	struct class * simple_class;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static struct cdev cdev;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ssize_t simple_read(struct file * pfile,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		char __user * buf, size_t size, loff_t * ppos)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		if (copy_to_user(buf, &amp;#34;test data\n&amp;#34;, 10))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			return -EFAULT;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			return 10;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int simple_open(struct inode * pnode, struct file * pfile)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34;open simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int simple_release(struct inode * pnode, struct file * pfile)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34;close simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static struct file_operations simple_op = 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.owner = THIS_MODULE,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.read = simple_read,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.open = simple_open,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.release = simple_release,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static int __init initialization(void)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int result;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;#34;simple&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		if (result &amp;lt; 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			return result;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cdev_init(&amp;amp;cdev, &amp;amp;simple_op);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		result = cdev_add(&amp;amp;cdev, devno, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		simple_class = class_create(THIS_MODULE, &amp;#34;simple&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		device_create(simple_class, NULL, devno, NULL, &amp;#34;simple&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34; init simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return result;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static void __exit cleanup(void)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		device_destroy(simple_class, devno);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		class_destroy(simple_class);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cdev_del(&amp;amp;cdev);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		unregister_chrdev_region(devno, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34; cleanup simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	module_init(initialization);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	module_exit(cleanup);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_AUTHOR(&amp;#34;alloc cppbreak@gmail.com&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_DESCRIPTION(&amp;#34;A simple linux kernel module&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_VERSION(&amp;#34;V0.1&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_LICENSE(&amp;#34;Dual BSD/GPL&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译加载驱动后，&lt;code&gt;ls /dev/&lt;/code&gt; 可查看到simple节点，调用 &lt;code&gt;cat /dev/simple&lt;/code&gt; 命令，发现会不停输出 &lt;code&gt;test data&lt;/code&gt;，原因是cat命令会输出文件所有内容，但此时的驱动只要调用read就会返回数据，不会到达文件结尾，会无休止输出，毕竟这是一个很简单的驱动，去除了影响理解框架的逻辑信息。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
