<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>汇编语言 on 讲故事的人</title>
        <link>https://drawing.fancymore.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</link>
        <description>Recent content in 汇编语言 on 讲故事的人</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 28 Apr 2014 01:18:03 +0800</lastBuildDate><atom:link href="https://drawing.fancymore.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>汇编语言练习-AT&amp;T汇编win32窗口</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-bios/</link>
        <pubDate>Mon, 28 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-bios/</guid>
        <description>&lt;h1 id=&#34;att-bios模式&#34;&gt;AT&amp;amp;T BIOS模式&lt;/h1&gt;
&lt;p&gt;BIOS(Basic Input/Output System) 是基本输入输出系统，它是硬件之上的一层。为计算机提供了最基本的控制硬件方式，BIOS存储了基本的硬件信息，例如磁盘大小等，并负责引导系统。&lt;/p&gt;
&lt;p&gt;系统加电启动时，BIOS首先获得控制权，由它首先进行硬件检测，这个过程称为加点自检(POST)，通常POST检测cpu、内存、磁盘、主板等等，一旦发现问题，便会提示信息或者鸣笛警告。&lt;/p&gt;
&lt;p&gt;BIOS另外一个职责便是引导系统，BIOS加电自检完毕之后，读取CMOS中的设备引导信息，从引导设备中读取0柱面0磁头1扇区的512字节，若 512字节以55 AA（2字节）结束，则认为是引导扇区（Boot Sector），BIOS便会装载此段到地址0x7C00，执行此程序，以后的引导工作边交由引导扇区处理，BIOS便退居幕后，为系统提供基本的服务。 在汇编中通过int指令产生中断，可请求BIOS服务，这篇先来介绍BIOS中断请求，不过需注意的是BIOS中断请求必须在16位实模式，或者虚拟 8086模式下才可运行，进入保护模式后，中断的处理方式发生变化。&lt;/p&gt;
&lt;p&gt;BIOS中断请求通过指令int Num，Num是中断号，不同的中断号负责不同的功能，比如0×10控制视频，0×16键盘中断等等。BIOS中断非常之多，不可能全部记忆，好在调用方式相同，另有相关手册参考，我觅得一份，可以在 这里 下载，或者浏览 网页版本，或者在Railf Brown 的主页 下载。&lt;/p&gt;
&lt;p&gt;这里以0×10号中断为例说明控制显示视频，先来看手册中0×10号中断部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INT 10 - VIDEO; CPU-generated (80286+)
INT 10 ---- - CPU-generated (80286+) - COPROCESSOR ERROR
INT 10h---- - LIRVGA19 - CHAR HEIGHT HOOK
INT 10 00-- - VIDEO - SET VIDEO MODE
INT 10 0070 - VIDEO - Everex Micro Enhancer EGA/Viewpoint VGA - EXTENDED MODE SET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到 INT 10 00 是设置显示模式，查看其输入参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 00h
	AL = desired video mode (see #00010)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到AH为功能号00h，AL为需要设置的模式，再通过手册查找模式号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Table 00010

Values for video mode:

     text/ text pixel	pixel	colors disply scrn  system
     grph resol	 box  resolution       pages  addr
 00h = T  40x25	 8x8   320x200	16gray	  8   B800 CGA,PCjr,Tandy
     = T  40x25	 8x14  320x350	16gray	  8   B800 EGA
     = T  40x25	 8x16  320x400	 16	  8   B800 MCGA
     = T  40x25	 9x16  360x400	 16	  8   B800 VGA
 01h = T  40x25	 8x8   320x200	 16	  8   B800 CGA,PCjr,Tandy
     = T  40x25	 8x14  320x350	 16	  8   B800 EGA
     = T  40x25	 8x16  320x400	 16	  8   B800 MCGA

     = T  40x25	 9x16  360x400	 16	  8   B800 VGA
 02h = T  80x25	 8x8   640x200	16gray	  4   B800 CGA,PCjr,Tandy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到 00h 为 40×25 字符，到这里大致清楚了功能号00（设置显示模式的使用），AH存放功能号00，AL存放字符显示模式，便可调用int 10h来调用BIOS设置显示模式。&lt;/p&gt;
&lt;p&gt;设置显示模式后来查看显示字符串的调用，0×10号中断的0×13功能号，还是来看手册中的描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 13h
	AL = write mode
	   bit 0: update cursor after writing
	   bit 1: string contains alternating characters and attributes
	   bits 2-7: reserved (0)
	BH = page number
	BL = attribute if string contains only characters
	CX = number of characters in string
	DH,DL = row,column at which to start writing
	ES:BP -&amp;gt; string to write
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里说一下BL，字体的属性，使用BIOS手册索引查找Attribute bits，得到屏幕颜色信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Screen colors.

 Normal colors       Bright colors          Attribute bits
 0 00 Black          8 08 Dark grey         7 normal    Foreground blink
 1 01 Blue           9 09 Light blue        7 alternate Background bright
 2 02 Green         10 0A Light green       6-4         Background color
 3 03 Cyan          11 0B Light cyan        3 normal    Foreground bright
 4 04 Red           12 0C Light red         3 alternate Alternate char. set

 5 05 Magenta       13 0D Light magenta     2-0         Foreground color
 6 06 Brown         14 0E Yellow
 7 07 White (grey)  15 0F Bright (white)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BL的0-2位表示前景色，3位表示高亮，4-6位表示背景色，7位表示前景闪烁。如果使用蓝色背景，红色前景，BL值应为 00011100 即 0x1c。&lt;/p&gt;
&lt;p&gt;接下来我们写一个BIOS调用输出字符串的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.code16
.text
	movw %cs, %ax
	movw %ax, %ds
	movw %ax, %es
	movw %ax, %ss

	movb $0, %ah
	movb $0, %al
	int $0x10

	movb $0x13, %ah
	movb $0, %al
	movb $0, %bh
	movb $0x1c, %bl
	movw $13, %cx
	movb $2, %dh
	movb $1, %dl
	movw $outstring, %bp
	int $0x10
	jmp .
outstring:
	.asciz &amp;quot;BIOS 10H 13H\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序开始使用.code16来指定16位代码段，第一个int $0×10设置字符显示模式为40×25，接着调用0×13号中断输出字符串，这里的参数设置可以参考手册，程序最后调用jmp . 跳转到当前位置，即形成一个死循环。最终结果便是显示蓝底红字的”BIOS 10H 13H”字串，同时单个cpu跑满。&lt;/p&gt;
&lt;p&gt;因为这里使用了 16位汇编，所以编译时也需要做相应改变，代码编译成16位实模式代码。因为BIOS调用只能处于实模式，所以在windows和linux上都无法使 用，好在windows兼容dos方式的虚拟8086模式，可以运行16位实模式程序，类似一个DOS的虚拟机，现在我们把代码编译成.com二进制文 件，由于.com是需要加载到0×100地址，所以我们仿照AT&amp;amp;T创建窗口的程序，写一个简单的ld链接脚本，指定加载地址为0×100：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SECTIONS
{
. = 0x0100;
.text : {*(.text)}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
as bios.s -o bios.o
ld bios.o -Tbios.lds
objcopy.exe -R .pdr -R .comment -R .note -S -O binary a.exe bios.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先用as编译汇编代码到目标文件，接着使用ld进行连接，指定脚本名bios.lds，连接之后称为a.exe，是windows下 的PE可执行格式，还需要使用objcopy命令去掉无用段信息成为二进制格式bios.com，如此，执行bios.com便可看到效果。如果用二进制 工具打开bios.com可以看到，文件中的二进制几乎与我们写的程序是一一对应的，完全可以在生成目标文件之后，直接使用 objcopy.exe -O binary bios.o bios.com 命令把目标文件拷成二进制文件，程序仍然可以执行，但是因为没有指定 0×0100起始地址，最终movw $outstring, %bp这里无法定位字符串，致使输出乱码，objcopy命令本身也可指定起始地址，只不过一直没有试验成功，不知应如何设置，这里暂且使用前者，虽然比 较繁琐，但毕竟能用。&lt;/p&gt;
&lt;p&gt;在本篇开始已经提到，BIOS加电自检以后会读取启动磁盘，如果发现第一扇区512字节以，55 AA结尾，则认为是引导区，会把这512字节载入到0x7c00地址处执行，根据这个说明，我们很容易做一个简单的引导区例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.code16
.text
	movw %cs, %ax
	movw %ax, %ds
	movw %ax, %es
	movw %ax, %ss

	movb $0, %ah
	movb $0, %al
	int $0x10

	movb $0x13, %ah
	movb $0, %al
	movb $0, %bh
	movb $0x1c, %bl
	movw $13, %cx
	movb $2, %dh
	movb $1, %dl
	movw $outstring, %bp
	int $0x10
	jmp .
outstring:
	.asciz &amp;quot;BIOS 10H 13H\n&amp;quot;

.org 510, 0
	.short 0xAA55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实这段代码跟虚拟8086显示字符的代码基本相同，只是末尾加入了.org宏，指示汇编器直接到510字节开始汇编，中间空出的字符 补0，最后以0xAA55结尾，因为内存中是大端方式存储数据。接下来需要修改的地方是连接脚本的0×0100，因为这里的程序需要加载至0x7c00， 所以修改这个地址，最后objcopy命令 bios.com 换成 bios.img，后缀只是为了让虚拟机识别。虚拟机会把img识别当软盘载入，之后的事情可以预料到了，BIOS会认为我们的这512字节文件是引导 区，并执行。&lt;/p&gt;
&lt;p&gt;使用二进制工具打开bios.img，检验一下，文件刚好512字节，并且以55 AA结尾。说明我们编译过程是没有问题的，接着使用virtual box或者VMware等虚拟机，配置软盘为bios.img，并且设置软盘为第一启动介质。接着开机，便可看到蓝底红字的BIOS 10H 13H！而且我们这里的代码完全独立于操作系统，是在裸机上执行的。&lt;/p&gt;
&lt;p&gt;这里的引导区可作为操作系统的前导，用于引导操作系统，Linux内核中也有一份类似代码，不过由于Linux使用了lilo或者grub这些专业的启动管理程序，内核引导代码便早已废弃。&lt;/p&gt;
&lt;h1 id=&#34;bios视频映射内存&#34;&gt;BIOS视频映射内存&lt;/h1&gt;
&lt;p&gt;之前说过BIOS的视频控制，仅仅说明的是字符显示，其实显卡可以设置两种模式，一种是图形模式，一种是字符模式，在BIOS中断10h ah=0时可以设置模式，在BIOS手册 video mode列表中，第二列有T和G字符，指明此种模式的类别，比如13h便是图形模式，屏幕大小为320×200，另外注意一个属性addr，这里是 A000，也就是说视频是映射至内存A000处，此地址是以后操作映射内存的基础：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Values for video mode:

     text/ text pixel	pixel	colors disply scrn  system
     grph resol	 box  resolution       pages  addr
 13h = G  40x25	 8x8   320x200	256/256K  .   A000 VGA,MCGA,ATI VIP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我便以此为例进行说明，再设置了显示模式以后，便要看如何绘图，绘图的操作当然也是通过BIOS调用，其中int 10h的0ch功能便是在屏幕上绘制一个像素点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Category: V - video

Inp.:
	AH = 0Ch
	BH = page number
	AL = pixel color
	    if bit 7 set, value is XOR&#39;ed onto screen except in 256-color modes
	CX = column
	DX = row
Return: nothing
Desc:	set a single pixel on the display in graphics modes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，有了绘制像素的功能，便可画线，之后一切的操作以此为基础实现。如果有兴趣可以试试此功能，在这里我并不使用这个调用，因为每次 调用BIOS都需要做很多操作，绘制一个图形需要非常多的像素，其速度可想而知。所以这里使用另外一种方式，就是内存映射，视频卡映射至内存，这样绘制屏 幕的像素可以像操作二维数组一般。&lt;/p&gt;
&lt;p&gt;在开始之前，先来看两条指令，in，out（输入输出指令），MASM语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;in al/ax/eax, port
out port, al/ax/eax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来看port，此操作数是硬件映射到cpu的端口，比如视频调色板port为3c8h，扬声器port为61h，当然这些端口值也可通过BIOS手册查找。&lt;/p&gt;
&lt;p&gt;先 来看颜色选择，13h的颜色并不用一个整数表示，而是使用调色板的概念，所谓调色板，可以理解为一个大小256的数组，数组每个元素都是一种颜色，每个颜 色由RGB三个字节组成，可提供256^3种颜色，但由于调色板的限制，每次只能显示256种颜色，调色板的索引0为背景色。视频调色板位于端口 3c8h。&lt;/p&gt;
&lt;p&gt;再看颜色，把颜色设置给对应的调色板，先选择调色板索引，之后再通过颜色选择端口 （3c9h）设置RGB值。&lt;/p&gt;
&lt;p&gt;另外视频的内存映射偏移为 0A000h，320 * 200大小的屏幕每个像素占1个字节，表示调色板的索引值，通过直接往这个地址范围写入调色板索引，便可决定对应像素的颜色，以达到绘制图形的效果。接下来我们通过例子来操作内存映射：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.model tiny
.code
org 7c00h

Video_Pallete_Port equ 3c8h
Color_Select_Port equ 3c9h
Video_Base equ 0A000h

Video_Width equ 320

main proc
	mov ax, Video_Base
	mov es, ax
	call SetVideoMode
	call SetBackgroudColor
	call DrawSquare
die:
	jmp die
main endp

SetVideoMode proc
	mov al, 13h
	mov ah, 0
	int 10h
	ret
SetVideoMode endp

; al : the video mode
SetBackgroudColor proc
	mov dx, Video_Pallete_Port
	mov al, 0
	out dx, al

	mov dx, Color_Select_Port
	mov al, 255
	out dx, al
	mov al, 0
	out dx, al
	out dx, al
	ret
SetBackgroudColor endp

DrawSquare proc
	mov dx, Video_Pallete_Port
	mov al, 1
	out dx, al

	mov dx, Color_Select_Port
	mov al, 0
	out dx, al
	out dx, al
	mov al, 255
	out dx, al

	;; Set The Squre Row Start
	mov bx, 30
	;; Set The Squre Row Num
	mov cx, 100
row:
	mov ax, Video_Width
	mul bx
	;; 10 Set Squre Col Start
	add ax, 10
	mov di, ax

	push cx
	;; Set The Squre Col Num
	mov cx, 100
col:
	mov byte ptr es:[di], 1
	inc di
	loop col
	pop cx
	inc bx
	loop row

	ret
DrawSquare endp

fill db (510 - (fill - main)) dup (0)
db 55h
db 0AAh

end main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里代码比较长，首先来看最开始org 7c00h， 指明该程序需要加载至7c00处，即引导程序加载位置。main函数里设置es段寄存器的地址为Video_Base，以便在此段中直接操纵内存，接下来调用了三个函数；&lt;/p&gt;
&lt;p&gt;函数SetVideoMode比较简单，调用int 10h设置显示模式为13h；&lt;/p&gt;
&lt;p&gt;函数SetBackgroudColor包含了调色板的操作，因为调色板索引0为背景，第一个out选择0调色板，接下来调用了三次out dx, al，dx为颜色选择端口，al为色彩值，以R、G、B的方式分别传出3个颜色字节进行设置，设置之后调色板0便为红色。&lt;/p&gt;
&lt;p&gt;函 数DrawSquare看似复杂，其实大部分都与BIOS调用无关，仅仅是计算坐标点，两个循环绘制了一个矩形，关键点有两个，第一个就是颜色设置，这次 设置的是调色板索引1，这里与SetBackgroudColor基本相同，再一个便是设置颜色，关键语句为 mov byte ptr es:[di], 1，如果记得，在main函数中把es设置为Video的机制，di是基址上的偏移，对应屏幕上的像素，这里屏幕像素是320*200，就是当dl为 320时是第二行第一列的像素，这里与二维数组的意义相同，第二个操作数1为刚才设置的调色板索引，综合来看，这句话的含义便是把内存位置（对应显存）设 置为调色板索引1的颜色。&lt;/p&gt;
&lt;p&gt;编译连接程序为 video.img，设置为虚拟机的软盘，并设置成第一启动介质，打开虚拟机便可看到红色背景上100*100的蓝色矩形。&lt;/p&gt;
&lt;h1 id=&#34;bios键盘中断&#34;&gt;BIOS键盘中断&lt;/h1&gt;
&lt;p&gt;这里来看一下BIOS中断的键盘控制部分，当用户按下键盘，键盘的扫描码从输入端口进入键盘缓冲，在系统中可以调用BIOS int 16h 来获取缓冲区中的扫描码和ASCII码。&lt;/p&gt;
&lt;p&gt;关于键盘操作的BIOS中断有很多种，接下来介绍一些常用的调用：&lt;/p&gt;
&lt;p&gt;设置击键重复率 03h ，当一直按着某个键，在按键开始重复之前有250~1000ms的延时。击键重复速率取值可以是1Fh（最慢）到0（最快）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 03h
	AL = subfunction
	    00h set default delay and rate (PCjr and some PS/2)
	    01h increase delay before repeat (PCjr)
	    02h decrease repeat rate by factor of 2 (PCjr)
	    03h increase delay and decrease repeat rate (PCjr)
	    04h turn off typematic repeat (PCjr and some PS/2)
	    05h set repeat rate and delay (AT,PS)
		BH = delay value (00h = 250ms to 03h = 1000ms)
		BL = repeat rate (00h=30/sec to 0Ch=10/sec [def] to 1Fh=2/sec)

    06h get current typematic rate and delay (newer PS/2s)
		Return: BL = repeat rate (above)
			BH = delay (above)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，当ah = 03h, al = 05h时设置速率，bh为重复率。&lt;/p&gt;
&lt;p&gt;等待按键，这是一个非常有用的功能，当键盘缓冲有按键时，删除按键并返回按键，没有时等待用户按键，以阻塞的方式运行，而且其参数非常简单，只需设置ah，返回ah为扫描码，al为ASCII码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 10h
Return: AH = BIOS scan code
	AL = ASCII character
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，还有可能有时不想等待，指向查看是否按键，没有按键便返回处理其他事情，这时功能11h便非常有用了，这个功能以非阻塞的方式返回按键，如果没有按键则ZF被设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 11h
Return: ZF set if no keystroke available
	ZF clear if keystroke available
	    AH = BIOS scan code
	    AL = ASCII character
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BIOS的16h功能全部用来处理键盘，另外还有检测按键状态等等，可查阅手册获知细节。&lt;/p&gt;
&lt;p&gt;这里改善上篇写的绘图程序，最终不以死循环结束程序，而是等待按键，根据按键做一些操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.model tiny
.code
org 7c00h

Video_Pallete_Port equ 3c8h
Color_Select_Port equ 3c9h
Video_Base equ 0A000h

Video_Width equ 320

main proc
	mov ax, Video_Base
	mov es, ax
	call SetVideoMode
	call SetBackgroudColor

die:
	mov ah, 10h
	int 16h
	cmp al, &#39;s&#39;
	jz shutdown
	cmp al, &#39;d&#39;
	jnz die
	call DrawSquare
	jmp die
shutdown:
	mov ax, 5301h
	xor bx, bx
	int 15h

	mov ax, 530eh
	mov cx, 0102h
	int 15h

	mov ax, 5307h
	mov bx, 1h
	mov cx, 03h
	int 15h

main endp

SetVideoMode proc
	mov al, 13h
	mov ah, 0
	int 10h
	ret
SetVideoMode endp

SetBackgroudColor proc
	mov dx, Video_Pallete_Port
	mov al, 0
	out dx, al

	mov dx, Color_Select_Port
	mov al, 255
	out dx, al
	mov al, 0
	out dx, al
	out dx, al
	ret
SetBackgroudColor endp

DrawSquare proc
	mov dx, Video_Pallete_Port
	mov al, 1
	out dx, al

	mov dx, Color_Select_Port
	mov al, 0
	out dx, al
	out dx, al
	mov al, 255
	out dx, al

	mov bx, 30
	mov cx, 100
row:
	mov ax, Video_Width
	mul bx
	add ax, 10
	mov di, ax

	push cx
	mov cx, 100
col:
	mov byte ptr es:[di], 1
	inc di
	loop col
	pop cx
	inc bx
	loop row

	ret
DrawSquare endp

fill db (510 - (fill - main)) dup (0)
db 55h
db 0AAh

end main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里修改的东西并不多，在程序启动时不进行绘图，而是调用int 16h来获取按键，检测按键为d时进行绘图，并且按键为s时调用了三组int 15h中断，15h调用掌管系统状态，当ax为5307h时可以关闭设备电源等，这三组int 15h功能是关闭计算机，其中细节可以通过手册获取。其实中断调用除了图形映射内存这种有一定背景的功能外，其他功能相对独立，使用时可能不知道改使用哪 个中断，一旦得知所使用的中断号，通过手册很容易掌握中断。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AX = 5307h
	BX = device ID (see #00474)
	CX = system state ID (see #00475)
Return: CF clear if successful
	CF set on error
	    AH = error code (01h,03h,09h,0Ah,0Bh,60h) (see #00473)

Table 00474
Values for APM device IDs:
 0000h	system BIOS
 0001h	all devices for which the system BIOS manages power
 01xxh	display (01FFh for all attached display devices)

Table 00475
Values for system state ID:
 0000h	ready (not supported for device ID 0001h)
 0001h	stand-by
 0002h	suspend
 0003h	off (not supported for device ID 0001h in APM v1.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后可在虚拟机上查看效果，由于增加了键盘等待，程序不会空耗cpu资源，而且可以关机，也不用使用暴力的方式断电关机。&lt;/p&gt;
&lt;h1 id=&#34;汇编优化执行文件大小&#34;&gt;汇编优化执行文件大小&lt;/h1&gt;
&lt;p&gt;闲来无事写了一个点灯小游戏，记得当年在文曲星上玩过，现在使用BIOS中断在引导区实现，其实整个游戏实现起来并不复杂，无非是一些BIOS调 用，图形显示等等，但是最让人郁闷的事情是引导程序仅仅有512字节，当然有方法突破这个限制，但这仅仅是个小程序，没有必要再去载入文件到内存。不过这 个以后倒可以试试。&lt;/p&gt;
&lt;p&gt;这里的代码不少，我会附到文后，不过我想也没有人去研究如此杂乱的代码。不过程序还有不少问题，BIOS刷新屏幕的部分，我重绘背景，这样导致刷新时会闪 屏，也不算很大的bug，我也没有花精力去解决这个问题，还有一个问题是填充的问题，最后填充时总是说长度不能为负，不过实际计算长度远不足512，不知 道什么机制导致这种错误，不过最后我编译好程序刚刚好512字节，也不存在填充的问题了，只是扩展不易。&lt;/p&gt;
&lt;p&gt;其实编译结果为512字节并非巧合，开始写完程序时文件有680多字节，经过调整代码，压缩，最终才缩小至512字节，能让系统正常引导。这里说下压缩可执行文件大小的经验：&lt;/p&gt;
&lt;h2 id=&#34;一立即数优化&#34;&gt;一、立即数优化&lt;/h2&gt;
&lt;p&gt;程 序中经常有 mov ax, 0 类似的指令，目的是把一个寄存器清零，别看这里的0是很小的数字，他占用的大小与 0ffffh 无异，都是根据Intel立即数的大小而定的，其他的比如ax和mov仅仅是intel的一个索引，所需字节很少，所以如非必要，尽力避免立即数的使用， 寄存器清零可使用 xor ax, ax 指令实现。相同的原理 cmp ax, 0 可用 test ax, ax 实现。
还是如果给寄存器加2，直接写成 add bp, 2 甚至比两个inc bp还要大。&lt;/p&gt;
&lt;h2 id=&#34;二地址优化&#34;&gt;二、地址优化&lt;/h2&gt;
&lt;p&gt;时 常会出现使用 address 寻址变量的情况，如果一个变量寻址多次，mov ax, word ptr[address]就会出现多次，address在16位平台大小16位，这样累计也是很客观的大小，这种情况可以使用mov si, offset address 指令，刚才提到，si寄存器仅仅是一个索引，所以mov ax, word ptr[si] 会比刚才要小，如果相同代码很多，则可节省不少空间。&lt;/p&gt;
&lt;p&gt;另外，还有函数的调用，有些代码放到函数中可减少重复代码，但如果函数很小call address占用的空间便会很大；
如果要保存一个寄存器待执行完毕后恢复，使用push cx, pop cx要比先存储与其他寄存器事后再恢复要小很多。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言练习-AT&amp;T汇编win32窗口</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-gas-win32/</link>
        <pubDate>Sun, 27 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-gas-win32/</guid>
        <description>&lt;p&gt;这里写一个win32窗口程序，如果对c语言如何使用api创建窗口还不熟悉，请先学习win32 api的使用，网上有很多用masm编写win32程序的例子，使用masm编写win32程序也比较方便，这里便不再重复。&lt;/p&gt;
&lt;p&gt;masm 毕竟对win32的api自己做了一层封装，不能使我们更加透彻的理解win32 api，所以我这里的例子使用AT&amp;amp;T语法编写，编译环境为mingw，当然，这里依赖于windows平台，语法虽说是跨平台的，但使用了系统 调用，便无法在linux下使用了。&lt;/p&gt;
&lt;p&gt;似乎很少有使用AT&amp;amp;T语法写窗口的例子，可能因为这样写比较繁琐，且没有意义，所以本例可能只是练习AT&amp;amp;T语法，顺便学习win32 api最原生的程序是什么样子，如果反汇编一个程序，看到的样子应该与这个相差无几，也为逆向或者破解做一些基础工作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
class_name:
	.asciz &amp;quot;go&amp;quot;
window_name:
	.asciz &amp;quot;First AT&amp;amp;T Windows&amp;quot;

.section .text

.globl _WindowProc
_WindowProc:
	pushl %ebp
	movl %esp, %ebp
	subl $16, %esp

	/*
		8 (%ebp) hwnd
		12(%ebp) message
		16(%ebp) wParam
		20(%ebp) lParam
	*/
	/* WM_DESTROY */
	cmp $0x0002, 12(%ebp)
	jnz L1
	pushl $0
	call _PostQuitMessage@4
L1:

	pushl 20(%ebp)
	pushl 16(%ebp)
	pushl 12(%ebp)
	pushl 8(%ebp)
	call _DefWindowProcA@16
	addl $16, %esp

	movl %ebp, %esp
	popl %ebp
	ret $16

.globl _main
_main:
	pushl %ebp
	movl %esp, %ebp
	subl $128, %esp
	/*
		-4(%ebp)  className
		-8(%ebp)  menuName
		-12(%ebp) hbrbackground
		-16(%ebp) hCursor
		-20(%ebp) hIcon
		-24(%ebp) hInstance
		-28(%ebp) wnd extra
		-32(%ebp) class extra
		-36(%ebp) callback
		-40(%ebp) style
	*/
	movl $0x03, -40(%ebp)
	movl $_WindowProc, -36(%ebp)
	movl $0, -32(%ebp)
	movl $0, -28(%ebp)
	movl 8(%ebp), %eax
	movl %eax, -24(%ebp)
	movl $0, -20(%ebp)
	movl $0, -16(%ebp)

	pushl $4
	call _GetStockObject@4
	movl %eax, -12(%ebp)
	movl $0, -8(%ebp)
	movl $class_name, -4(%ebp)

	leal -40(%ebp), %eax
	pushl %eax
	call _RegisterClassA@4

	/*
		-44(%ebp) hwnd
	*/
	pushl $0
	pushl -24(%ebp)
	pushl $0
	pushl $0
	pushl $0x80000000
	pushl $0x80000000
	pushl $0x80000000
	pushl $0x80000000
	pushl $0xCF0000
	pushl $window_name
	pushl $class_name
	pushl $0
	call _CreateWindowExA@48
	movl %eax, -44(%ebp)

	pushl $1
	pushl -44(%ebp)
	call _ShowWindow@8

	pushl -44(%ebp)
	call _UpdateWindow@4

	/*
		28 byte MSG
		-48(%ebp) -&amp;gt; -76(%ebp)
	*/

L_Message:
	pushl $0
	pushl $0
	pushl $0
	leal -76(%ebp), %eax
	pushl %eax
	call _GetMessageA@16
	test %eax, %eax
	jz L_End

	leal -76(%ebp), %eax
	pushl %eax
	call _TranslateMessage@4

	leal -76(%ebp), %eax
	pushl %eax
	call _DispatchMessageA@4
	jmp L_Message

L_End:
	movl %ebp, %esp
	popl %ebp
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里基本结构是win32 api标准的窗口创建程序，只是AT&amp;amp;T语法没有相应的结构体，只能通过操作一块内存的方式处理，在AT&amp;amp;T看来，windows下的所 有结构体都仅仅是一块内存，具体多少偏移代表什么意义，还需根据win32的结构体对应。这里的符号有些奇怪，之前提到过STDCALL的符号处理方式， 后缀要加“@参数字节数”。&lt;/p&gt;
&lt;p&gt;编译过程使用 gcc win.s -lgdi32 因为其中使用了gdi函数，所以需引入gdi32库。&lt;/p&gt;
&lt;p&gt;如 果注意一下编译后的可执行文件大小，足足有27k之多，对于masm汇编可能就有几k，真是天壤之别，难道mingw如此臃肿么？其实这里正是mingw 灵活的地方，之所以编译后有如此之大，是因为mingw添加了很多信息，对于windows的pe格式，不管你怎么编译，最终可用代码都是一样的，而ld 连接器可以自定义脚本，甚至手工设置段信息，这里来试一下，先写一个win.lds的ld脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SEARCH_DIR(&amp;quot;D:\Program Files\MSYS\mingw\lib&amp;quot;)
SEARCH_DIR(&amp;quot;D:\Program Files\MSYS\mingw\include&amp;quot;)
ENTRY(_main)

SECTIONS
{
. = 0X40000;
.text : {*(.text)}
.data : {*(.data)}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;脚本开始定义一下搜索路径，方便找到引用的头文件和库，ENTRY定义了程序的入口函数符号，SECTIONS定义各个段，从0×40000开始，依次是代码段和数据段。&lt;/p&gt;
&lt;p&gt;之后再进行分步编译：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;as win.s -o
ld win.lds a.out -lgdi32 -luser32
strip a.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终生成可执行文件a.exe，可以看到仅仅有2k了。如果之前大家用od调试过mingw的程序，可以看到大部分的代码都不是我们所写，调试也不方便，但通过这种方式生成，用ollydbg反汇编后，剩下的大部分都是我们所写的有效代码，而且基本与我们的代码一一对应。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言练习-实模式下的汇编</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-16-asm-real-mode.md/</link>
        <pubDate>Sat, 26 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-16-asm-real-mode.md/</guid>
        <description>&lt;p&gt;在MS-DOS下，没有保护模式与32位寄存器，程序可以直接调用BIOS中断，虽然DOS系统已经离我们远去，但是Intel CPU进入保护模式之前需在实模式下进行设置和跳转，所以实模式编程仍然具有一定的意义，在本篇中不介绍纯DOS环境下的MASM，仅仅利用 Windows的虚拟8086模式编程，虚拟8086是Intel为了兼容实模式程序推出的，此模式可以让用户程序在32位系统上进行16位操作，模拟了 8086处理器。&lt;/p&gt;
&lt;p&gt;在16位实模式下，由于寻址空间的限制，必须把内存划分为多个段，如果单纯的使用一个offset，由于16位的操作数，最多能寻址 64k 的地址空间，但8086 cpu的数据总线有20位，也就是能够寻址1M的地址，所以intel处理器想出了 seg:offset 的方式，去寻址，首先由seg段寄存器定位一个地址，再此地址上进行偏移，具体计算 seg * 16 + offset ，如此便可达到20位的寻址。所以在实模式下编程，还需要注意段寄存器，在寻址之前要看使用的段。&lt;/p&gt;
&lt;p&gt;还有一个问题是编译最后的格式，之前在windows保护模式下，编译最后都是windows可执行文件PE格式，这显然是不能在实模式下运行的，所以还需要把我们的程序编译成能够在实模式下运行的文件。&lt;/p&gt;
&lt;p&gt;在MS-DOS下支持一种COM二进制执行文件，COM格式是纯二进制代码，系统加载时把此文件加载至100h内存处。现来写一个简单的COM程序框架：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.model tiny
.code
org 100h

main proc
	mov ah, 2
	mov dl, &#39;A&#39;
	int 21h
die:
	jmp die
	ret
main endp
end main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码开始首先使用.model设置当前内存模式是tiny，而非之前的flat模式，然后再代码开始的地方使用org伪指令指定程序将要载入内存的位置，这里设置段基址时有用，如果设置错误将会找不到定义的数据字符。&lt;/p&gt;
&lt;p&gt;接下来使用了int 21h，int 21h是DOS调用，DOS调用相比BIOS调用就方便的多了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先把功能号存储于AH寄存器 
把参数传入指定寄存器
int 21h 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里使用功能号2，输出一个字符，DOS调用的其他功能网上有大量教程，而且DOS调用至今或许也没太大价值，这里便不再叙述。&lt;/p&gt;
&lt;p&gt;最后再来看如何编译我们的程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ml /c 16bit.asm
link16 /TINY 16bit.obj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的连接程序使用了link16处理16位程序，之后双击16bit.com，便可看到控制台窗口输出字符A，程序进入死循环。&lt;/p&gt;
&lt;p&gt;当然，可以利用刚才所述内从结合上篇BIOS视频控制来制作系统的引导程序，仅仅需要再程序之后填充至512字节并且以 55AA结尾便可，这里列举一下填充部分代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fill db (510 - (fill - main)) dup (0)
db 55h
db 0AAh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里进行了一次计算，fill为当前位置，减去程序开始地址，即到当前所用去的字节数，再被510减，得到需要填充的字节数，用0补足，最后在定义 55AA 标志字即可，当然DOS调用是无法使用的，需要替换成BIOS调用。&lt;/p&gt;
&lt;p&gt;关于AT&amp;amp;T实模式编程，可参考后面的BIOS模式下的汇编编程&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十四)-SSE指令集</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.-assembler-sse-instruct/</link>
        <pubDate>Fri, 25 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.-assembler-sse-instruct/</guid>
        <description>&lt;p&gt;本篇介绍sse指令接，sse是流化SIMD扩展（Streaming SIMD Extension, SSE)，提供全新的一组寄存器，处理128位打包数据。&lt;/p&gt;
&lt;p&gt;sse提供了xmm寄存器，xmm一组8个128位的寄存器，分别名为xmm0-xmm7，sse构架提供对打包单精度浮点数的SIMD支持。&lt;/p&gt;
&lt;p&gt;sse提供了两个版本的指令，其一以后缀ps结尾，这组指令对打包单精度浮点值执行类似mmx操作运算，而第二种后缀ss，这些指令对一个量标单精度浮点 值进行运算操作，这些指令不对打包值中的所有浮点值操作，而只对打包值中的低位双字节执行操作，源操作数中剩余的3个值直接传送给结果。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;movaps&lt;/td&gt;
&lt;td&gt;把4个对准的单精度值传送到xmm寄存器或者内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movups&lt;/td&gt;
&lt;td&gt;把4个不对准的单精度值传送到xmm寄存器或者内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movss&lt;/td&gt;
&lt;td&gt;把1个单精度值传送到内存或者寄存器的低位双字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movlps&lt;/td&gt;
&lt;td&gt;把2个单精度值传送到内存或者寄存器的低四字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movhps&lt;/td&gt;
&lt;td&gt;把2个单精度值传送到内存或者寄存器的高四字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movlhps&lt;/td&gt;
&lt;td&gt;把2个单精度值从低四字传送到高四字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movhlps&lt;/td&gt;
&lt;td&gt;把2个单精度值从高四字传送到低四字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中对准操作movaps要求数据在内存中对准16字节的边界，以提交效率，否则应使用movups传送数据。&lt;/p&gt;
&lt;p&gt;运算指令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;addps&lt;/td&gt;
&lt;td&gt;将两个打包值相加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;subps&lt;/td&gt;
&lt;td&gt;将两个打包值相减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mulps&lt;/td&gt;
&lt;td&gt;将两个打包值相乘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;divps&lt;/td&gt;
&lt;td&gt;将两个打包值相除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rcpps&lt;/td&gt;
&lt;td&gt;计算打包值的倒数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sqrtps&lt;/td&gt;
&lt;td&gt;计算打包值的平方根&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rsqrtps&lt;/td&gt;
&lt;td&gt;计算打包值的平方根倒数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;maxps&lt;/td&gt;
&lt;td&gt;计算两个打包值中的最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;minps&lt;/td&gt;
&lt;td&gt;计算两个打包值中的最小值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;andps&lt;/td&gt;
&lt;td&gt;计算两个打包值的按位逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;andnps&lt;/td&gt;
&lt;td&gt;计算两个打包值的按位逻辑非&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;orps&lt;/td&gt;
&lt;td&gt;计算两个打包值的按位逻辑或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xorps&lt;/td&gt;
&lt;td&gt;计算两个打包值的按位逻辑异或&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上指令都是用两个操作数：源操作数可以是128位内存或者xmm寄存器，目标操作数必须是xmm寄存器。&lt;/p&gt;
&lt;p&gt;这里举一个简单的例子，使用gdb查看最后结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
	value1: .float 12.12, 34.89, 56.23, 78.45
	value2: .float 31.12, 57.124, 234.23, 67.246
.section .text
.globl _main
_main:
	enter $0, $0

	movups value1, %xmm0
	movups value2, %xmm1
	addps %xmm0, %xmm1

	movups value2, %xmm1
	maxps %xmm0, %xmm1
	leave
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译时加-g参数加入调试信息，调用addps后查看xmm1寄存器的结果，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) print $xmm1
$1 = {v4_float = {43.2400017, 92.0139999, 290.459991, 145.695999},
  v2_double = {26419069594869.762, 1245245520236216.2}, v16_int8 = {-61, -11,
    44, 66, 43, 7, -72, 66, -31, 58, -111, 67, 45, -78, 17, 67}, v8_int16 = {
    -2621, 16940, 1835, 17080, 15073, 17297, -19923, 17169}, v4_int32 = {
    1110242755, 1119356715, 1133591265, 1125233197}, v2_int64 = {
    4807600484593235395, 4832839782622116577},
  uint128 = 0x4311b22d43913ae142b8072b422cf5c3}
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，调用加法指令之后，四组和都存储在xmm1寄存器中，gdb查看时由于不知道如何解析xmm1寄存器的内容，因为可能是单精度，也可能是双精度或者不同宽度的整数，所以只能按不同的解析方式全部显示，查看v4_float即四个单精度浮点数的显示。&lt;/p&gt;
&lt;p&gt;下面介绍一下sse构架下的比较指令，sse的比较指令单独比较128位打包单精度浮点的每个元素，结果是一个掩码，满足比较条件的结果全为1值，不满足结果的全为0值（量标只对最低的双字执行）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cmpps&lt;/td&gt;
&lt;td&gt;比较打包值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmpss&lt;/td&gt;
&lt;td&gt;比较标量值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;comiss&lt;/td&gt;
&lt;td&gt;比较标量值并且设置eflags寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ucomiss&lt;/td&gt;
&lt;td&gt;比较标量值（包括非法值）并设置eflags寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;看到这里，仅仅有一个比较指令，并没有说明大小，何为满足条件全1，不满足全0呢，这样说一下指令的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmpps imp, source, destination
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中多出来的imp是一个无符号整数，这个整数表示的含义就是条件，这个条件值如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;整数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;小于或等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;不小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;不小于或等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果需要比较两个数是否相等，传imp为0即可作为条件，满足条件结果全1，这是sse的比较方式。这里说明一下条件中的无序，因为是浮点比较，寄存器或内存中的有些值并不符合规定的浮点存储格式，相互比较是没有意义的，称为无序。&lt;/p&gt;
&lt;p&gt;除了对浮点数的支持，sse指令集也有指令对mmx提供的功能进行扩展，他们对mmx寄存器中的数据执行操作：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pavgb&lt;/td&gt;
&lt;td&gt;计算打包无符号字节整数的平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pavgw&lt;/td&gt;
&lt;td&gt;计算打包无符号字整数的平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pextrw&lt;/td&gt;
&lt;td&gt;把一个字从mmx寄存器复制到通用寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pinsrw&lt;/td&gt;
&lt;td&gt;把一个字从通用寄存器复制到mmx寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pmaxub&lt;/td&gt;
&lt;td&gt;计算打包无符号字节整数的最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pmaxsw&lt;/td&gt;
&lt;td&gt;计算打包有符号字整数的最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pminub&lt;/td&gt;
&lt;td&gt;计算打包无符号字节整数的最小值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pminsw&lt;/td&gt;
&lt;td&gt;计算打包有符号字整数的最小值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pmulhuw&lt;/td&gt;
&lt;td&gt;将打包无符号字整数相乘并且存储高位结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psadbw&lt;/td&gt;
&lt;td&gt;计算无符号字节整数的绝对差的总和&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SSE2 指令集又对 SSE 指令集做了很多扩充，主要对操作双精度浮点数和128位打包整数值执行数学操作，下面介绍SSE2的使用，先来看数据传送指令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;movapd&lt;/td&gt;
&lt;td&gt;把2个对准的双精度值传送到xmm寄存器或者内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movupd&lt;/td&gt;
&lt;td&gt;把2个不对准的双精度值传送到xmm寄存器或者内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movdqa&lt;/td&gt;
&lt;td&gt;把2个对准的四字节整数传送到xmm寄存器或者内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movdqu&lt;/td&gt;
&lt;td&gt;把2个不对准的四字节整数传送到xmm寄存器或者内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movsd&lt;/td&gt;
&lt;td&gt;把1个双精度值传送到内存或者寄存器的低四字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movhpd&lt;/td&gt;
&lt;td&gt;把1个双精度值传送到内存或者寄存器的高四字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movlpd&lt;/td&gt;
&lt;td&gt;把1个双精度值传送到内存或者寄存器的低四字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SSE2指令集提供处理打包双精度浮点数，打包字整数，打包双字整数和打包四字整数值的数学指令，这里列举SSE2的加法指令来说明这一系列指令格式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;addpd&lt;/td&gt;
&lt;td&gt;将打包双精度浮点值相加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;addsd&lt;/td&gt;
&lt;td&gt;将量标双精度浮点值相加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddsb&lt;/td&gt;
&lt;td&gt;将打包带符号字节整数相加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddsw&lt;/td&gt;
&lt;td&gt;将打包带符号字整数相加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddd&lt;/td&gt;
&lt;td&gt;将打包带符号双字整数相加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddq&lt;/td&gt;
&lt;td&gt;将打包带符号四字整数相加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里虽然只列举add系列指令，这些选项也存在于乘法和除法操作中(mulpd, mulsd, divpd, divsd等）。
另外同sse指令集，sse2指令集也提供专门的数学操作，sqrt, max, min。&lt;/p&gt;
&lt;p&gt;最后我们来看SSE3指令集，SSE3构架并没有提供任何新的数据类型，仅仅添加了几条指令，用于更快的执行标准函数，下面是新指令的列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;fisttp&lt;/td&gt;
&lt;td&gt;把第一个fpu寄存器的值转换为整数（舍入）并且从fpu堆栈弹出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lddqu&lt;/td&gt;
&lt;td&gt;快速从内存加载128位不对准的数据值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movshdup&lt;/td&gt;
&lt;td&gt;传送128位值，复制第2个和第4个32位数据元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movsldup&lt;/td&gt;
&lt;td&gt;传送128位值，复制第1个和第3个32位数据元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;movddup&lt;/td&gt;
&lt;td&gt;传送64位值，赋值值，使之成为128位值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;addsubps&lt;/td&gt;
&lt;td&gt;对于打包单精度浮点数，对第2个和第4个32位执行加法，第1和第3个32位执行减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;addsubpd&lt;/td&gt;
&lt;td&gt;对于打包单精度浮点数，对第2对64位值执行加法，第1对位执行减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;haddps&lt;/td&gt;
&lt;td&gt;对操作数的相邻的元素执行单精度浮点加法操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;haddpd&lt;/td&gt;
&lt;td&gt;对操作数的相邻的元素执行双精度浮点加法操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hsubps&lt;/td&gt;
&lt;td&gt;对操作数的相邻的元素执行单精度浮点减法操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hsubpd&lt;/td&gt;
&lt;td&gt;对操作数的相邻的元素执行双精度浮点减法操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SSE指令繁多，这里举得例子却很少，以后我会在此文继续附加一些说明例子，方便理解。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十三)-MMX指令集</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.-assembler-mmx-instruct/</link>
        <pubDate>Thu, 24 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.-assembler-mmx-instruct/</guid>
        <description>&lt;p&gt;这篇来介绍intel cpu的高级特性，SIMD-单指令多数据，从名字来看，就是执行一条指令可以计算多个数据。先从最简单的mmx指令集来看，在寄存器那篇已经提 到，mmx有 mm0-mm7 共8个64位寄存器，但是寄存器并非独立寄存器，而是复用了上篇说到的fpu数据堆栈寄存器，也就是说使用mmx指令集会破坏fpu的计算，如果同时使用 着两种特性，一定要注意这点，避免出现莫名的错误。&lt;/p&gt;
&lt;p&gt;首先mmx指令集需要cpu的支持，但不是所有cpu都支持，不然也不会称之为高级特性 了，所以在使用之前需要检测，检测指令为cpuid，获得cpu的特性，cpuid虽然只有一条指令，但是其隐含的内容太多，这里仅仅介绍检测SIMD指 令集所需要的部分，其他一些信息可参阅Intel 手册获得。&lt;/p&gt;
&lt;p&gt;当eax为1时，cpuid指令返回cpu签名信息，放入ecx和edx寄存器中，相应位为1表示支持。检测SIMD指令集的结果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器&lt;/th&gt;
&lt;th&gt;位&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;支持MMX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;支持SSE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;支持SSE2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ECX&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;支持SSE3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;具体检测代码如下(AT&amp;amp;T 语法)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
	mmxstring: .asciz &amp;quot;支持mmx指令集\n&amp;quot;
	ssestring: .asciz &amp;quot;支持sse指令集\n&amp;quot;
	sse2string: .asciz &amp;quot;支持sse2指令集\n&amp;quot;
	sse3string: .asciz &amp;quot;支持sse3指令集\n&amp;quot;

.section .text
.globl _main
_main:
	movl $1, %eax
	cpuid

mmxop:
	test $0x800000, %edx
	jz sseop
	pushl $mmxstring
	call _printf

sseop:
	test $0x2000000, %edx
	jz sse2op
	pushl $ssestring
	call _printf

sse2op:
	test $0x4000000, %edx
	jz sse3op
	pushl $sse2string
	call _printf

sse3op:
	test $0x01, %ecx
	jz end
	pushl $sse3string
	call _printf
end:
	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面正式开始mmx指令集的介绍，使用mmx需要三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从整数值创建打包整数，载入mmx寄存器&lt;/li&gt;
&lt;li&gt;使用mmx指令集计算&lt;/li&gt;
&lt;li&gt;从mmx获得结果，存入内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个和最后一个步骤比较简单，仅仅是数据移动而已，这里提到打包，因为这里要单指令多数据，所以需要把多数据合成一个操作数进行计算，存入64位的mmx寄存器中，打包的过程就是把 8个字节/4个字/2个双字 合成一个64位数据。&lt;/p&gt;
&lt;p&gt;从加减法说起，对于普通数据，如果数据溢出可以置标记位，但是对于多数据的运算，由于同时计算多个加法，就不能单纯的设置标志，对mmx计算有几种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;环绕运算		截断其值，丢弃进位
带符号饱和	最大/最小 带符号值
无符号饱和	最大/最小 无符号值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中饱和运算的预设值根据结果的位数决定，有符号8位最大为127，如果超过127，结果按127计算，其他情况与此类似，这里方便与一些图形处理，比如色彩黑色为0，为无符号最小值，小于其值也按黑色处理。&lt;/p&gt;
&lt;p&gt;好 了，到此可以看一下具体的指令，这里的指令有相同的格式，instruction source, destination;其中source可以是mmx寄存器或者64位内存，destination为mmx寄存器。这是AT&amp;amp;T语法，对于 MASM语法源目的操作数相反。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;paddb&lt;/td&gt;
&lt;td&gt;环绕打包字节整数加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddw&lt;/td&gt;
&lt;td&gt;环绕打包字整数加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddd&lt;/td&gt;
&lt;td&gt;环绕打包双字整数加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddsb&lt;/td&gt;
&lt;td&gt;带符号饱和打包字节整数加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddsw&lt;/td&gt;
&lt;td&gt;带符号饱和打包字整数加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddusb&lt;/td&gt;
&lt;td&gt;无符号饱和打包字节整数加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paddusw&lt;/td&gt;
&lt;td&gt;无符号饱和打包字整数加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psubb&lt;/td&gt;
&lt;td&gt;环绕打包字节整数减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psubw&lt;/td&gt;
&lt;td&gt;环绕打包字整数减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psubd&lt;/td&gt;
&lt;td&gt;环绕打包双字整数减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psubsb&lt;/td&gt;
&lt;td&gt;带符号饱和打包字节整数减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psubsw&lt;/td&gt;
&lt;td&gt;带符号饱和打包字整数减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psubusb&lt;/td&gt;
&lt;td&gt;无符号饱和打包字节整数减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psubusw&lt;/td&gt;
&lt;td&gt;无符号饱和打包字整数减法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面以AT&amp;amp;T加法为例进行说明，这里以饱和方式计算4个无符号字之和：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# add four word
# output : result is 18932, 7631, 65535, 510
.section .data
	value1: .short 12300, 2384, 60000, 456
	value2: .short 6632, 5247, 40000, 54

	outstring: .asciz &amp;quot;result is %u, %u, %u, %u\n&amp;quot;
.section .text
.globl _main
_main:
	movq value1, %mm0
	movq value2, %mm1
	paddusw %mm1, %mm0
	movq %mm0, value1

	movl $value1, %ebx
	xorl %eax, %eax
	movw 6(%ebx), %ax
	pushl %eax
	movw 4(%ebx), %ax
	pushl %eax
	movw 2(%ebx), %ax
	pushl %eax
	movw (%ebx), %ax
	pushl %eax

	pushl $outstring
	call _printf

	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;movq 指令把内存中的数据传送至mmx寄存器，如果数据之前在内存中不是连续的，则需要集中存放，即进行打包，之后使用paddusw进行加法计算，输出时 word需转化成dword放入堆栈，可以看到以饱和方式第三个结果为65535，即16位无符号数的最大值。从这里例子可以看出，通过一条指令计算了四 个word整数相加，很大程度上提高了计算的效率，但是同时需要注意，整数的打包以及传送过程也需要耗时，如果打包操作很多，结果不是提高效率而是降低效 率了。&lt;/p&gt;
&lt;p&gt;mmx指令集的加法根据需要有饱和方式和环绕方式计算，但对于乘法而言，由于结果的宽度可能是操作数的两倍，所以两种方式看上去都不合适，所以intel提供了两个指令，一个得到计算结果的低字节，另一个得到计算结果的高字节。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pmulluw&lt;/td&gt;
&lt;td&gt;对无符号16位整数相乘取结果低16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pmulhuw&lt;/td&gt;
&lt;td&gt;对无符号16位整数相乘取结果高16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pmullw&lt;/td&gt;
&lt;td&gt;对有符号16位整数相乘取结果低16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pmulhw&lt;/td&gt;
&lt;td&gt;对有符号16位整数相乘取结果高16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pmaddwd&lt;/td&gt;
&lt;td&gt;对4个带符号整数相乘，高位两个结果相加存入高32位，低位相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;mmx指令集还提供对四字值进行布尔逻辑操作和移位指令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pand&lt;/td&gt;
&lt;td&gt;对源和目标操作数按位与操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pandn&lt;/td&gt;
&lt;td&gt;对目标操作数进行按位逻辑非操作，然后对源和目标操作数按位与操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;por&lt;/td&gt;
&lt;td&gt;对源和目标操作数按位或操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pxor&lt;/td&gt;
&lt;td&gt;对源和目标操作数按位异或操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psll&lt;/td&gt;
&lt;td&gt;对目标操作数执行逻辑左移操作，使用0填充空位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;psra&lt;/td&gt;
&lt;td&gt;对目标操作数执行逻辑右移操作，使用0填充空位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其AT&amp;amp;T指令格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pand source, destination
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中source是mmx寄存器或者64位内存，destination必须是mmx寄存器。移位指令可以使用字，双字或者四字操作数，还有移位的位置数量。MASM格式的源目的操作数相反。&lt;/p&gt;
&lt;p&gt;mmx构架提供了用于比较两个值的指令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pcmpeqb&lt;/td&gt;
&lt;td&gt;比较打包字节整数值的相等性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pcmpeqw&lt;/td&gt;
&lt;td&gt;比较打包字整数值的相等性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pcmpeqd&lt;/td&gt;
&lt;td&gt;比较打包双字整数值的相等性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pcmpgtb&lt;/td&gt;
&lt;td&gt;判断打包字节整数值是否大于另一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pcmpgtw&lt;/td&gt;
&lt;td&gt;判断打包字整数值是否大于另一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pcmpgtd&lt;/td&gt;
&lt;td&gt;判断打包双字整数值是否大于另一个&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为mmx同时比较多个数据，所以不能设置标志，替换的做法是把判断结果放到目标打包整数值中，如果打包整数值满足对比提交，就把结果设置为全1，否则设置为全0。&lt;/p&gt;
&lt;p&gt;由于mmx指令集并非所有cpu都可以支持，所以对c语言这种编译通用性的程序而言，是不会贸然使用mmx指令集的，这也对我们手工汇编优化程序提供了很大的空间，但是需要注意打包整数的效率损耗。&lt;/p&gt;
&lt;p&gt;另外，intel除了mmx指令集，另有SIMD指令如sse指令集，将会再下篇详细说明。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十二)-浮点指令</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.-assembler-float-instruct/</link>
        <pubDate>Wed, 23 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.-assembler-float-instruct/</guid>
        <description>&lt;h1 id=&#34;浮点数如何存储&#34;&gt;浮点数如何存储&lt;/h1&gt;
&lt;p&gt;浮点数的运算完全不同于整数，从寄存器到指令，都有一套独特的处理流程，浮点单元也称作x87 FPU。&lt;/p&gt;
&lt;p&gt;现在看浮点数的表示方式，我们所知道的，计算机使用二进制存储数据，所表示的数字都具有确定性，那是如何表示浮点这种具有近似效果的数据呢，答案是通过科学计数，科学计数由符号，尾数和指数表示，这三部分都是一个整数值，具体来看一下IEEE二进制浮点标准：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单精度&lt;/td&gt;
&lt;td&gt;32位：符号占1位，指数占8位，尾数中的小数部分占23位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;双精度&lt;/td&gt;
&lt;td&gt;64位：符号占1位，指数占11位，尾数中的小数部分占52位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;扩展精度&lt;/td&gt;
&lt;td&gt;80位：符号占1位，指数占16位，尾数中的小数部分占63位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以单精度为例，在内存中的储存格式如下（左边为高位）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	| 1位符号 | 8位指数 | 23位尾数 |
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中符号位1表示负数，0表示正数，这与整数形式的符号位意义相同；
科学计数法表示形式如 m * (b ^ e)，m为尾数，b为基数，e是指数，再二进制中，基数毫无疑问是2，对单精度，指数为中间8位二进制表示的数字，其中的尾数是形如1.1101 小数点后面的整数值。&lt;/p&gt;
&lt;p&gt;关于指数，由于需要表示正负两种数据，IEEE标准规定单精度指数以127为分割线，实际存储的数据是指数加127所得结果，127为高位为零，后7位为1所得，其他双精度也以此方式计算。&lt;/p&gt;
&lt;p&gt;为了解释内存中浮点数的存储方式，举一个浮点数的例子说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float test = 123.456;

int main()
{
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例子再简单不过了，仅仅定义了一个全局的float类型，我们通过&lt;code&gt;gcc -S test.c&lt;/code&gt;来生成汇编，看看&lt;code&gt;123.456&lt;/code&gt;是如何存储的，打开反汇编后的文件，看到符号&lt;code&gt;_test&lt;/code&gt;后定义的数字是 &lt;code&gt;1123477881&lt;/code&gt; （这里gcc定义成了long类型，不过没有关系，因为都是四字节数字，具体的类型还得看如何使用）。可以使用计算器把十进制数字转化为二进制：&lt;code&gt;0 10000101 11101101110100101111001&lt;/code&gt;，这里根据单精度的划分方式把32位划分成三部分，符号位为0，为正数，指数为 133，减去127得6，尾数加上1.，形式为&lt;code&gt;1.11101101110100101111001&lt;/code&gt;，扩大2 ^ 23次方为&lt;code&gt;111101101110100101111001&lt;/code&gt;，十进制&lt;code&gt;16181625&lt;/code&gt;，后除以&lt;code&gt;2 ^ (23 – 6) = 131072&lt;/code&gt;，结果为&lt;code&gt;123.45600128173828125&lt;/code&gt;，与我们所定义的浮点数正好相符。&lt;/p&gt;
&lt;h1 id=&#34;浮点寄存器&#34;&gt;浮点寄存器&lt;/h1&gt;
&lt;p&gt;这里介绍了浮点数的二进制表示，前面说过浮点单元计算使用独立的寄存器，在寄存器那篇也稍有提及，这里详细说明一下浮点单元的寄存器设施。&lt;/p&gt;
&lt;p&gt;FPU有 8 个独立寻址的80位寄存器，名称分别为r0, r1, …, r7，他们以堆栈形式组织在一起，统称为寄存器栈，编写浮点指令时栈顶也写为st(0)，最后一个寄存器写作st(7)。&lt;/p&gt;
&lt;p&gt;FPU另有3个16位的寄存器，分别为控制寄存器、状态寄存器、标记寄存器，现一一详细说明此三个寄存器的作用：&lt;/p&gt;
&lt;p&gt;状态寄存器，为用户记录浮点计算过程中的状态，其中各位的含义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 —— 非法操作异常
1 —— 非规格化操作数异常
2 —— 除数为0异常
3 —— 溢出标志异常
4 —— 下溢标志异常
5 —— 精度异常标志
6 —— 堆栈错误
7 —— 错误汇总状态
8 —— 条件代码位0（c0）
9 —— 条件代码位1（c1）
10 —— 条件代码位2 （c2）
11-13 —— 堆栈顶指针
14 —— 条件代码位3（c3）
15 —— 繁忙标志
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中读取状态寄存器内容可使用 fstsw %ax&lt;/p&gt;
&lt;p&gt;控制寄存器的位含义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 —— 非法操作异常掩码 
1 —— 非法格式化异常掩码 
2 —— 除数为0异常掩码 
3 —— 溢出异常掩码 
4 —— 下溢异常掩码 
5 —— 精度异常亚曼 
6-7 —— 保留 
8-9 —— 精度控制（00单精度，01未使用，10双精度，11扩展精度） 
10-11 —— 舍入控制（00舍入到最近，01向下舍入，10向上舍入，11向0舍入） 
12 —— 无穷大控制 
13–15 —— 保留
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中读取控制寄存器和设置控制寄存器的指令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 加载到内存
fstcw control
# 加载到控制器
fldcw control
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的标志寄存器最为简单，分别0-15位分别标志r0-r7共8个寄存器，每个寄存器占2位，这两位的含义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;11 —— 合法扩展精度 
01 —— 零 
10 —— 特殊浮点 
11 —— 无内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外对浮点寄存器的一些控制指令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 初始化fpu，控制、状态设为默认值，但不改变fpu的数据
finit

# 恢复保存环境
fldenv buffer
fstenv buffer

#清空浮点异常
fnclex

#fpu状态保存
fssave
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fstenv 保存控制寄存器、状态寄存器、标记寄存器、FPU指令指针偏移量、FPU数据指针，FPU最后执行的操作码到内存中。&lt;/p&gt;
&lt;h1 id=&#34;浮点数指令&#34;&gt;浮点数指令&lt;/h1&gt;
&lt;p&gt;接下来将要详细说明其计算过程，要计算数据首先得看如何从内存中加载数据到寄存器，同时把结果从寄存器取出到内存，除了加载内存中的浮点数据指令，另外还有一些常量的加载，现列举如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;finit&lt;/td&gt;
&lt;td&gt;初始化控制和状态寄存器，不改变fpu数据寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstcw control&lt;/td&gt;
&lt;td&gt;将控制寄存器内容放到内存control处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstsw status&lt;/td&gt;
&lt;td&gt;将状态寄存器内容放到内存status处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;flds value&lt;/td&gt;
&lt;td&gt;加载内存中的单精浮点到fpu寄存器堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldl value&lt;/td&gt;
&lt;td&gt;加载内存中的双精浮点到fpu寄存器堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldt value&lt;/td&gt;
&lt;td&gt;加载内存中的扩展精度点到fpu寄存器堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fld %st(i)&lt;/td&gt;
&lt;td&gt;将%st(i)寄存器数据压入fpu寄存器堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fsts value&lt;/td&gt;
&lt;td&gt;单精度数据保存到value，不出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstl value&lt;/td&gt;
&lt;td&gt;双精度数据保存到value，不出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstt value&lt;/td&gt;
&lt;td&gt;扩展精度数据保存到value，不出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstps value&lt;/td&gt;
&lt;td&gt;单精度数据保存到value，出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstpl value&lt;/td&gt;
&lt;td&gt;双精度数据保存到value，出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstpt value&lt;/td&gt;
&lt;td&gt;扩展精度数据保存到value，出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fxch %st(i)&lt;/td&gt;
&lt;td&gt;交换%st(0)和%st(i)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fld1&lt;/td&gt;
&lt;td&gt;把 +1.0 压入 FPU 堆栈中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldl2t&lt;/td&gt;
&lt;td&gt;把 10 的对数(底数2)压入 FPU 堆栈中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldl2e&lt;/td&gt;
&lt;td&gt;把 e 的对数(底数2)压入 FPU 堆栈中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldpi&lt;/td&gt;
&lt;td&gt;把 pi 的值压入 FPU 堆栈中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldlg2&lt;/td&gt;
&lt;td&gt;把 2 的对数(底数10)压入 FPU 堆栈中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldln2&lt;/td&gt;
&lt;td&gt;把 2 的对数(底数e) 压入堆栈中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fldz&lt;/td&gt;
&lt;td&gt;把 +0.0 压入压入堆栈中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上指令虽多，但是还是很有规律，前缀f表示fpu操作，ld加载，st保存设置，p后缀弹出堆栈，s、l、t后缀表示单精度，双精度，扩展精度，c后缀表 示控制寄存器，s后缀表示状态寄存器。当然这仅仅是对AT&amp;amp;T语法而言，对MASM语法没有s，l，t之分，需要使用type ptr来指明精度，即内存大小。&lt;/p&gt;
&lt;p&gt;学会灵活的加载弹出数据堆栈后，接下来就要看一些基本的计算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fadd 	浮点加法
fdiv 	浮点除法
fdivr 	反向浮点除法
fmul 	浮点乘法
fsub 	浮点减法
fsubr 	反向浮点减法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于以上的每种指令，有几种指令格式，以fadd为例，列举如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 内从中的32位或者64位值和%st(0)相加
fadd source

# 把%st(x)和%st(0)相加，结果存入%st(0)
fadd %st(x), %st(0)

# 把%st(0)和%st(x)相加，结果存入%st(x)
fadd %st(0), %st(x)

# 把%st(0)和%st(x)相加，结果存入%st(x)，弹出%st(0)
faddp %st(0), %st(x)

# 把%st(0)和%st(1)相加，结果存入%st(1)，弹出%st(0)
faddp

# 把16位或32位整数与%st(0)相加，结果存入%st(0)
fiadd source
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这仅仅是对AT&amp;amp;T语法而言，对MASM源操作数与目的操作数相反！另外，对AT&amp;amp;T，与内存相关指令可加s、l指定内存精度。其中反向加法和反向除法是计算过程中目的与源反向计算。&lt;/p&gt;
&lt;h1 id=&#34;浮点计算例子&#34;&gt;浮点计算例子&lt;/h1&gt;
&lt;p&gt;接下来举一个AT&amp;amp;T语法的例子，来计算表达式的值 ( 12.34 * 13 ) + 334.75 ) / 17.8 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ( 12.34 * 13 ) + 334.75 ) / 17.8
.section .data
	values: .float 12.34, 13, 334.75, 17.8
	result: .double 0.0

	outstring: .asciz &amp;quot;result is %f\n&amp;quot;
.section .text
.globl _main
_main:
	leal values, %ebx
	flds 12(%ebx)
	flds 8(%ebx)
	flds 4(%ebx)
	flds (%ebx)

	fmulp
	faddp
	fdivp %st(0), %st(1)

	fstl result

	leal result, %ebx
	pushl 4(%ebx)
	pushl (%ebx)
	pushl $outstring
	call _printf
end:
	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前四个flds加载所有的数据到寄存器堆栈，可以单步运行并是用gdb的print $st0打印堆栈寄存器的值，可以看到为什么是堆栈寄存器。需要说明的是由于printf的%f是double类型的输出，所以最后要把一个8字节浮点放 到栈中传递，最终结果为27.818541，可以看到与计算器计算的结果近似相等。&lt;/p&gt;
&lt;h1 id=&#34;浮点高级运算&#34;&gt;浮点高级运算&lt;/h1&gt;
&lt;p&gt;除了基本的浮点计算，x87还提供了一些诸如余弦运算等高级计算功能：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f2xm1&lt;/td&gt;
&lt;td&gt;计算2的乘方（次数为st0中的值，减去1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fabs&lt;/td&gt;
&lt;td&gt;计算st0中的绝对值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fchs&lt;/td&gt;
&lt;td&gt;改变st0中的值的符号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcos&lt;/td&gt;
&lt;td&gt;计算st0中的值的余弦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fpatan&lt;/td&gt;
&lt;td&gt;计算st0中的值的部分反正切&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fprem&lt;/td&gt;
&lt;td&gt;计算st0中的值除以st1的值的部分余数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fprem1&lt;/td&gt;
&lt;td&gt;计算st0中的值除以st1的值的IEEE部分余弦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fptan&lt;/td&gt;
&lt;td&gt;计算st0中的值的部分正切&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;frndint&lt;/td&gt;
&lt;td&gt;把st0中的值舍入到最近的整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fscale&lt;/td&gt;
&lt;td&gt;计算st0乘以2的st1次方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fsin&lt;/td&gt;
&lt;td&gt;计算st0中的值的正弦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fsincos&lt;/td&gt;
&lt;td&gt;计算st0中的值的正弦和余弦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fsqrt&lt;/td&gt;
&lt;td&gt;计算st0中的值的平方根&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fyl2x&lt;/td&gt;
&lt;td&gt;计算st1*log st0 以2为底&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fyl2xp1&lt;/td&gt;
&lt;td&gt;计算st1*log (st0 + 1) 以2为底&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面来看一下浮点条件分支，浮点数的比较不像整数，可以容易的使用cmp指令比较，判断eflags的值，关于浮点数比较，fpu提供独立的比较机制和指令，现对这组比较指令进行说明：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;fcom&lt;/td&gt;
&lt;td&gt;比较st0和st1寄存器的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcom %st(x)&lt;/td&gt;
&lt;td&gt;比较st0和stx寄存器的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcom source&lt;/td&gt;
&lt;td&gt;比较st0和32/64位内存值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcomp&lt;/td&gt;
&lt;td&gt;比较st0和st1寄存器的值，并弹出堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcomp %st(x)&lt;/td&gt;
&lt;td&gt;比较st0和stx寄存器的值，并弹出堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcomp source&lt;/td&gt;
&lt;td&gt;比较st0和32/64位内存值，并弹出堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcompp&lt;/td&gt;
&lt;td&gt;比较st0和st1寄存器的值，并两次弹出堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ftst&lt;/td&gt;
&lt;td&gt;比较st0和0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浮点数比较的结果放入状态寄存器的c0，c2，c3条件代码位中，其值如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;c3&lt;/th&gt;
&lt;th&gt;c2&lt;/th&gt;
&lt;th&gt;c0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;st0 &amp;gt; source&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;st0 &amp;lt; source&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;st0 = source&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如此倘若直接判断c0，c2，c3的值比较繁琐，所以可以使用一些技巧，首先使用fstsw指令获得fpu状态寄存器的值并存入ax，再使用sahf指令把 ah寄存器中的值加载到eflags寄存器中，sahf指令把ah寄存器的第0、2、4、6、7分别传送至进位、奇偶、对准、零、符号位，不影响其他标 志，ah寄存器中这些位刚好包含fpu状态寄存器的条件代码值，所以通过fstsw和sahf指令组合，可以传送如下值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;把c0位传送到eflags的进位标志 
把c2位传送到eflags的奇偶校验标志 
把c3位传送到eflags的零标志
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传送完毕后，可以用条件跳转使用不同的结果值，另外需要说明的是浮点数相等判断，因为浮点数本身存储结构决定了它仅仅是一个近似值，所以不能直接判断是否相 等，这样可能与自己预期的结果不同，应该判断两个浮点数之差是否在一个很小的误差范围内，来决定这两个浮点数是否相等。&lt;/p&gt;
&lt;p&gt;根据上面的技巧，使用fstsw和fpu指令组合，可以方便的使用浮点判断结果，这对我们是一种便利，而intel的工程师又为我们设计了一个组合指令，fcomi指令执行浮点比较结果并把结果存放到eflags寄存器的进位，奇偶，和零标志。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;fcomi&lt;/td&gt;
&lt;td&gt;比较st0和stx寄存器的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcomip&lt;/td&gt;
&lt;td&gt;比较st0和stx寄存器，并弹出堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fucomi&lt;/td&gt;
&lt;td&gt;比较之前检查无序值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fucomip&lt;/td&gt;
&lt;td&gt;比较之前检查无序值，之后弹出堆栈&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;判断结束后eflags的标志设置如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;ZF&lt;/th&gt;
&lt;th&gt;PF&lt;/th&gt;
&lt;th&gt;CF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;st0 &amp;gt; st(x)&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;st0 &amp;lt; st(x)&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;st0 = st(x)&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;cmov移动指令&#34;&gt;CMOV移动指令&lt;/h1&gt;
&lt;p&gt;最后介绍的是类似cmov的指令，根据判断结果决定是否需要移动数据，其AT&amp;amp;T格式为 fcmovxx source, destination，其中source是st(x)寄存器，destination是st(0)寄存器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;fcmovb&lt;/td&gt;
&lt;td&gt;如果st(0)小于st(x)，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcmove&lt;/td&gt;
&lt;td&gt;如果st(0)等于st(x)，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcmovbe&lt;/td&gt;
&lt;td&gt;如果st(0)小于或等于st(x)，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcmovu&lt;/td&gt;
&lt;td&gt;如果st(0)无序，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcmovnb&lt;/td&gt;
&lt;td&gt;如果st(0)不小于st(x)，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcmovne&lt;/td&gt;
&lt;td&gt;如果st(0)不等于st(x)，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcmovnbe&lt;/td&gt;
&lt;td&gt;如果st(0)不小于或等于st(x)，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fcmovnu&lt;/td&gt;
&lt;td&gt;如果st(0)非无序，则进行传送&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上可以看出，无论从寄存器的操作，还是计算过程，都比整数运算要繁琐的多，而且看似很简单的一个表达式，转化成浮点汇编需要做很多工作，由于其复杂性，同 一个表达式可以有多种运算过程，当然其中的效率相差很大，这依赖于对浮点汇编的理解程度，好在有高级语言处理相关工作，编写浮点指令的情况比较少见。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十一)-预编译宏</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.-assembler-precompile-macro/</link>
        <pubDate>Tue, 22 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.-assembler-precompile-macro/</guid>
        <description>&lt;p&gt;在c语言中，宏作为一种预编译手段，可以在编译之前进行替换，汇编中的宏只是语法与c有所差别，在语言中所起到的作用非常相近。&lt;/p&gt;
&lt;p&gt;先来看MASM中宏的语法规范：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;macroname macro parameter1, parameter2, ...
	statement-list
endm

; 调用
macroname parameter1, parameter2, ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看上去跟结构体的声明差不多，只是endm时不需要宏名，这里的参数是在调用点传递，预处理器只做替换，与c的宏有相同的含义，不过这里调用点的参数个数可以不与宏定义的参数个数相同，如果调用点个数多余定义，汇编器会产生一个警告，如果少于，则未传递的参数为空。&lt;/p&gt;
&lt;p&gt;接下来举一个简单的例子进行说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.386
.model flat,stdcall
option casemap:none

include		windows.inc
include		kernel32.inc
includelib	kernel32.lib
includelib	msvcrt.lib

.data
outstring	db &amp;quot;result is %d&amp;quot;, 0ah, 0dh, 0
result dd 0

.code
printf proto c s:dword, i:dword

addTwo macro a, b, result
	mov eax, a
	add eax, b
	mov result, eax
endm

start:
	addTwo 12, 14, result
	invoke printf, addr outstring, result
	addTwo result, 14, result
	invoke printf, addr outstring, result
    invoke ExitProcess, NULL
end start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过反汇编此程序，可以看到宏被扩展了两份，与函数调用不同。&lt;/p&gt;
&lt;p&gt;masm中宏的使用还有其他一些特性，对于参数，有时必须要调用者指定，可以在参数后加:req，由此后缀的参数必须传递。比如上例中的a，可以写做 a:req。
另外如果需要宏在汇编时输出信息，可使用echo伪指令，比如在addTwo宏内任意一行添加echo test data，则在编译时会输出两句test data.&lt;/p&gt;
&lt;p&gt;接下来介绍MASM的条件汇编伪指令，类似于c语言的#if-#else-#endif条件编译宏。&lt;/p&gt;
&lt;p&gt;先来看条件汇编伪指令的一般格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition
	statements
[else
	statements]
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，其用法与c基本相同，唯一需要说明一下的是condition的使用，因为次伪指令是在编译期间决定是否需要编译，所以条件表达式必须为常量，能够在编译期间识别，另外可使用一些关系运算符进行比较：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LT 	小于
GT 	大于
EQ 	等于
NE 	不等于
LE 	小于等于
GE 	大于等于
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if宏还有几种变型，现列举如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;伪指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ifb &amp;lt; param &amp;gt;&lt;/td&gt;
&lt;td&gt;如果参数为空则允许汇编，参数名必须用&amp;lt;&amp;gt;括起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifnb &amp;lt; param &amp;gt;&lt;/td&gt;
&lt;td&gt;如果参数不为空则允许汇编，参数名必须用&amp;lt;&amp;gt;括起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifidn &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
&lt;td&gt;如果两个参数相同则允许汇编，区分大小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifidni &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
&lt;td&gt;如果两个参数相同则允许汇编，不分区大小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifdif &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
&lt;td&gt;如果两个参数不同则允许汇编，区分大小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifdifi &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
&lt;td&gt;如果两个参数不同则允许汇编，不分区大小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifdef name&lt;/td&gt;
&lt;td&gt;如果名字定义则允许汇编&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifndef name&lt;/td&gt;
&lt;td&gt;如果名字没有定义则允许汇编&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MASM的重复定义块：
MASM中有些用于生成重复定义块的循环伪指令，while, repeat, for 和 forc，这些伪指令可在汇编期间生成代码，一般定义格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while constExpression
	statements
endm

repeat constExpression
	statements
endm

; 第一次循环时，参数取值为arg1
; 第二次循环时，参数取值为arg2
; 如此反复值最后一个取值
for parameter, 
	statements
endm

; 与for类似，第一次循环parameter取string的第一个字母
; 依次取遍所有字符，注意&amp;lt;&amp;gt;这两个字符前需加!标识
forc parameter, 
	statements
endm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的语法还是比较清楚，先略去实例的说明。&lt;/p&gt;
&lt;p&gt;以上是MASM语法中的宏，在AT&amp;amp;T语法中，也有类似机制，现对几个常用的宏进行说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.macro
与MASM的macro类似，只是前面需要加点，语法规则如下：

.macro macro_name param[=value], ...
	statements
.endm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里param可以赋默认值，宏中使用参数时需要使用\，\param引用参数param。举一个与MASM宏相同的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
	result: .int 0
	outstring: .asciz &amp;quot;result is %d\n&amp;quot;

.section .text

.macro addTwo a, b, result
	mov \a, %eax
	add \b, %eax
	mov %eax, \result
.endm

.globl _main
_main:
	addTwo $12, $13, result
	pushl result
	pushl $outstring
	call _printf

	addTwo $123, $456, result
	pushl result
	pushl $outstring
	call _printf

	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外还有.if宏，其用法与MASM和c相同，这里仅仅做一个简单的列举：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.ifdef symbol&lt;/td&gt;
&lt;td&gt;symbol 定义则编译&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.ifeq expression&lt;/td&gt;
&lt;td&gt;如果表达式为0则编译&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.ifndef symbol&lt;/td&gt;
&lt;td&gt;如果符号未定义则编译&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.endif&lt;/td&gt;
&lt;td&gt;结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.else&lt;/td&gt;
&lt;td&gt;同MASM&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当然，选择编译宏的种类十分丰富，这里只是列举常用宏，全部信息可由as使用手册获得。&lt;/p&gt;
&lt;p&gt;最后还需要说明一下AT&amp;amp;T的.fill宏，这个宏在编译期间填充字符，可以用来控制可执行文件的大小，语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.fill repeat, size, value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里暂且不举例，如果有机会说明一下系统引导程序编程，再说明这个指令吧。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十)-内联汇编</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.-assembler-c-inline/</link>
        <pubDate>Mon, 21 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.-assembler-c-inline/</guid>
        <description>&lt;p&gt;这篇介绍一下c内联汇编的使用，准确的说，内联汇编不算是汇编的语法，而是c/c++的语法，虽然c/c++是有标准参考的，但是不同编译器使用的 汇编不同，导致内联汇编是编译器相关的。这里介绍vc和gcc下c的内联汇编使用，vc使用masm语法，gcc自然是AT&amp;amp;T语法。&lt;/p&gt;
&lt;h1 id=&#34;语法规则&#34;&gt;语法规则&lt;/h1&gt;
&lt;p&gt;一般来讲，MASM的语法规则较多，也比较复杂，不过内联汇编却相当的方便，相反，AT&amp;amp;T的内联汇编语法规非常复杂，这里先介绍简单的MASM内联。&lt;/p&gt;
&lt;p&gt;vc环境下内联汇编语法规则如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__asm statement
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__asm {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	statement-1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	statement-2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	statement-n
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的指令即MASM程序，但是有一些限制如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能使用数据定义伪指令&lt;/li&gt;
&lt;li&gt;不能定义结构等复杂数据类型&lt;/li&gt;
&lt;li&gt;不能使用宏，或宏操作符&lt;/li&gt;
&lt;li&gt;不能引用段名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然这里只是简单的介绍一下，其中的细节只能在实践中体会了，接下来举一个简单的例子来说明内联汇编的使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/** 计算两个参数的积 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;testAssembler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kr&#34;&gt;__asm&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mul&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;testAssembler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kr&#34;&gt;__asm&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;result is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里 testAssembler 函数中使用内联汇编计算了参数的积，调用点并未接受其返回值，因为函数返回值是由eax寄存器返回，则再次使用内联汇编可以取到返回值。&lt;/p&gt;
&lt;p&gt;可以看到MASM内联汇编是十分简单的，接下来看gcc的内联语法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;asm (
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	语句模板
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	: 输出部分
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	: 输入部分
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	: 破坏描述
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;先来说语句模板，这里的语句即为AT&amp;amp;T的基本语法，与MASM不同的是这里不能直接使用局部变量，倒是可以引用全局变量，指 令之间使用&lt;code&gt;;&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\n\t&lt;/code&gt; 分割，后面的部分是可选的，如果只介绍到这里，可如vc一样的方式去使用内联，不过这便损失了gcc更为强大的功能。&lt;/p&gt;
&lt;p&gt;在指令部分除了使用 AT&amp;amp;T标准语法之外，还可以有最多10个占位符：&lt;code&gt;%0&lt;/code&gt;, &lt;code&gt;%1&lt;/code&gt;, &lt;code&gt;…&lt;/code&gt; , &lt;code&gt;%9&lt;/code&gt;，他们出现的次序与操作数相对应，另外，可在%和数字之间插入字符w, h, b分别表示访问操作数中的低字，低字中的高字节和低字中的低字节。这里可能说的比较糊涂，不过没关系，介绍之后的部分自然会明白。&lt;/p&gt;
&lt;p&gt;输出部分指示此内嵌汇编输出结果保存到什么变量中，这些变量通过占位符作为汇编语句中的操作数。当输出列表多于一个变量时，变量之间用逗号隔开，这些变量之间的修饰字符串中必须包含’=&amp;rsquo;，来表示它是一个输出操作数，修饰字符稍微会做详细说明。&lt;/p&gt;
&lt;p&gt;输入部分看名字就知道是做输入之用，语法格式也与输出部分相同，唯一缺少的就是那个修饰的符号&lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;修饰符&#34;&gt;修饰符&lt;/h1&gt;
&lt;p&gt;到这里详细说一下修饰字符，修饰字符很多，这里仅仅介绍常用修饰符。&lt;/p&gt;
&lt;h2 id=&#34;寄存器绑定这类修饰符修饰的变量跟某中寄存器绑定随后的操作中可直接操作相应的寄存器&#34;&gt;寄存器绑定：这类修饰符修饰的变量跟某中寄存器绑定，随后的操作中，可直接操作相应的寄存器。&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;绑定寄存器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;%eax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;%ebx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;%ecx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;%edx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;%esi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;%edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;eax, ebx, ecx, edx 任意一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;eax, ebx, ecx, edx, esi, edi 任意一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;被修饰是64位变量，要与%eax,%edx联合绑定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;不绑定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另外，如果该寄存器已经被绑定，编译器会在合适的地方push到堆栈，使用之后再回复此寄存器。&lt;/p&gt;
&lt;h2 id=&#34;输出变量修饰&#34;&gt;输出变量修饰&lt;/h2&gt;
&lt;p&gt;除了以上修饰符，还有一些只用于修饰输出变量，简单介绍如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;‘&amp;amp;’&lt;/td&gt;
&lt;td&gt;输出变量不能和输入变量共用同一个寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘=’&lt;/td&gt;
&lt;td&gt;输出变量只写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘+’&lt;/td&gt;
&lt;td&gt;先将输出变量预先读入到对应寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;gcc 内联汇编规范最后一个部分是破坏描述，不论做什么操作，基本都需要寄存器的参与，对于只有c代码的程序，编译器保护寄存器不会被不同模块写乱，但是对于内 联汇编，我们可能修改某些寄存器而破坏了gcc原本保护的寄存器，所以内联汇编时我们需要告诉编译器哪些寄存器使我们所需要改变的，这里破坏描述符由逗号 隔开的字符串组成，每个字符串描述一种情况，一般是寄存器名，另外还有”memory”-内存破坏描述符，内存描述符为了将寄存器保存的变量内容及时写回 到内存中去，避免在寄存器中存有多份不同拷贝，与c++关键字volatile类似。&lt;/p&gt;
&lt;p&gt;到这里简要介绍了gcc内联汇编的部分语法，接下来举例说明此用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;asm&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;volatile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;	&lt;span class=&#34;s2&#34;&gt;&amp;#34;movl %1, %0&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n\t&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;					&lt;span class=&#34;s2&#34;&gt;&amp;#34;addl %2, %0&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n\t&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;+a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;result is &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，在语句模板部分出现了占位符，其中 0,1,2 根据变量出现的次数依次为sum, var1, var2，所以，movl %1, %0 表示把var1存入sum，addl %2, %0表示把var2与sum相加结果存入sum，后面描述部分都比较简单，因为addl语句的关系，需要对%0先读其值后计算，所以需要使用描述 符”+”。&lt;/p&gt;
&lt;p&gt;当然，内联汇编只是汇编跟c结合的一种方式，还有一种就是直接把汇编编译成目标文件，再跟c直接链接到一起，这里并没有什么新的东西，仅仅写一个AT&amp;amp;T汇编的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#file Assembler.s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.globl _mulTwo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;_mulTwo:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %esp, %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl 8(%ebp), %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mull 12(%ebp)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %ebp, %esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	popl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ret
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里汇编仅仅实现一个函数，并通过.globl导出符号，这里加下划线的原因是因为Windows的符号规则，之前已有说明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* file testAssembler.c*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/** 由于c必须声明，这里仅仅对汇编函数做一个c声明 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mulTwo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mulTwo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;测试的c代码只需要定义一个汇编的函数声明即可使用。编译命令可以分别编译成目标文件再链接，也可直接使用 gcc testAssembler.c Assembler.s 编译之，对于反过来回调，汇编代码调用c代码，因为之前在汇编结尾已多次使用exit函数，这里便不再举例，同时，MASM语法的原理也相同，仅换了一套 编译命令而已。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(九)-函数</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.-assembler-function/</link>
        <pubDate>Sun, 20 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.-assembler-function/</guid>
        <description>&lt;p&gt;编程语言为了不至于使代码过于庞大，便于管理，都提供了函数的功能，提供输入和输出接口，完成独立的功能，细分代码。汇编语言同样也有函数的概念， 但是这里函数有其本身的复杂性，像高级语言，直接提供声明格式，输入输出便可，而汇编需要透彻的理解堆栈，如果需要与c函数进行交互，还需理解c的堆栈处 理过程，所以此篇最复杂的不是定义一个函数，而是理解堆栈的处理过程。&lt;/p&gt;
&lt;p&gt;首先从基本的函数语法形式说起，先来说MASM语法，因为他的语法比较复杂，相对AT&amp;amp;T就很简单了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name proc [uses reg1 reg2 ...] [,参数:类型]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里函数定义比较简单，唯一有点迷惑的是uses伪指令，因为函数需要做很多操作，这样不免修改某些寄存器，uses伪指令指定该函数 要修改的寄存器，由编译器对其做保护，当然，此项是可选的，不规定一定要把修改的寄存器保护起来。编译器保护寄存器的方式就是在函数开始把reg通过 push指令保存到堆栈，退出时再通过pop反向的取出寄存器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	test_uses proc uses eax ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 编译器再此添加
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; push eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; push ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 编译器再此添加
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; pop ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; pop eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	test_uses endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数声明倒不复杂，先来看参数的传递，传递参数最简单的情况就是通过寄存器，调用点把数据放至寄存器中，到函数中便可直接使用，但寄存 器毕竟数量有限，更为通用的方式就是通过堆栈传输，再调用点先把参数依次传入堆栈（push 指令），函数中便可从堆栈中读取参数，对c函数来讲，参数的入栈顺序是倒序的，也就是最后一个参数先入栈，依次向前。&lt;/p&gt;
&lt;p&gt;调用点调用函数需要指 令：call address，call指令先把接下来要执行的指令（EIP）放入堆栈，紧接着修改EIP的值为address，这样就到address的位置开始执 行，即函数入口。因为函数结束时需要跳转到刚才存入堆栈的EIP地址执行，所以必须有一个指令与call对应，修改EIP的值，那就是ret指令，ret 指令从堆栈中取出返回地址，然后修改EIP为该地址，便可回到调用函数的地址开始往下执行。&lt;/p&gt;
&lt;p&gt;所以，再调用点现在可以写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	push param
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	call function
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，MASM提供了一个方便的指令invoke，语法规则为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	invoke procName, Arg1, Arg2 ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可把函数调用过程简化为 invoke function param，invoke可以让调用汇编像调用c函数一样简单，不过如果需要invoke调用则需先声明，当然如果函数在使用之前定义，则可不进行声明， 这与C语言的语法颇为相似，MASM提供了另一个伪指令proto来声明函数，无需函数体，仅仅规定函数格式，proto语法与proc大致相同，修改 proc到proto也很简单，只需要proc改为proto，去掉uses伪指令，去掉函数体。&lt;/p&gt;
&lt;p&gt;函数的返回值可以以任意方式返回，不过c函数一般是通过eax寄存器返回，如果调用c函数，可直接使用eax得到返回值。&lt;/p&gt;
&lt;p&gt;到这里似乎有了很多的堆栈操作，比如保护寄存器，返回地址，参数，还有局部变量，这里问题是不会发生堆栈的错乱么？这还要通过堆栈的变化来看。&lt;/p&gt;
&lt;p&gt;首先堆栈是从大到小增长的，也就是后push进去的元素在小地址。需要传递参数时，先用push指令把参数入栈，然后用call进行跳转，call指令再把 返回地址入栈，接下来的空间作为局部变量的地址，也就是说以返回地址为分割，小地址方向为局部变量，大地址方向存储参数。但是如果函数中再次调用其他函数 会修改堆栈，这样影响了局部变量的空间，所以再进入函数时，需要把esp减去一定字节数以腾出空间作为局部变量，但是esp本身是随着push指令而变化 的，不能使用esp来寻址参数或者局部变量，一般做法是在函数开始处保存ebp的值，再把esp赋值给ebp作为固定的基址寻址参数，esp减去一定空间 作为局部变量。再函数退出时只需把ebp赋值给esp即可清理一切局部堆栈信息。所以基本的函数框架如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name proc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		push ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ebp, esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		sub esp, 16
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov esp, ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pop ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此，在读取第一个参数时使用语法 [ebp + 8], 第二个参数便是 [ebp + 12]，依次类推，第一个局部变量便是 [ebp - 4], 第二个是 [ebp - 8] 等等。当然这只是规律但不是规定，如果使用uses伪指令再函数开始处增加push指令而改变堆栈，如此的规律便不再适用。&lt;/p&gt;
&lt;p&gt;为了方便理解，这里用一图示来展现函数堆栈的分布，当然这一图示是静态的，难以表示整个函数调用过程中动态增衰的过程，还需更多的思考：&lt;/p&gt;
&lt;p&gt;由图可以清楚的看到堆栈状态，这样我们甚至可以直接修改返回地址为另外一个函数，来改变整个调用的流程！甚至这个过程可以用c语言指针操作来完成，有兴趣的可以一试。&lt;/p&gt;
&lt;p&gt;MASM为了方便参数的读取（不必计算偏移）而制定了参数列表，为了方便局部变量的读取而指令了local指令，语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uses&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reg1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reg2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此，在程序中便可直接使用var来直接引用byte局部变量。&lt;/p&gt;
&lt;p&gt;另外由于函数的开始和结尾都是定式，intel又提供了两个指令来简化操作，enter指令，有两个操作数，第一个位局部变量大小，第二个暂时填写0即可，leave指令无操作数，上面函数框架也可写作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name proc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		enter 16, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 等价于以下三条指令
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; push ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; mov ebp, esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; sub esp, 16
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		leave
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 等价于一下两条指令
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; mov esp, ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; pop ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上都是MASM语法形式，当然，大多数的原理性东西也对AT&amp;amp;T语法适用，MASM提供了很多宏去方便程序员适用，从函数调用的invoke伪指令，到参数列表，到局部变量，都做了全副武装。这在AT&amp;amp;T中就没那么幸运了。&lt;/p&gt;
&lt;p&gt;对AT&amp;amp;T汇编来说，函数仅仅是一个符号，跟其他label并没什么不同。定义的语法规则如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.type func_name, @function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	func_name:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里仅仅是对linux适用，如果在mingw下写，发现这样甚至连编译都过不了，其实只要有一个符号即可，.type完全可以不写， 如果要导出函数，可用.globl func_name。另外，AT&amp;amp;T的函数需要自己计算参数的偏移，没有参数列表没有局部声明，也没有invoke调用。这么简陋的设施或许也没 什么可以说明的。&lt;/p&gt;
&lt;p&gt;如果仔细研究堆栈变化，在调用函数的时候先要把参数入栈，然后把返回地址入栈，之后跳到函数入口点执行。这样就产生一个问题，谁应该把压入的参数弹出（即清理堆栈）。&lt;/p&gt;
&lt;p&gt;对于__cdecl函数（c函数）是调用者进行清理，gcc的处理方式是在局部变量的最后多开辟一点空间，然后每次调用函数之前，先把参数赋值给esp的正偏移，这样等函数返回之后就没有必要清理堆栈了。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;__stdcall&lt;/code&gt;函数（Win32 API），清理堆栈的工作需要交给被调用者，也就是说，所有&lt;code&gt;__stdcall&lt;/code&gt;的函数在返回之前使用 ret (n-bype) 清理了参数，如果返回之后再次清理堆栈就会造成堆栈的混乱。&lt;/p&gt;
&lt;p&gt;这里由函数本身清理堆栈时，还用到一个ret指令的变形，可以增加一个操作数来指定堆栈清理的字节数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; MASM
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ret bytes;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; AT&amp;amp;T
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	retn bytes;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，举一个例子简单的说明一下函数的用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		out: .asciz &amp;#34;result is %d\n&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	# 这里定义一个两数相加的例子
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	# 为了说明，先存结果到局部变量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _Function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_Function:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %esp, %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		subl $16, %esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl 8(%ebp), %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		addl 12(%ebp), %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		#存入局部变量位置偏移为 -4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %ebx, -4(%ebp)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl -4(%ebp), %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %ebp, %esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		popl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_main:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $5
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $9
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _Function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		#结果位于eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		#调用printf输出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $out
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _printf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _exit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里需要注意的是，_Function这个函数符合c编程的规范，也就是说c语言也可直接调用此函数，这种方式再下篇会有提及。对于 MASM，也适用这种写法，不过为了介绍简化过程的伪指令，现把此程序改为由伪指令简化过的形式，注意（enter虽然简化过程，但是intel的指令， 不算伪指令）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;386&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stdcall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;casemap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;none&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;windows&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;kernel32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;includelib&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;includelib&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msvcrt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;outstring&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;result is &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ebx&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outstring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;n&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ExitProcess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里需要做几点说明，由于.model设定了stdcall，所以proc指定的都会是stdcall函数，即堆栈清理由函数自己执 行，所以Function最终使用ret 8来返回。另外，由于指定了函数Function的参数，编译器会自动生成框架，所以无需使用enter和leave，对于printf，没有使用头文 件，而是自己进行了生命，当然，这里并没有使用可变长参数，仅仅写了两个参数，proto后加了函数的类型为c类型。另外，连接期间无需连接成 windows类型，可用命令&lt;code&gt;link /subsystem:console fun.obj&lt;/code&gt; 来连接成控制台程序。&lt;/p&gt;
&lt;p&gt;本篇主要介绍了函数堆栈变化，这个过程虽然并不复杂，但是要是讲解清晰还是非常困难。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(八)-字符串</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.-assembler-string-instruct/</link>
        <pubDate>Sat, 19 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.-assembler-string-instruct/</guid>
        <description>&lt;p&gt;字符串处理可能是编程语言中最耗时以及最繁琐的操作，比较一个整数只需要比较32位，但是比较字符串却需要循环比较字符串的每一个字符，相关的复制 追加操作则需要很多的内存拷贝操作，可能各种语言都对应有一系列的字串处理库，对汇编来说，当然没有类似的库可用，但是Intel提供了一系列字串处理相 关的指令，可以相对方便的处理字符串。&lt;/p&gt;
&lt;p&gt;先来看几个简单的拷贝操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	;AT&amp;amp;T 语法格式
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movsb 传递一个字节
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movsw 传递两个字节
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movsl 传递四个字节
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为这组操作没有操作数，所以MASM语法相同，但是movsl不同，l在AT&amp;amp;T语言中表示long，是4字节，但是在MASM中，4字节是dword，所以最后一个指令被写做 movsd&lt;/p&gt;
&lt;p&gt;虽说这里movsb没有操作数，但是没有操作数如何拷贝字符？其实这有关字串处理的操作，有两个操作数，源字符串和目标字符串，这里的操作数是隐含操作数，记得寄存器那篇说过，esi为源操作数，edi为目标操作数，所体现的就是这里了。&lt;/p&gt;
&lt;p&gt;另外一个问题是，如果仅仅移动一个字符，mov指令完全可以胜任，那还要movsb干什么呢？的确如此，movsb本身来讲并不见得方便，但是结合一个指令前缀rep，就不同了。&lt;/p&gt;
&lt;p&gt;rep是一个指令前缀，就是再其他指令之前表示一种特性，rep为repeat，重复之意，就是他可以不停的执行，直到ecx为0，与之相关的还有两个指令，一起总结如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rep&lt;/td&gt;
&lt;td&gt;ecx &amp;gt; 0时重复&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repz/repe&lt;/td&gt;
&lt;td&gt;零标志置位 并且 ecx &amp;gt; 0时重复&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repnz/repne&lt;/td&gt;
&lt;td&gt;零标志为清零 并且 ecx &amp;gt; 0时重复&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果还记得loop和loopz指令，应该熟悉汇编中的这种后缀规律。&lt;/p&gt;
&lt;p&gt;如果movsb能够重复执行，那另外一个问题就出来了，重复复制一个字节有什么意思呢？其实movsb指令不单复制，同时还修改esi和edi的值。至于如何修改，是加还是减，需要看DF标志，方向标识。当DF清零，则esi和edi递增；反之递减。&lt;/p&gt;
&lt;p&gt;为了方便操作DF标志，Intel还专门提供了两个清零和置位的指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cld 	DF 清零 	esi 和 edi 递增
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std 	DF 置位 	esi 和 edi 递减
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与这两个指令相类似的还有cli, sti来控制中断标志，clc, stc控制CF标志，其中的规律一看便知。&lt;/p&gt;
&lt;p&gt;回头来看字串的复制步骤，先填充源目的寄存器，再用cld/std设置方向，之后设置ecx控制循环次数，再rep movsb即可。
现举一个memcpy函数的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	char src[100] = &amp;#34;test data&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	char dest[100];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		memcpy(dest, src, 100);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对应的MASM语法格式的汇编如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	src	db &amp;#34;test data&amp;#34;, 91 dup(0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dest db 100 dup(0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cld
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov esi, offset src
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov edi, offset dest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, 100
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		rep movsb
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里代码很少，操作也非常明了，对于AT&amp;amp;T语法，这里就不单写一个了，不过，从原理上讲，不管是AT&amp;amp;T还是 MASM语法，最终都得编译成intel cpu可以识别的机器码，所以我们把这段MASM写成的程序用AT&amp;amp;T语法的反汇编器反汇编即可得到AT&amp;amp;T的写法，Ollydbg 2.0 可以反汇编程序到多种汇编语法，不过我感觉翻译AT&amp;amp;T翻译的不大好看，还是使用gcc套件里的工具吧，这个工具是objdump，参数-D 为反汇编参数，直接使用命令行 objdump -D strcpy.exe 即可输出AT&amp;amp;T语法的汇编，这里简单摘要一些：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401000:       fc                      cld
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401001:       be 00 30 40 00          mov    $0x403000,%esi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401006:       bf 64 30 40 00          mov    $0x403064,%edi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	40100b:       b9 64 00 00 00          mov    $0x64,%ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401010:       f3 a4                   rep movsb %ds:(%esi),%es:(%edi)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401012:       6a 00                   push   $0x0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401014:       e8 01 00 00 00          call   0x40101a
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中大致流程还是看的很清楚的。&lt;/p&gt;
&lt;p&gt;介绍了这么多，仅仅只介绍了一个字符拷贝命令movsb，其他的一些诸如比较、加载的指令，但是其他指令与movsb类似，没有什么难点，这里仅仅做一些列举：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;源操作数&lt;/th&gt;
&lt;th&gt;目的操作数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;lodsb&lt;/td&gt;
&lt;td&gt;加载字节&lt;/td&gt;
&lt;td&gt;esi&lt;/td&gt;
&lt;td&gt;al&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lodsw&lt;/td&gt;
&lt;td&gt;加载双字节&lt;/td&gt;
&lt;td&gt;esi&lt;/td&gt;
&lt;td&gt;ax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lodsl(MASM lodsd)&lt;/td&gt;
&lt;td&gt;加载四字节&lt;/td&gt;
&lt;td&gt;esi&lt;/td&gt;
&lt;td&gt;eax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stosb&lt;/td&gt;
&lt;td&gt;保存字节到目的&lt;/td&gt;
&lt;td&gt;al&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stosw&lt;/td&gt;
&lt;td&gt;保存双字节到目的&lt;/td&gt;
&lt;td&gt;ax&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stosl(MASM stosd)&lt;/td&gt;
&lt;td&gt;保存四字节到目的&lt;/td&gt;
&lt;td&gt;eax&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmpsb&lt;/td&gt;
&lt;td&gt;比较字节&lt;/td&gt;
&lt;td&gt;esi&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmpsw&lt;/td&gt;
&lt;td&gt;比较双字节&lt;/td&gt;
&lt;td&gt;esi&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmpsl(MASM cmpsd)&lt;/td&gt;
&lt;td&gt;比较四字节&lt;/td&gt;
&lt;td&gt;esi&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scasb&lt;/td&gt;
&lt;td&gt;比较内存和AL&lt;/td&gt;
&lt;td&gt;al&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scasw&lt;/td&gt;
&lt;td&gt;比较内存和AX&lt;/td&gt;
&lt;td&gt;ax&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scasl(MASM scasd)&lt;/td&gt;
&lt;td&gt;比较内存和EAX&lt;/td&gt;
&lt;td&gt;eax&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里举一个简单的strlen例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;test data&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对应的MASM汇编如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	string	db &amp;#34;test data&amp;#34;, 91 dup(0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	len dd 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cld
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov edi, offset string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov al, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, 100
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		repne scasb
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		sub ecx, 100
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		neg ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		dec ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov len, ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里把al设置为0，使用scasb指令，即在edi指向的字符中查找0，找到以后ecx所减少的数字就是移动的次数，注意其中是包含0的，最后经过运算便可得到字串长度。&lt;/p&gt;
&lt;p&gt;使用此类指令操作字符串，比用c语言好的地方是不需要循环，这个再之前提到，由于预载入指令的问题，如果进行跳转（循环）将会是一件很损耗效率的事情，使用此类指令可以避免这个问题。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(七)-寻址方式</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.-assembler-addressing-method/</link>
        <pubDate>Fri, 18 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.-assembler-addressing-method/</guid>
        <description>&lt;p&gt;寻址一直以来都是汇编中的关键内容，但是在平坦内存模式下，汇编寻址的难度降低很多，不过Intel CPU必须经历段式内存模式后才可到达页式存储，所以如果系统底层编程，也可能会涉及到实模式下的程序设计，需要掌握段式寻址。&lt;/p&gt;
&lt;p&gt;对于实模式，处理器可以寻址20位的地址空间，但是寄存器只有16位，为了能达到20位的寻址，需要使用 段：偏移 这样的方式寻址，格式为 &lt;code&gt;segreg:offset&lt;/code&gt;，计算出的直接偏移地址为 &lt;code&gt;segreg * 16 + offset&lt;/code&gt;，相当于段基址左移4位后加上偏移，这样刚好有20位的地址，可以达到2M内存寻址。
在平坦内存模式下，寻址类似于c的指针，一个基址加上偏移。&lt;/p&gt;
&lt;p&gt;对AT&amp;amp;T来说，寻址方式比较怪异，但又非常简洁，语法格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	segreg:base_address(offset_address, index, size)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	;例子
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %eax, label1(, $2, $4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %ebx, (label2, $2,)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %ecx, (%esp)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其效果为 &lt;code&gt;segreg:base_address + offset_address + index * size&lt;/code&gt;
segreg为分段模式下段寄存器，&lt;code&gt;base_address&lt;/code&gt;为基址，&lt;code&gt;offset_address&lt;/code&gt; 为偏移，&lt;code&gt;index * size&lt;/code&gt;决定了第几个元素，其中size为元素长度，只能为1,2,4,8等等，这些元素都是可选的，index默认为0，size默认为1。&lt;/p&gt;
&lt;p&gt;对于MASM，表达相同含义的语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	segreg:[base_address + index * scale + offset_address]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	;例子
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov label1[2 * 4], eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov [label2 + 2], ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov [esp], ecx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对MASM，有些指令并不知道寻址以后是该取1字节还是多字节，也就是说需要制定寻址以后数据的长度，这个长度可由ptr操作符声明，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movzx eax, word ptr [base + 2];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样指定在base + 2地址处读取word宽度字节。而在AT&amp;amp;T中，由于指令可跟w,l等后缀，无需再次指令，这里可以看到AT&amp;amp;T简洁之处。&lt;/p&gt;
&lt;p&gt;另外，对AT&amp;amp;T，如果需要取全局符号的地址，可以使用$var（见框架），对于MASM，还需另外一个操作符：offset，相同的功能可写为offset var。当然也可使用lea指令，lea指令为取地址指令，语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;lea&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里跟offset的区别在于，offset在编译期间可以指定全局变量的位置，无需运行时计算，但是offset无法取得局部变量的 地址，因为局部变量位于堆栈，是在运行时才可得知其地址，而lea指令与之相反，是在运行时计算变量（可为全局和局部变量）的地址，二者的另一个区别在于 lea为cpu指令，AT&amp;amp;T同样有与之对应的指令（同其他指令一样，操作数相反，且指令可跟长度后缀），而offset仅仅为编译器指令，编译 成机器码之后只有一个地址，没有offset的影子。&lt;/p&gt;
&lt;p&gt;下面举一个简单的例子，仍然是翻译c代码到汇编：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	void swap(int * a, int * b)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int tmp = *a;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		*a = *b;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		*b = tmp;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int a[10] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 0};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		for (int i = 0; i &amp;lt; 10; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			for (int j = i; j &amp;lt; 10; ++j)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;				if (a[i] &amp;gt; a[j])
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;					swap(a + i, a + j);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里c代码是一个效率比较低的排序，我们改写成AT&amp;amp;T汇编 sort.s ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		array: .int 1, 3, 5, 7, 9, 2, 4, 6, 8, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_main:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		xorl %eax, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %eax, %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl array(, %ebx, 4), %ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmpl %ecx, array(, %eax, 4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jbe label1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		xchg %ecx, array(, %eax, 4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %ecx, array(, %ebx, 4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		incl %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmpl $10, %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		incl %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmpl $10, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _exit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的代码并不复杂，loop1, 和loop2为两个循环，之间的操作与c的含义相同，这里不做解释，其中的诸多细节需要细细体会，这里再给出MASM的一个版本，完全是从AT&amp;amp;T版本直译过来的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	array	dd 1, 3, 5, 7, 9, 2, 4, 6, 8, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    xor eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ebx, eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, array[ebx * 4]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp array[eax * 4], ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jbe label1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		xchg ecx, array[eax * 4]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov array[ebx * 4], ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		inc ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp ebx, 10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		inc eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp eax, 10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里可以充分看出AT&amp;amp;T和MASM的语言的不同之处。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(六)-数学运算</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.-assembler-math-instruct/</link>
        <pubDate>Thu, 17 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.-assembler-math-instruct/</guid>
        <description>&lt;p&gt;在上面几篇已经提到了一些数学运算功能，这篇再详细介绍之，数学运算无非是一些加减乘除，移位等等，就是这些简单的操作造就了丰富多彩的程序世界，可以说程序的根本就是计算。&lt;/p&gt;
&lt;h1 id=&#34;指令介绍&#34;&gt;指令介绍&lt;/h1&gt;
&lt;h2 id=&#34;加减法&#34;&gt;加减法&lt;/h2&gt;
&lt;p&gt;首先说加减法，其实加减法本身没什么好说，但是还是跟mov指令一样，AT&amp;amp;T和MASM语法的操作数相反，造成了混乱。对AT&amp;amp;T来说：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	addx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	subx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中x为操作数长度，与mov相同，这里的含义相当于 destination += source; 和 destination -= source&lt;/p&gt;
&lt;p&gt;对MASM来说，语法格式为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	add destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sub destination, source
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;add 和 sub 指令都会影响进位，零标志，符号标志，溢出标识辅助进位和奇偶标志，方便使用条件控制。&lt;/p&gt;
&lt;p&gt;inc和dec指令分别对寄存器或内存进行加一和减一操作，对于AT&amp;amp;T的指令，需要增加操作数长度指令b,l,w,q等，格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	inc operand
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dec operand
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;相反数&#34;&gt;相反数&lt;/h2&gt;
&lt;p&gt;neg 指令求寄存器和内存的相反数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	neg reg
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	neg mem
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进位加减法，adc和sbb，这两个指令的格式与add和sub完全相同，所不同的是adc把源操作数，目的操作数和进位标识相加。sbb同样也减去进位标识，这两个指令的存在主要是为了进行大整数运算。&lt;/p&gt;
&lt;h2 id=&#34;乘法&#34;&gt;乘法&lt;/h2&gt;
&lt;p&gt;乘法mul，imul:
其中mul为无符号乘法，乘法的格式也比较简单，而imul为有符号乘法， 却有三种语法格式。语法如下：&lt;/p&gt;
&lt;p&gt;以下是AT&amp;amp;T语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul imm, source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下是MASM语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul destination, source, imm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到mul只有源操作数，那目的操作数呢？其实这里是隐含操作数。mul的操作数如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;被乘数&lt;/th&gt;
&lt;th&gt;乘数&lt;/th&gt;
&lt;th&gt;积&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AL&lt;/td&gt;
&lt;td&gt;r/m8&lt;/td&gt;
&lt;td&gt;AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AX&lt;/td&gt;
&lt;td&gt;r/m16&lt;/td&gt;
&lt;td&gt;DX:AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EAX&lt;/td&gt;
&lt;td&gt;r/m32&lt;/td&gt;
&lt;td&gt;EDX:EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;最所以积比被乘数宽度大一倍，是因为两个32位的乘数乘起来可能是64位的！&lt;/p&gt;
&lt;p&gt;除法div，idiv
除法与乘法相反，mul的操作数表反过来便是div的操作数表，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;被除数&lt;/th&gt;
&lt;th&gt;除数&lt;/th&gt;
&lt;th&gt;商&lt;/th&gt;
&lt;th&gt;余数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AX&lt;/td&gt;
&lt;td&gt;r/m8&lt;/td&gt;
&lt;td&gt;AL&lt;/td&gt;
&lt;td&gt;AH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DX:AX&lt;/td&gt;
&lt;td&gt;r/m16&lt;/td&gt;
&lt;td&gt;AX&lt;/td&gt;
&lt;td&gt;DX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EDX:EAX&lt;/td&gt;
&lt;td&gt;r/m32&lt;/td&gt;
&lt;td&gt;EAX&lt;/td&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里跟乘法不同的是64位的操作数除以32位的操作数以后结果还可能大于32位，如此一来便会溢出，所以计算除法要千万小心，确保你的操作数不会出现溢出问题。
语法格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; 因为只有一个操作数，所以AT&amp;amp;T语法格式和MASM相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	div divisor
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	div divisor
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;移位运算&#34;&gt;移位运算&lt;/h2&gt;
&lt;p&gt;先说一下算术移位和逻辑移位，二者对于左移来说没有什么区别，都是在空位上补0，但对于右移，对于无符号的应该补零，对于有符号的应该补符号位，所以就有了算术和逻辑，算术右移补符号位，一般用于有符号数，逻辑右移不论符号位是什么，一律补0。&lt;/p&gt;
&lt;p&gt;循环移位，比如左移，先把所有位向左移一位，把最高位补到最低位的空缺，顺便把CF标志设置为最高位的值。
带进位的循环移位，跟循环移位相比，循环移位CF本身不参与移位，仅仅是记录最高位的值，而带进位的循环移位CF标志也参与移位，即CF放入对地位，高位填充至CF标志。&lt;/p&gt;
&lt;p&gt;还有一种移位为双精度移位，拿左移为例，改指令把目的操作数左移指定的位数，左移空出来的位用源操作数的高位来填充，源操作数不变，相当于循环移位但是是对不同的操作数来讲的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shl 	逻辑左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shr 	逻辑右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sal 	算术左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sar 	算术右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rol 	循环左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ror 	循环右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rcl 	带进位循环左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rcr 	带进位循环右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shld 	双精度左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shrd 	双精度右移
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下是各种语法规则(imm8为8位立即数）&lt;/p&gt;
&lt;p&gt;以下是AT&amp;amp;T语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; shl shr sal sar rol ror rcl rcr 指令格式相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shlx destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shlx imm8, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shlx %cl, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下是MASM语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; shl shr sal sar rol ror rcl rcr 指令格式相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shl destination, imm8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shl destination, cl
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; shld shrd 格式相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shld destination, source, cl/imm8
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;与或非运算&#34;&gt;与或非运算&lt;/h2&gt;
&lt;p&gt;对AT&amp;amp;T语法格式 x位操作数宽度&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	andx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	orx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	xorx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	notx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;MASM 语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	and destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	or destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	xor destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	not reg/mem
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;test指令&#34;&gt;test指令&lt;/h2&gt;
&lt;p&gt;test 指令与 and 指令相同，不过test指令不改变操作数的值，仅仅置eflags标志。&lt;/p&gt;
&lt;h2 id=&#34;cmp指令&#34;&gt;cmp指令&lt;/h2&gt;
&lt;p&gt;cmp 指令与 sub 指令相同，唯一的区别是cmp只置标记不保存结果，也就是cmp操作的源、目的操作数不变。&lt;/p&gt;
&lt;h1 id=&#34;例子&#34;&gt;例子&lt;/h1&gt;
&lt;p&gt;这里由于指令过多，而且写的比较匆忙，没有一一举例，仅仅做了一个简单总结，我的一位挚友对此文每种指令都做了尝试，并指出一些错误，在次表示感谢！以下测试代码由这位挚友提供，由于没有输出，可由ollydbg调试观察结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;.386&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.model&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;flat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;stdcall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;casemap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;none&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;windows.inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;kernel32.inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;includelib&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;kernel32.lib&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;res2&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dw&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;res3&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dd&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;start:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;sub&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;inc&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;dec&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;neg&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;单操作数乘法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;al&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;;被乘数根据位数不同分别默认存放于al(8)、ax(16)、eax(32)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ah&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mul&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ah&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;;积根据位数不同分别默认存放于ax(16)、dx:ax(32)、edx:eax(64)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;c1&#34;&gt;;32位积为什么不能直接存放于eax中呢？是因为刚开始计算机只有16位所以就按这种高位低位的方式来存放
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;c1&#34;&gt;;后面发展成为32位后为了保持兼容性故还是这样存放
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;双操作数乘法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;imul&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;三操作数乘法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;imul&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;;所谓三操作数就是在最后多乘了一个立即数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;除法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;33&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;bx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;div&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;bx&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;al&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;;商
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ah&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;;余数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;移位运算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;shl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;shr&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;sal&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;sar&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;rol&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;ror&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;rcl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;rcr&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;此指令前两个寄存器必须是大于8位的，左边操作数可以是内存，最后一个必须为8位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;shld&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;shrd&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;逻辑运算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;ffffh&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;xor&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;test, cmp指令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;jz&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;label1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label1:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;inc&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label2:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ExitProcess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;start&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>汇编语言学习笔记(五)-控制流</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.-assembler-control-flow/</link>
        <pubDate>Wed, 16 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.-assembler-control-flow/</guid>
        <description>&lt;p&gt;程序不可能一顺到底的执行，需要有一些分支流程控制的语法，对高级语言来讲，有分支循环等，对于汇编，有一个“跳”，或者选择性跳，跳转指令本身非常简单，仅仅一个jmp指令，类似于c语言的goto，语法为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jmp label
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;跳转分为段跳转（小于128字节），远跳转（分段模式下跨段跳转），近跳转（其他），不过这些在AT&amp;amp;T里编译器会根据参数的 变化而选择性的生成机器码，但对于MASM，需要自己指定，&lt;code&gt;jmp near ptr label&lt;/code&gt;, &lt;code&gt;jmp far ptr label&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但本质上讲，倘若只有这样的jmp，那不论如何跳都将是个死循环，所以便有了条件跳转（Jcond），在一定条件下进行跳转，这里所谓的条件，仍然是eflags的不同标记位，如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;跳转条件&lt;/th&gt;
&lt;th&gt;eflags标志&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JA&lt;/td&gt;
&lt;td&gt;Jump if above&lt;/td&gt;
&lt;td&gt;CF=0 &amp;amp; ZF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JAE&lt;/td&gt;
&lt;td&gt;Jump if above or equal&lt;/td&gt;
&lt;td&gt;CF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JB&lt;/td&gt;
&lt;td&gt;Jump if below&lt;/td&gt;
&lt;td&gt;CF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JBE&lt;/td&gt;
&lt;td&gt;Jump if below or equal&lt;/td&gt;
&lt;td&gt;CF=1 or ZF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JC&lt;/td&gt;
&lt;td&gt;Jump if carry&lt;/td&gt;
&lt;td&gt;CF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JCXZ&lt;/td&gt;
&lt;td&gt;Jump if CX=0&lt;/td&gt;
&lt;td&gt;register CX=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JE&lt;/td&gt;
&lt;td&gt;(is the same as JZ) Jump if equal&lt;/td&gt;
&lt;td&gt;ZF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JG&lt;/td&gt;
&lt;td&gt;Jump if greater (signed)&lt;/td&gt;
&lt;td&gt;ZF=0 &amp;amp; SF=OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JGE&lt;/td&gt;
&lt;td&gt;Jump if greater or equal (signed)&lt;/td&gt;
&lt;td&gt;SF=OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JL&lt;/td&gt;
&lt;td&gt;Jump if less (signed)&lt;/td&gt;
&lt;td&gt;SF != OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JLE&lt;/td&gt;
&lt;td&gt;Jump if less or equal (signed)&lt;/td&gt;
&lt;td&gt;ZF=1 or SF!=OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMP&lt;/td&gt;
&lt;td&gt;Unconditional Jump&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNA&lt;/td&gt;
&lt;td&gt;Jump if not above&lt;/td&gt;
&lt;td&gt;CF=1 or ZF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNAE&lt;/td&gt;
&lt;td&gt;Jump if not above or equal&lt;/td&gt;
&lt;td&gt;CF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNB&lt;/td&gt;
&lt;td&gt;Jump if not below&lt;/td&gt;
&lt;td&gt;CF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNBE&lt;/td&gt;
&lt;td&gt;Jump if not below or equal&lt;/td&gt;
&lt;td&gt;CF=1 &amp;amp; ZF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNC&lt;/td&gt;
&lt;td&gt;Jump if not carry&lt;/td&gt;
&lt;td&gt;CF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNE&lt;/td&gt;
&lt;td&gt;Jump if not equal&lt;/td&gt;
&lt;td&gt;ZF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNG&lt;/td&gt;
&lt;td&gt;Jump if not greater (signed)&lt;/td&gt;
&lt;td&gt;ZF=1 or SF!=OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNGE&lt;/td&gt;
&lt;td&gt;Jump if not greater or equal (signed)&lt;/td&gt;
&lt;td&gt;SF!=OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNL&lt;/td&gt;
&lt;td&gt;Jump if not less (signed)&lt;/td&gt;
&lt;td&gt;SF=OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNLE&lt;/td&gt;
&lt;td&gt;Jump if not less or equal (signed)&lt;/td&gt;
&lt;td&gt;ZF=0 &amp;amp; SF=OF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNO&lt;/td&gt;
&lt;td&gt;Jump if not overflow (signed)&lt;/td&gt;
&lt;td&gt;OF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNP&lt;/td&gt;
&lt;td&gt;Jump if no parity&lt;/td&gt;
&lt;td&gt;PF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNS&lt;/td&gt;
&lt;td&gt;Jump if not signed (signed)&lt;/td&gt;
&lt;td&gt;SF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNZ&lt;/td&gt;
&lt;td&gt;Jump if not zero&lt;/td&gt;
&lt;td&gt;ZF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JO&lt;/td&gt;
&lt;td&gt;Jump if overflow (signed)&lt;/td&gt;
&lt;td&gt;OF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JP&lt;/td&gt;
&lt;td&gt;Jump if parity&lt;/td&gt;
&lt;td&gt;PF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JPE&lt;/td&gt;
&lt;td&gt;Jump if parity even&lt;/td&gt;
&lt;td&gt;PF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JPO&lt;/td&gt;
&lt;td&gt;Jump if paity odd&lt;/td&gt;
&lt;td&gt;PF=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JS&lt;/td&gt;
&lt;td&gt;Jump if signed (signed)&lt;/td&gt;
&lt;td&gt;SF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JZ&lt;/td&gt;
&lt;td&gt;Jump if zero&lt;/td&gt;
&lt;td&gt;ZF=1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;根据上次的规律很容易理解，这里我们举几个例子，把c语言的流程控制语句转化为汇编：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对应的汇编语言写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nl&#34;&gt;sum:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.int&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nl&#34;&gt;num:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.int&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.globl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;_main:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;cmpl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;num&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;jbe&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;label1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;incl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;num&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label1:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;movl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label2:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;addl&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;incl&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;cmp&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;jb&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;label2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label3:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;pushl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_exit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译使用&lt;code&gt;gcc hello.s -g&lt;/code&gt;，加上调试信息，之后使用gdb调试，这里直接使用&lt;code&gt;br label3&lt;/code&gt;在&lt;code&gt;label3&lt;/code&gt;处下断，然后&lt;code&gt;print sum&lt;/code&gt;打印信息查看结果。&lt;/p&gt;
&lt;p&gt;这段程序开始 &lt;code&gt;cmpl $10, num&lt;/code&gt;，比较num和10，jbe跳转，相当于&lt;code&gt;if (num &amp;gt; 10)&lt;/code&gt; 部分，incl把操作数加一。&lt;/p&gt;
&lt;p&gt;对于for循环比较麻烦，这里把eax寄存器当做循环计数，先初始化eax为0，紧接着调用addl %eax, sum把eax加到sum上，再把eax加一，后面的比较就与if相同了，如果小于则跳转到label2。&lt;/p&gt;
&lt;p&gt;汇编中还有一类分支结构，就是循环loop，有三种形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop 循环到ecx为0，每次循环ecx减一
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loope/loopz 循环到ecx为0或者没有设置ZF标志
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loopne/loopnz 循环到ecx为0，或者设置了ZF标志
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还记得在寄存器那里提到，ecx被用作循环计数器，全部体现在这里了。loop本质上讲每次先把ecx减一，如果不为零则跳转到label，通过实现上面的for循环，很容易理解loop的使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		sum dd 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, 9;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		add sum, ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		loop label1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然准确的从逻辑上讲其实这样是少一个循环的，不过最后一次加的是0，忽略掉吧。
注意这里loop是先把ecx减一后判断是否为0，如果ecx开始为0，则不会停止，ecx直接溢出，被减成负数。&lt;/p&gt;
&lt;p&gt;在学习汇编时，可以多参阅编译器生成的汇编代码，用编译器gcc -S，便可生成汇编代码，也可使用不同的优化参数-O1 -O3优化生成的汇编，这样一来可以更好的学习汇编，而来可以理解c和汇编的对应关系，方便阅读反汇编代码。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(四)-MOV指令</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.-assembler-mov-instruct/</link>
        <pubDate>Tue, 15 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.-assembler-mov-instruct/</guid>
        <description>&lt;p&gt;汇编语言和高级语言不通，需要清晰掌握数据存储和机器相关的大量细节，高级语言会自动处理很多赋值的细节，有时甚至都不知道编译器给我创建了多少变 量，赋值了几次，但在汇编里，一切都变得很清晰了，你需要自己处理每个赋值的细节，这是通过mov指令实现，在汇编里，几乎有一半多的代码都是mov。&lt;/p&gt;
&lt;p&gt;对于AT&amp;amp;T和MASM两种语法，最大的差别就从此开始了，因为二者的源、目的操作数是相反的！&lt;/p&gt;
&lt;p&gt;在AT&amp;amp;T里mov的语法结构为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中x为操作数的宽度，有l，w，b，q等，例如movl操作数的宽度为32位，movb操作数宽度为8位，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl $0, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl $0, %al
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里另一个不同是寄存器的写法，在AT&amp;amp;T里使用寄存器要在寄存器前加%符号，在MASM中则不用。另外MASM可以自动识别操作数大小，如果有些仅仅传入内存，无法识别操作数大小，则必须使用 dword ptr[] 语法，这里在寻址部分会有涉及。&lt;/p&gt;
&lt;p&gt;在MASM中，mov语言的规则为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov destination, source
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里千万注意二者的操作数是相反的！&lt;/p&gt;
&lt;p&gt;对于MOV指令还有一些规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个操作数尺寸必须相同&lt;/li&gt;
&lt;li&gt;两个操作数不可同为内存&lt;/li&gt;
&lt;li&gt;目的操作数不可为CS，EIP和IP&lt;/li&gt;
&lt;li&gt;立即数不可直接传送至段寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些规则对AT&amp;amp;T语法也同样适用，why？因为二者编译都会编译成相同的二进制代码，这些规则是cpu的规则，而不是某种语法的规则。&lt;/p&gt;
&lt;p&gt;以上说的是基本的mov指令，另外为了方便或者效率，还有些相应的扩展指令：
扩展移动，因为mov指令的操作数大小必须相同，所以如果需要把一个较小值ax移动到较大值ebx中，则需要两步：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov ebx, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov bx, ax
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果ax为负数，需要把ebx高位扩展为全1，mov ebx, FFFFFFFFh，好在intel支持了相关的扩展指令，movzx和movsx
movzx为零扩展，即高位补零，movsx为符号扩展，即高位补符号位，一般有符号数适用movsx。此指令目标操作数必须为寄存器，源操作数可以为内存和寄存器。
写一个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		num1: .byte 0x12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		num2: .byte 0xf2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_main:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov num1, %al
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movzx num1, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movsx num1, %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movzx num2, %ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movsx num2, %edx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _exit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译时使用 &lt;code&gt;gcc -g hello.s -o hello&lt;/code&gt; 加入调试信息，便于调试，然后使用命令 &lt;code&gt;gdb a.exe&lt;/code&gt; 调试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	br main // 在main函数出下断点
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	r // 执行程序
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	n // 单步运行至 pushl $0 处
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	info register // 查看寄存器信息
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	eax 0×12 18
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ecx 0xf2 242
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	edx 0xfffffff2 -14
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ebx 0×12 18
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显示所有寄存器的信息，可以看到，eax和ebx都是0×12，因为num1高位是0，所以无论使用哪种方式都是高位补零，num2符号位为1，如此在使用movzx时高位补零，但是使用movsx时高位为符号位，补0，所以edx的最后结果为0xfffffff2。&lt;/p&gt;
&lt;p&gt;这里示例了AT&amp;amp;T语法，对于MASM二者的用法相同，除了操作数的顺序。&lt;/p&gt;
&lt;p&gt;mov 的另外一种变形是cmovx形式，涉及到cpu流水线的问题，cpu的eip寄存器指向当前执行的指令，但这个指令如果每次用到再从内存中读取，速度会有 所限制，于是cpu使用流水线方式，会对指令进行预读取，就是先读一定量的指令到队列中，每次都从此队列中读取，这样会加快执行速度，但是一旦遇到跳转指 令，cpu在运行到此处时并不知道程序将会走哪个分支，如此，到达跳转部分，将会有可能清空队列中所有指令，再次读取另一分支，损耗cpu执行指令的效 率，当然，cpu后来加入了乱序引擎，但是还是尽量减少跳转为上。对于一些简单的跳转移动数据，比如比较大小后决定是否赋值，使用cmovx形式便可不进 行跳转而完成这个过程。&lt;/p&gt;
&lt;p&gt;例如对于c语言的一段分支代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	if (a &amp;gt; b)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		max = a;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现用汇编改写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.686
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value1 dd 4321h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value2 dd 1234h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	max dd ?
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov eax, value1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp eax, value2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmovb eax, value2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov max, eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里要说明的是.686模式，如果使用.386模式编译会错误，说cmovb对目前的cpu模式不支持，从start开始，第一句 mov eax, value1 把value1赋值给eax寄存器，cmp比较eax和value2的大小，实际上做了一个eax-value2的操作，但是舍弃结果。如果eax小于 value2，则eflag寄存器的CF位被设置（参考寄存器），cmovb指令是CF=1时移动数据，否则不做操作。这样eax中即为大数，直接移动到 max内存中。&lt;/p&gt;
&lt;p&gt;这样程序看不到最终的效果，还需要调试器的帮助，在Windows平台，比较方便的动态调试工具为Ollydbg，打开 Ollydbg后文件-&amp;gt;打开cmov.exe，如此便可在代码窗口看到刚才写的指令，可以在push 0处设置断点，运行便可在右侧寄存器窗口看到结果。其使用方式与VC大致相同。&lt;/p&gt;
&lt;p&gt;另外从调试过程中，我们也可看到invoke ExitProcess, NULL被编译成push和call指令，与AT&amp;amp;T的写法相同，invoke仅仅是为了简化函数调用的写法而已。&lt;/p&gt;
&lt;p&gt;另外cmovx是一系列函数，都是根据eflag寄存器的不同标志来决定是否移动数据，其中的细节可参考Intel手册卷2A，这里简单列举一些情形以及条件：&lt;/p&gt;
&lt;p&gt;对于无符号型比较&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmova / cmovnbe &amp;gt; 赋值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovae / cmovnb &amp;gt;=
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovnc 无进位赋值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovb / cmovnae &amp;lt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovc 进位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovbe / cmovna cmove / cmovz = 或 为0 赋值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovne / cmovnz 不等于 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于有符号类型&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	:::nasm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovge / cmovnl &amp;gt;=
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovl / cmovnge &amp;lt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovle /cmovng cmovo 溢出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovno 未溢出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovs 结果带符号（负数）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovns 无符号（非负数） 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里乍一看，如此之多的情形，还只是其中一部分，不过稍微细心观察，这里的规律还是很明显的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	a表示above，无符号大于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	b表示blow，无符号小于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	e表示equal，等于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	n表示not，不等于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	g表示great，有符号大于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	l表示less，有符号小于 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;掌握其中规律，记住这些指令并不是难事，而且这些规律在汇编指令中是用过的，不如以后将会看到的条件跳转指令，也是如此。&lt;/p&gt;
&lt;p&gt;到这里mov指令介绍完了，但是移动数据的指令还有很多，这里也顺便做一些归纳，简单列举几类指令，对于AT&amp;amp;T和MASM都是通用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;xchg 指令：
格式 xchg operand1, operand2 ，交换operand1和operand2两个操作数的值，但千万别以为这个指令很方便，因为这个指令操作时会对内存加锁LOCK，可能会非常耗时，所以请慎用。这里两个操作数不能同为内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bswap 指令：
格式 bswap operand , 其中operand为32位或64位寄存器，这个指令时反转字节指令，即可以让32位寄存器的4个字节数据反转，可以方便的转换大小端数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lahf 和 sahf 指令：
lahf指令将eflags寄存器的低字节复制到ah寄存器，sahf把ah寄存器的值复制到eflags寄存器的低字节，ah为隐含操作数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push 指令:
把一个16位、32位、64位数据（寄存器，立即数，内存）到堆栈，esp指针做相应修改。这里AT&amp;amp;T指令必须自己指定大小，加后缀l, w等，与mov指令相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 指令:
出栈，与push相反。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有pop和push的批量操作指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pusha/popa 全部16位通用寄存器入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushad/popad 全部32位通用寄存器入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushf/popf eflags寄存器低16位入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushfd/popfd eflags寄存器全32位入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到这里介绍了常用的数据移动指令，当然这里不可能一一详细介绍，其中的细节还需要参考Intel手册卷2(A,B)。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(三)-数据结构</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.-assembler-datastruct/</link>
        <pubDate>Mon, 14 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.-assembler-datastruct/</guid>
        <description>&lt;p&gt;其实对于cpu来说，本没有什么类型之分，仅是一些内存，至于是什么，看你怎么去计算它们了，汇编是与机器码一一对应的，但是还是有些许区别，汇编毕竟还需要编译连接，为了给人使用方便，还是定义了不少数据类型（也有汇编除外，比如NASM，完全是对内存的操作）。&lt;/p&gt;
&lt;p&gt;对AT&amp;amp;T汇编来说，仅仅有几种基本类型，上篇介绍编程框架时已经有所涉及：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.ascii —— 字符串，但是无\0结尾
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.asciz —— 字符串，自动加入\0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.byte —— 8位数据
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.double ——　双精度64位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.float —— 单精度32位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.int —— 整数32位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.long —— 长整数32位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.octa —— 16字节整数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.quad —— 8字节整数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.short —— 短整型16位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.single —— 单精度，同.float
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这些基本数据类型时，可以用标号命名，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label1:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.ascii&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;test data\0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label2:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.byte&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样便可使用label2直接引用12这块内存，当然要取12这块内存的地址应使用$label2&lt;/p&gt;
&lt;p&gt;另外，还有一些有关符号的命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.equ&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;factor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是定义常量，定义factor为3，如果还记得上一篇的内容，如果想使用此标号，应该写为 $factor&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.comm&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;symbol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;length&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里定义在.bss段，表示在symbol处分配length长度的空间，通用符号&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.lcomm&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;symbol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;length&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里定义在.bss段，表示sysmol处将会分配有length长度的空间，不过符号只能在本文件内使用&lt;/p&gt;
&lt;p&gt;对比MASM，数据类型要复杂的多，甚至有高级语言所谓的结构体。&lt;/p&gt;
&lt;p&gt;先说其基本类型及其相应的简写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	byte 8位无符号 简写db
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sbyte 8位有符号
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	word 16位无符号 简写dw
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sword 16位有符号
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dword 32位无符号 简写dd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sdword 32位有符号
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	fword 48位整数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	qword 64位整数 简写dq
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	tbyte 80位整数 简写dt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	read4 32位IEEE短实数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	real8 64位IEEE长实数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	real10 80位IEEE扩展精度
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义变量时格式为：
[name] 指令 初始值 [,初始值 &amp;hellip;]
例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value1 byte &amp;#39;A&amp;#39;, &amp;#39;b&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value2 dd 12345678h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value3 byte &amp;#34;This is a string&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中数字后加h位16进制数字，在初始值处也可使用num dup(value)来创建num个value值。&lt;/p&gt;
&lt;p&gt;另外MASM中定义常量也需要equ指令，但是用法却与gas语法不同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name equ expression
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name equ symbol
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name equ
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外还有指令 textequ，可以被重定义&lt;/p&gt;
&lt;p&gt;另外MASM高级数据类型还有结构，结构其实是基本类型的组合，定义的基本格式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name struct
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name type initial_value
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name ends
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中初始化数据定义结构成员默认值，可写?表示未定义。&lt;/p&gt;
&lt;p&gt;在初始化结构体时，可使用&amp;lt;&amp;gt;构建初始化列表，若为空则结构初始化为定义的默认值。
例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; Post结构定义
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Post struct
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		IdNum	byte &amp;#34;123456&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		Time	dw	?
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		Content	byte 1024 dup(&amp;#39;A&amp;#39;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Post ends
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; Post对象声明
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No1	Post &amp;lt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No2 Post 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No3 Post 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No4 Post 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; 使用变量时与c无异
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov Post.Time, eax
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，结构体内仍可嵌套其他结构体，Masm32在 windows.inc 头文件中定义了Win32 API结构和函数。&lt;/p&gt;
&lt;p&gt;还有一种高级结构为联合，语法声明为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name union
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	union-fields
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name ends
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 union-fields 部分与结构完全相同，这里不再赘述。&lt;/p&gt;
&lt;p&gt;这 里介绍了AT&amp;amp;T的MASM语法的数据类型部分，程序=数据+算法，数据类型并不很难，却是程序的一个重要组成部分。从这里可以看到AT&amp;amp;T数据类型十分之少，没有结构体等高级概念，当然这样定义变量时也不需要事先声明，对他来说，每个变量仅仅是一个地址，如果需要操作结构，还需我 们自己计算结构的偏移；而MASM相对方便了很多，有点类似高级语言的味道，当然语法规则也更为繁琐。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(二)-代码框架</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.-assembler-framework/</link>
        <pubDate>Sun, 13 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.-assembler-framework/</guid>
        <description>&lt;p&gt;前面总结了一下普通寄存器的知识，这里绍下汇编程序的基本框架。&lt;/p&gt;
&lt;h1 id=&#34;gas语法框架&#34;&gt;GAS语法框架&lt;/h1&gt;
&lt;p&gt;程序员学习语言都是从&lt;code&gt;hello world&lt;/code&gt;开始的，这样能快速展示一个能运行的完整程序，对语言有个直观的理解。首先说一下环境配置，对于linux程序，无需过多的配置，只需要 有gcc编译环境即可，调试时需要使用gdb，另外，由于AT&amp;amp;T汇编的跨平台性，在Windows系统下可以使用MinGW编译器，具备gcc 的全套功能，但是毕竟与纯粹的linux平台还是有些差别，为了使用AT&amp;amp;T和MASM两种语言方便切换，这里将使用MinGW编译器介绍，并且 将说明与Linux环境的差别。&lt;/p&gt;
&lt;p&gt;下面看一下&lt;code&gt;hello world&lt;/code&gt;程序，因为GAS汇编文件以.s后缀，所以文件名定为hello.s：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;out_text:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;na&#34;&gt;.asciz&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello world\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.globl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;_main:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;pushl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$out_text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_printf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;pushl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_exit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了方便输出，忽略程序细节，其中引用了c函数库，可以使用 &lt;code&gt;gcc hello.s -o hello&lt;/code&gt; 来编译此程序，运行hello后输出hello world字串。&lt;/p&gt;
&lt;p&gt;至 此完成了最为简单的程序，从main开始，先调用printf输出out_text处的字串，之后调用exit程序结束程序，从代码调用的函数名可以很清 楚理解这个过程，但是汇编最需注重的是细节，任何一个细节都可能导致程序的崩溃。&lt;/p&gt;
&lt;h1 id=&#34;gas程序说明&#34;&gt;GAS程序说明&lt;/h1&gt;
&lt;p&gt;下面我对以上涉及到的细节做一些说明：&lt;/p&gt;
&lt;h2 id=&#34;函数入口&#34;&gt;函数入口&lt;/h2&gt;
&lt;p&gt;对于c来说，毫无疑问是main函数作为入口，但这也只是表象，之所以要指定入口，是因为连接器把目标文件组织成可执行文件时需要把入口代码放到代码 段最开始的位置，只要编译器告诉连接器把哪个部分放在入口处即可，所以入口仅仅是一个符号，一个程序可以完全不写main函数，直接修改连接器ld的连接 脚本或者参数，自定义一个入口点。&lt;/p&gt;
&lt;p&gt;汇编程序也是如此，因为直接使用的gcc编译器，gcc把&lt;code&gt;main&lt;/code&gt;作为入口点，但其实gcc并不是编译汇编的主体，汇编编译器其实是as，它默认入口点是 &lt;code&gt;start&lt;/code&gt;。可以把以上程序&lt;code&gt;_main&lt;/code&gt;修改为&lt;code&gt;_start&lt;/code&gt;，使用as进行编译，编译成目标文件之后再使用ld进行链接，之所以这里用gcc编译，完全是为 了简单，它可以自动进行编译连接，并在连接时加入c库。&lt;/p&gt;
&lt;h2 id=&#34;c库调用&#34;&gt;C库调用&lt;/h2&gt;
&lt;p&gt;另一个问题是main，&lt;code&gt;printf&lt;/code&gt;函数都有个下划线，问题便出来了，到底这个 是&lt;code&gt;printf&lt;/code&gt;还是&lt;code&gt;_printf&lt;/code&gt;呢？这里完全是Windows下的规则，Windows的标准c函数，在连接时符号都是加入下划线的，在vc里写入 &lt;code&gt;printf&lt;/code&gt;，编译时被修改为&lt;code&gt;_printf&lt;/code&gt;进行连接，这里由于是汇编，没有c编译器处理这些细节，只能由我们直接写出最终的连接符号。这里有必要一提的 是，对于stdcall类型函数，比如Win32 API，连接符号后会有“@参数总长度 ” 这样的后缀，比如上层的&lt;code&gt;MessageBox&lt;/code&gt;函数，在编译时便会转变成&lt;code&gt;_MessageBoxA@16&lt;/code&gt;，后面所加的A是使用的窄字符版本，这里并不是编译 器所作，而是Windows.h头文件中使用宏分离的不同字符集下的符号，作为汇编，一切工作都得由我们做了，可以看到使用GAS来处理Windows程 序甚为繁琐，因为没有很好的支持，后面可以看到MASM的一个封装，MASM32，作者本身定义了很多的宏以方便调用。当然，如果在linux下编程，便 可省去这烦人的下弧线了。&lt;/p&gt;
&lt;h2 id=&#34;数据段和代码段&#34;&gt;数据段和代码段&lt;/h2&gt;
&lt;p&gt;接下来该进入正题了，就是语法，由于最终程序是要分成若干段，比如代码段，数据段，这些c编译器可以帮忙指定，对于汇编，还是需要我们自己说明，这里的&lt;code&gt;.section&lt;/code&gt;指令便是指明段的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.data —— 初始化数据段，其中的数据在编译期间便已经占用了指定了空间&lt;/li&gt;
&lt;li&gt;.bss —— 与.data对应，是未初始化数据段，也就是这里的数据是未初始化的，在程序运行时才分配的空间&lt;/li&gt;
&lt;li&gt;.rodata —— 只读数据段，相当于常量区，其中的数据不可修改&lt;/li&gt;
&lt;li&gt;.text —— 代码段，此段具有可执行属性，只读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标签&#34;&gt;标签&lt;/h2&gt;
&lt;p&gt;另外，&lt;code&gt;out_text&lt;/code&gt;为标签，因为gas汇编并没有变量名的概念，只能在内存地址的其实位置定义一个标签，方便以后引用此位置。&lt;code&gt;.globl&lt;/code&gt; 导出&lt;code&gt;_main&lt;/code&gt;这个符号，毕竟在连接时需要使用此符号。&lt;/p&gt;
&lt;h2 id=&#34;符号&#34;&gt;$符号&lt;/h2&gt;
&lt;p&gt;最后说明一$符号的使用，在gas汇编中，对于立即数，比如0，需要在数字之前加上$符号，来指明此为立即数，$0就是立即数0，另外，对于符号前的$，即为取地址，&lt;code&gt;$out_text&lt;/code&gt;含义便是取出&lt;code&gt;out_text&lt;/code&gt;的地址，因为&lt;code&gt;printf&lt;/code&gt;需要&lt;code&gt;char *&lt;/code&gt;指针传入。&lt;/p&gt;
&lt;p&gt;如此，示例代码便很容易理解了。对于涉及到的一些汇编指令，今后将会做详细说明。&lt;/p&gt;
&lt;h1 id=&#34;masn-语法框架&#34;&gt;MASN 语法框架&lt;/h1&gt;
&lt;p&gt;对于MASM汇编，语法规则可能要繁琐，但是理解反而要简单，这可能是微软的一贯风格。
首先也来讲一下环境配置，其实编译MASM只需要在微软的开发包中提取出ml.exe和link.exe即可，有人为了方便大家使用，把所需要的一系列工具集成一个开发包，可以在这里下载 Masm32 。&lt;/p&gt;
&lt;p&gt;安装好后，便可开始&lt;code&gt;hello world&lt;/code&gt;程序，这里使用记事本创建&lt;code&gt;hello.asm&lt;/code&gt;程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    user32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib user32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	szText    db &amp;#39;hello world!&amp;#39;,0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke MessageBox, NULL, offset szText, NULL, MB_OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里编译的时候要注意，因为这里引用了头文件和lib文件，所以需要设置环境变量include和lib到masm32目录下的include和lib，或者直接在源文件里写绝对路径，最好设置masm32/bin到path变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ml /c /coff hello.asm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	link /SUBSYSTEM:WINDOWS hello.obj
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ml 为编译命令，&lt;code&gt;/c&lt;/code&gt; 是仅编译不连接，&lt;code&gt;/coff&lt;/code&gt;是编译为coff格式的目标文件。
link 为连接命令，&lt;code&gt;/SUBSYSTEM:WINDOWS&lt;/code&gt; 指定为窗口程序&lt;/p&gt;
&lt;p&gt;先看开头这些命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;.386&lt;/code&gt; 指定处理器构架在&lt;code&gt;.386&lt;/code&gt;以上，&lt;code&gt;.model&lt;/code&gt;指定编译模式为flat平坦模式，&lt;code&gt;casemap:none&lt;/code&gt;选项表明程序大小写敏感。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.data 指定数据段 .code指定代码段。&lt;/li&gt;
&lt;li&gt;start 为程序开始指定一个符号&lt;/li&gt;
&lt;li&gt;end start 指明程序就此结束，并指定程序入口为start&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里给出框架仅仅为了能建立能运行的汇编环境，其中调用了一些API，也算作配合高级语言编程的一种方式，但汇编绝对不是调用几个API显示几个漂亮的窗口 就算是学会汇编，这些事情用C语言都能够更轻易的处理，一个语言擅长什么就该让它去做什么。没有能应对一切情况的语言，如同没有一个完美的人。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(一)-寄存器</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.-assembler-register/</link>
        <pubDate>Sat, 12 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.-assembler-register/</guid>
        <description>&lt;p&gt;一直在犹豫汇编语言开始讲什么，如果只说指令，常用的也就几十条甚至十几条指令，如果认为学习汇编就是学习一些指令，那未免有点舍本逐末，如果从IA-32构架开始，又过于晦涩，纠结之下还是先对下基本寄存器做个介绍，为了完整性，顺便对其他高级寄存器做一个列举。&lt;/p&gt;
&lt;p&gt;寄存器是CPU的组成部分，因为在CPU内，所以CPU对其读写速度是最快的，不需要IO传输，但同时也决定了此类寄存器数量非常有限，有限到几乎每个存储都有自己的名字，而且有些还有多个名字^_^&lt;/p&gt;
&lt;h1 id=&#34;寄存器分类&#34;&gt;寄存器分类&lt;/h1&gt;
&lt;p&gt;IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;段寄存器&lt;/li&gt;
&lt;li&gt;状态和控制寄存器&lt;/li&gt;
&lt;li&gt;指令寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通用寄存器&#34;&gt;通用寄存器&lt;/h2&gt;
&lt;p&gt;32位通用寄存器有八个，eax, ebx, ecx, edx, esi, edi, ebp, esp，他们主要用作逻辑运算、地址计算和内存指针，具体功能如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eax —— 累加和结果寄存器
ebx —— 数据指针寄存器
ecx —— 循环计数器
edx —— i/o指针
esi —— 源地址寄存器
edi —— 目的地址寄存器
esp —— 堆栈指针
ebp —— 栈指针寄存器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，以上功能并未限制寄存器的使用，特殊情况为了效率也可作其他用途。这八个寄存器低16位分别有一个引用别名 ax, bx, cx, dx, bp, si, di, sp, 其中 ax, bx, cx, dx, 的高8位又引用至 ah, bh, ch, dh，低八位引用至 al, bl, cl, dl&lt;/p&gt;
&lt;p&gt;在 64-bit 模式下，有16个通用寄存器，但是这16个寄存器是兼容32位模式的，32位方式下寄存器名分别为 eax, ebx, ecx, edx, edi, esi, ebp, esp, r8d – r15d. 在64位模式下，他们被扩展为 rax, rbx, rcx, rdx, rdi, rsi, rbp, rsp, r8 – r15. 其中 r8 – r15 这八个寄存器是64-bit模式下新加入的寄存器。&lt;/p&gt;
&lt;h2 id=&#34;段寄存器&#34;&gt;段寄存器&lt;/h2&gt;
&lt;p&gt;段寄存器 cs, ds, ss, es, fs, gs, 保存16位的段选择子，一个段选择子指定了一个段在内存的指针，以便再内存中访问段，访问方式与内存模式有关，段模式和平坦模式其代表的意义并不相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cs —— 代码段寄存器
ds, es, fs, gs —— 数据段寄存器
ss —— 堆栈段寄存器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 64-bit 模式下，这6个寄存器并无变化，只是使用上略有区别。&lt;/p&gt;
&lt;h2 id=&#34;状态和控制寄存器-eflags&#34;&gt;状态和控制寄存器 eflags&lt;/h2&gt;
&lt;p&gt;这个寄存器表示的意义非常丰富，程序中并不直接操作此寄存器，并由此衍生出很多操作指令。&lt;/p&gt;
&lt;p&gt;除去一些保留位，其他每位都代表一个具体的含义，其中 bits 0, 2, 4, 6, 7, 11 是状态位，标识了某此操作后的状态，8, 9, 10 位为控制标识&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CF (bit 0) —— 进位标识，算术操作进行了进位和借位，则此位被设置
PF (bit 2) —— 奇偶标识，结果包含奇数个1，则设置此位
AF (bit 4) —— 辅助进位标识，结果的第3位像第4位借位，则此位被设置
ZF (bit 6) —— 零标识，结果为零，此位设置
SF (bit 7) —— 符号标识，若为负数则设置此位
OF (bit 11) —— 溢出标识，结果像最高位符号位进行借位或者进位，此标志被设置

TF (bit 8) —— 陷阱标识，设置进程可以被单步调试
IF (bit 9) —— 中断标识，设置能够响应中断请求
DF (bit 10) —— 方向标识，用于标示字符处理过程中指针移动方向。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在64-bit模式下，该寄存器被扩展为64位，rflags，但是其高32位保留未被使用，其低32位所表示含义与32位模式相同。&lt;/p&gt;
&lt;h2 id=&#34;指令寄存器-eip&#34;&gt;指令寄存器 EIP&lt;/h2&gt;
&lt;p&gt;EIP —— 标志当前进程将要执行指令位置
在64位模式下扩展为 RIP 64位指令寄存器。&lt;/p&gt;
&lt;h2 id=&#34;控制寄存器&#34;&gt;控制寄存器&lt;/h2&gt;
&lt;p&gt;cr0, cr2, cr3, cr4&lt;/p&gt;
&lt;h2 id=&#34;系统表指针寄存器&#34;&gt;系统表指针寄存器&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;idtr —— 中断描述符表信息
gdtr —— 全局描述符表信息
ldtr —— 局部描述符表信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;任务寄存器tr&#34;&gt;任务寄存器tr&lt;/h2&gt;
&lt;p&gt;保存任务的状态信息 tss&lt;/p&gt;
&lt;p&gt;调试寄存器
dr0 – dr7
控制和允许监视进程的调试操作&lt;/p&gt;
&lt;h2 id=&#34;x87-fpu-寄存器&#34;&gt;x87 FPU 寄存器&lt;/h2&gt;
&lt;p&gt;这组指令专门用过浮点运算，因为浮点运算尤其固有的特性，所以需要使用一组独立寄存器。
数据寄存器包括 r0 – r7 的8个 80 位寄存器，汇编程序中通过名字 st(x) 引用，另外还有3个16位寄存器，分别是控制寄存器，状态寄存器，标记寄存器。
这里的省略具体含义的介绍。&lt;/p&gt;
&lt;h2 id=&#34;mmx-寄存器&#34;&gt;MMX 寄存器&lt;/h2&gt;
&lt;p&gt;MMX 为一种 SIMD 技术，即可通过一条指令执行多个数据运算，共有8个64位寄存器，分别为mm0 – mm7，他与其他普通64位寄存器的区别在于通过它的指令进行运算，可以同时计算2个32位数据，或者4个16位数据等等，可以应用为图像处理过程中图形 颜色的计算。另外需要特别注意的是，MMX并非一种新的寄存器，而是FPU 80位寄存器的低64位，也就是说，使用MMX指令集，会影响浮点运算！&lt;/p&gt;
&lt;h2 id=&#34;xmm-寄存器&#34;&gt;XMM 寄存器&lt;/h2&gt;
&lt;p&gt;XMM 同 MMX，只是他有 8 个 128 位寄存器，分别为 xmm0 – xmm7，另外还包含计算过程中的状态和控制寄存器&lt;/p&gt;
&lt;p&gt;这篇介绍列举了一些CPU寄存器并对某些寄存器进行了详细介绍，但并非完整详尽的介绍，略去了很多细节，因为寄存器本身只做存储之用，真正理解还需依靠其对应的指令操作，这里仅仅为之后的介绍做一些准备工作，如果有可能，我会努力完善此文。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(零)-为什么开始</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.-assembler-why-learning/</link>
        <pubDate>Fri, 11 Apr 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.-assembler-why-learning/</guid>
        <description>&lt;h1 id=&#34;为什么开始&#34;&gt;为什么开始&lt;/h1&gt;
&lt;p&gt;从开始学习汇编到现在也有很长时间了，虽算不上刻苦钻研，但接触久了多少也有些感悟，打算就此做一些总结，一来算是备忘，二来也可以梳理知识使之融会贯通。我自小就不是一个勤奋的人，写这个东西也不会很积极，只当做是闲暇时的消遣，希望不要无疾而终便好。&lt;/p&gt;
&lt;p&gt;沿袭程序员“良好”习惯，这篇文章做为第零篇，主要总括汇编语言的概况以及它的主要用途，初识一种技能，知道它能做什么或许比如何去做更加有意义。&lt;/p&gt;
&lt;h1 id=&#34;汇编语言种类&#34;&gt;汇编语言种类&lt;/h1&gt;
&lt;p&gt;汇编语言不同于C、C++等高级语言，因为它“派系林立”，语法种类非常之多，但总体来讲各种语法都没有本质的差别，更多的是表述方式不同。&lt;/p&gt;
&lt;p&gt;大学时期学过一门《微机原理》的课程，其中的汇编是微软的Masm语法，如同Windows基本成为系统的代名词，Masm几乎也成了汇编代名词，但我这组文章并不是仅仅用来说明Masm，微软的东西用起来挺方便，用多了感觉多少有点繁琐；Masm 还是 Visual C++编译后端，如果有需要，可以编译C/C++代码到Masm查看汇编代码。&lt;/p&gt;
&lt;p&gt;除此之外，比较流行的语法还有Nasm，这也算是个简洁的语法，简单到连数据类型都没有，只需指定内存大小，如何理解内存是开发者的事情，这样也更接近汇编语言的本质，但易用性就较之Masm差了很多；与Masm专注于Windows平台不同，Nasm是个跨平台语言，几乎可以生成各种平台下各种格式的二进制，官方的教程也写得很详细，只是语言显得有点过于简单，似乎学的人不少，但是用的人不多。&lt;/p&gt;
&lt;p&gt;还有一种比较出名的汇编语法HLA，语法有点类似高级语言，这种语法之所以出名得益于《汇编语言编程艺术》一书，书名有“艺术”一词或许会显得比较高深，但实在不知道这种语法除了作者还有谁在使用，用于何地。&lt;/p&gt;
&lt;p&gt;最后隆重推出的语法是AT&amp;amp;T的GAS语法，压轴戏都是最后登场，此次也不例外，之前提到的各种汇编语法都是伟大的结晶，我也没有任何贬低之意，只是我更加喜欢AT&amp;amp;T而已，AT&amp;amp;T语法是Gcc的后端汇编语法，这也是为什么我更偏爱它的原因之一，Gcc几乎可以在任何平台编译任何代码，GAS当然做到Gcc所实现的事情，Nasm虽然也能轻松跨平台应用，但在特定平台下编译代码，除了代码的二进制还需有资源文件、系统库等，这点需要一个强大的链接器支持，与其使用各种拼盘，不如直接用Gcc套件来的更为直接；AT&amp;amp;T汇编也被应用于Linux内核中，这点也不难理解，原本Gcc编译的代码就跟AT&amp;amp;T汇编是一样的的东西。&lt;/p&gt;
&lt;p&gt;当然，汇编语言种类很多，还有些主要应用于Dos平台，我也没有更多接触，自此也不便妄加评论；汇编之中使用最为广泛的就属Win平台下的MASM和Linux平台下的GAS，之所以重要在于二者分别是VC++和Gcc这两大重器的后端，尤其是在Windows广泛应用的环境下，Masm在汇编语法中就显得更为重要了，所以说，有时候拼的不是谁更出色，而是拼谁的“背景”更牛。若在Linux平台想用汇编对代码进行优化、阅读Linux内核源码，就免不了GAS汇编；在Windows下做优化、破解、外挂，也免不了Masm汇编。虽说二者本质相同，但表现形式还是有很大差别。我这里写的东西并不局限于其中一种汇编，因为二者都是非常重要的语言。&lt;/p&gt;
&lt;h1 id=&#34;学习汇编语言有什么用&#34;&gt;学习汇编语言有什么用&lt;/h1&gt;
&lt;p&gt;在学习汇编之前，很多人可能都有疑问，汇编到底能做什么，除非是Geek，否则没人去用汇编写一套软件出来吧；在这里需要总括一下汇编的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;破解：也许汇编最广的用途在于软件的破解，在中国大多数人都在有意无意的使用着盗版，有很多人都不知道自己电脑中哪些软件是需要收费的，也有很多程序员收集很多软件，以及这些软件所对应的注册码供人使用，所谓己所不欲勿施于人，作为一个程序员，却侵犯着其他程序员的利益，好在如今免费的东西越来越多，尤其是互联网的广泛使用，各种云平台的挤压，为服务收费方式越来越多过为软件收费的方式。抛开盗版这种行为，破解软件的过程中本身是件很有趣的事情，是跟软件保护者的一场智力对抗比赛；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逆向工程：有时候看到某些软件制作精巧，细想之下居然不知道他是如何实现的，在作者不开源的情况下，要想理解作者的实现思路，只能阅读部分的汇编代码，还原为C代码来仿制作者的功能；同样由于互联网的冲击，提供网络服务的企业越来越多，逆向的需求也越来越少；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;游戏外挂：破解和逆向的应用场景不断收缩，但与之关联的游戏外挂却越来越火爆（当然法律的越来越健全对外挂有着相当大的阻力），因为通过游戏的盈利点非常清晰，通过一款成功的游戏能够获得巨大收益，而外挂是游戏的一种“捷径”，从中牟取的利益也是非常客观。游戏外挂本身是逆向和破解的集合，对技能的要求非常高。随着网页游戏和手机游戏的逐渐火爆，外挂的形式也变得多种多样，已经并不局限于汇编；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统编程：对于精确定位和控制可执行文件大小方面，恐怕没有哪种高级语言能够实现，Linux内核尽可能使用C语言实现，但是引导区部分仍然需要汇编处理，另外，操控硬件(in,out指令)，中断（int,syscall指令）等等，C语言也需要内联汇编实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编优化：C语言是比较底层的语言，还是需要更进一步编译为汇编代码，由于C需要通用性，翻译成汇编指令的过程中为了兼顾其他平台或者各种可能的用法，对某种具体行为未必能做到最优化处理，这时就需要手动调整汇编代码，不过Gcc 的优化能力已经非常出色，况且这种优化只能是微观优化，大多数情况还得需要宏观的优化，调整算法的复杂度，汇编优化可能提高几倍的效率，业务算法的优化可能能够提升上百倍甚至上千倍的效率，除非这里已经是算法的瓶颈所在，否则汇编优化是没有多少意义的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解高级语言：C++有很多晦涩的语法，不了解编译器如何实现，可能有各种猜测，但事实是否如此，我们可将最简单的例子编译成汇编阅读，一窥语言的底层实现，不过这里只供理解之用，不是标准规定的，各个平台的实现并不尽相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有对可执行文件的二次开发等等，都脱离不了对程序的逆向。同时我们也可以看到，在互联网时代，汇编似乎显得比较没落，更多的学习者都在于增加“功力”而已。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
