<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>编程 on 讲故事的人</title>
        <link>https://drawing.fancymore.com/categories/%E7%BC%96%E7%A8%8B/</link>
        <description>Recent content in 编程 on 讲故事的人</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 11 Apr 2023 22:50:04 +0800</lastBuildDate><atom:link href="https://drawing.fancymore.com/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>告警优化实践总结</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</link>
        <pubDate>Tue, 11 Apr 2023 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</guid>
        <description>&lt;h2 id=&#34;一背景&#34;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;对于 7*24 小时不间断运行的后台服务，监控告警是稳定性运行的基石。很多开发者都有过这样的经历，对服务的每一个指标都做了严格的监控和告警，唯恐漏掉告警导致问题无法发现，导致每天接收到大量的无效告警，告警的泛滥逐渐麻痹了警惕性，结果真实的问题初漏端倪时却被忽略，最终导致了严重的故障。&lt;/p&gt;
&lt;p&gt;如何提升告警的有效性，准确识别问题，同时又不至于淹没在大量的无效告警中，正是本文所探讨的内容。&lt;/p&gt;
&lt;h2 id=&#34;二告警是可靠性的基础&#34;&gt;二、告警是可靠性的基础&lt;/h2&gt;
&lt;p&gt;首先来看一下告警的重要性，为什么我们需要耗费这么多精力来优化告警。虽然我们都期望一个服务是没有故障的，但事实确是不存在 100% 没问题的系统，我们只能不断提升服务的可靠性，我们期望做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对服务当前状态了如指掌，尽在掌控&lt;/li&gt;
&lt;li&gt;能够第一时间发现问题，并且快速定位问题原因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要想做到以上两点，只能依赖完善的监控&amp;amp;告警，监控展示服务的完整运行状态，但是不可能一直盯屏观察，并且也不可能关注到所有方面，要想被动的了解系统状态，唯有通过告警，自动检测异常情况。&lt;/p&gt;
&lt;p&gt;所以，告警是团队监控服务质量和可用性的一个最主要手段。系统故障相关的时间问题通常用 MTBF、MTTF、MTTR 这三项指标来表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MTTF (Mean Time To Failure，平均无故障时间）&lt;/strong&gt;：指系统无故障运行的平均时间，取所有从系统开始正常运行到发生故障之间的时间段的平均值。 MTTF = ∑T1 / N&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MTTR (Mean Time To Repair，平均修复时间）&lt;/strong&gt;：指系统从发生故障到维修结束之间的时间段的平均值。MTTR = ∑(T2+T3) / N&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MTBF (Mean Time Between Failure，平均失效间隔）&lt;/strong&gt;：指系统两次故障发生时间之间的时间段的平均值。 MTBF = ∑(T2+T3+T1) / N&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-10-28.png&#34;
	width=&#34;2042&#34;
	height=&#34;570&#34;
	srcset=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-10-28_hu15943157384875458411.png 480w, https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-10-28_hu11269095617358630092.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;可用性指标&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;358&#34;
		data-flex-basis=&#34;859px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可靠性在于追求更高的 MTTF 和低的 MTTR（平均无故障时间）。最好的情况是能够不产生故障，但不存在 100%可靠的系统，当出现故障/异常时，我们需要尽可能减少 MTTR（平均修复时间），告警的意义在于尽可能减少 T2 + T3 时间。&lt;/p&gt;
&lt;h2 id=&#34;三告警面临的现实问题&#34;&gt;三、告警面临的现实问题&lt;/h2&gt;
&lt;p&gt;理想中的告警，不存在误报（即本来正常的，告警为异常）也不存在漏报（即本来异常的，误认为正常），所以理想的模型满足以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;误报为 0：出现的告警都是需要处理的问题&lt;/li&gt;
&lt;li&gt;漏报为 0：异常问题都能够告警发现&lt;/li&gt;
&lt;li&gt;及时发现：能够第一时间发现问题，甚至于在导致故障前发现问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但在实践中无法做到理想情况。要减少漏报，需要针对每一种可能发生的场景进行监控，同时配置告警，这其实并不算困难；但我们的告警往往不是太少了，而是太多了，以至于需要耗费大量时间处理无效告警，由于告警过多，容易忽略真正有用的告警，导致异常发现的时间变长，或者忽略的潜在的风险。所以对于告警，最大的问题在于如何减少无效告警，提升告警的效率。&lt;/p&gt;
&lt;p&gt;先来看一下无效告警产生的原因。&lt;/p&gt;
&lt;p&gt;监控系统应该解决两个问题：什么东西出故障了，以及为什么会出故障。其中“什么东西出故障了”即为现象，“为什么”则代表了原因（可能是中间原因）。现象和原因的区分是构建信噪比高的监控系统时最重要的概念。&lt;/p&gt;
&lt;p&gt;在实践中，想绝对做到这两点几乎不可能，但我们可以无限趋向于理想模型。&lt;/p&gt;
&lt;p&gt;告警一般是通过“现象”来判断，而是否有问题要看产生现象的原因判断。相同的现象引起的原因可能不同，这种“可能性”是导致误告警的最核心原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-11-21.png&#34;
	width=&#34;766&#34;
	height=&#34;388&#34;
	srcset=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-11-21_hu3871953080438610077.png 480w, https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-11-21_hu3726007170146800320.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;197&#34;
		data-flex-basis=&#34;473px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;举个例子，请求失败告警，原因可能是请求内容有问题，也可能上游机器异常，或者是我们自身的服务处理异常。理想的情况肯定是期望告警有着唯一的原因，但实际上由于现实的复杂性，未必能够做到精准的区分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-11-50.png&#34;
	width=&#34;916&#34;
	height=&#34;510&#34;
	srcset=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-11-50_hu9081048393850106354.png 480w, https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-11-50_hu17186107071552279164.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;431px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;减少误告警的思路，就是要尽可能减少现象产生的原因，如果能减少到唯一的一个原因，那就能很明确问题所在。&lt;/p&gt;
&lt;h2 id=&#34;四告警分类&#34;&gt;四、告警分类&lt;/h2&gt;
&lt;p&gt;同样是告警，对于 CPU 跑满这种情况需要立即处理，但对于单机健康状态告警（正常异常机器会自动置换，异常情况可能置换失败），系统并不能自动解决这种状况，但是一段时间内不处理，也不会造成影响，负载均衡设备会自动摘除。&lt;/p&gt;
&lt;p&gt;所以这里涉及到一个告警分类的问题，当然，告警可以有很多种分类方法，分成很多种级别区别对待，但在优化无效告警的目标下，我们通过是否需要立即停下手头工作立即处理，分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;紧急&lt;/strong&gt;：收到报警就需要立即执行某种操作。如 CPU 跑满，内存跑满等。判断标准，是否对业务有影响，以及是否有潜在的未知风险&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不紧急&lt;/strong&gt;：系统并不能自动解决目前状况，但是一段时间内不处理，也不会造成影响。如单机出现访问不通异常。判断标准，对业务无影响，基本无潜在的风险，但最终需要人工介入处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不需要处理&lt;/strong&gt;：已知异常并且系统会自动恢复，不需要人工接入。如机器虽然出现异常，但运维底座会再一段时间内自动处理，不需要人工介入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个异常，首先需要判断是否需要立即处理，区分进行优化。&lt;/p&gt;
&lt;p&gt;对于不需要处理的异常，则完全没有必要进行告警。如果需要感知事件，可以通过邮件方式进行时候定时通知，无需通过告警渠道打断工作。&lt;/p&gt;
&lt;p&gt;对于不紧急的告警，如果工具支持的话，应该以工单的形式定时推送，统一处理，没必要进行实时告警，减少对正常工作的打断。在工具不支持的场景，可以适当调整告警间隔时间，以及重复告警的收敛策略。如单机异常可以整点告警，避免重复打断工作，当然，如果同时超过一定百分比的机器异常，这便转换为紧急告警了，需要实时触达。&lt;/p&gt;
&lt;p&gt;对于紧急告警，应该尽量提升其实时性和准确性，尽可能去除无效告警。那应该如何进行无效告警的识别和判断呢，接下来可以看一下告警设置的原则。&lt;/p&gt;
&lt;h2 id=&#34;五告警设置原则&#34;&gt;五、告警设置原则&lt;/h2&gt;
&lt;p&gt;每当告警发生时，值班同学需要暂停手头工作，查看告警。这种中断非常影响工作效率，增加研发成本，特别对正在开发调试的同学，影响很严重。所以，每当我们收到告警时，我们希望它能真实的反映出异常，即告警尽可能不误报（对正常状态报警）；每当有异常产生时，报警应该及时发出来，即告警不能漏报（错过报警）。误报和漏报总是一对矛盾的指标。&lt;/p&gt;
&lt;p&gt;以下是一些告警设置原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;告警具备真实性&lt;/strong&gt;：告警必须反馈某个真实存在的现象，展示你的服务正在出现的问题或即将出现的问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;告警表述详细&lt;/strong&gt;：从内容上，告警要近可能详细的描述现象，比如服务器在某个时间点具体发生了什么异常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;告警具备可操作性&lt;/strong&gt;：每当收到告警时，一般需要做出某些操作，对于某些无须做出操作的告警，最好取消。当且仅当需要做某种操作时，才需要通知&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新告警使用保守阈值&lt;/strong&gt;：在配置告警之初，应尽可能扩大监控告警覆盖面，选取保守的阈值，尽可能避免漏报。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;告警持续优化&lt;/strong&gt;：后续持续对告警进行统计分析，对误报的告警，通过屏蔽、简化、阈值调整、更精准的体现原因等多种方式减少误报，这是一个相对长期的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再以请求失败举例，如仅当请求的失败量超过某一阈值时告警，可能存在多种原因，如一些恶意构造的请求，也触发失败量告警。这样的告警既不具备真实性，也不具备可操作性，因为确实无需任何处理。对于此类情况，我们应该尽可能通过特性加以识别，从而更加精准的区分原因的告警。&lt;/p&gt;
&lt;h2 id=&#34;六善用工具&#34;&gt;六、善用工具&lt;/h2&gt;
&lt;p&gt;另外优化告警的一个必备条件，就是要熟悉所用告警平台使用，如果都不知道告警平台可以做到什么程度，可以设置怎样灵活的条件阈值，是很难对告警做合理优化的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控告警平台能做到什么：业务基础指标，系统基础指标，各种维度的统计方式&lt;/li&gt;
&lt;li&gt;告警阈值设置：如何电话/短信告警设置&lt;/li&gt;
&lt;li&gt;告警统计和趋势：有利于进行数据分析和优化告警&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以请求失败举例，告警平台是否可以区分不同原因类型告警，是否可以统计成功率告警，是否可以配置持续多久告警，是否可以配置环比同比条件告警；以及不同类型的阈值区分配置，不同条件下的短信，还是电话告警，短信一段时间未处理是否可以转换为电话通知，是否可以屏蔽重复告警等等。所有的特性都有利于我们设置一个精准的告警条件。&lt;/p&gt;
&lt;p&gt;另外平台提供的统计和趋势，有利于我们进行针对性优化，查看每天每周的 TopN 告警是什么，整体的趋势是什么样的，从而进行针对性优化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-13-22.png&#34;
	width=&#34;2806&#34;
	height=&#34;938&#34;
	srcset=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-13-22_hu6602699653685221263.png 480w, https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-13-22_hu14153978391679206386.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;299&#34;
		data-flex-basis=&#34;717px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;七告警处理流程&#34;&gt;七、告警处理流程&lt;/h2&gt;
&lt;p&gt;前面提到了告警的优化是一个持续的过程，不存在一劳永逸的事情。需要每天或者每周安排值班人员负责告警事宜，这点上确实是需要一定的投入。值班同学需要持续关注告警的有效性，对于出现的无效告警，分析清楚原因，持续优化阈值或者告警策略。&lt;/p&gt;
&lt;p&gt;合理的告警流转流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-13-33.png&#34;
	width=&#34;1688&#34;
	height=&#34;174&#34;
	srcset=&#34;https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-13-33_hu9448743948538008039.png 480w, https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%91%8A%E8%AD%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/2023-04-12-18-13-33_hu11685085295150633733.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;970&#34;
		data-flex-basis=&#34;2328px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;处理流程中，在告警触发后，通过短信/电话等方式触达，值班处理人接单处理，再接单后处理完成前，重复的问题不再触发告警，以避免大量的重复无效告警。确认原因后结单返回原因。&lt;/p&gt;
&lt;p&gt;可能受限于告警工具问题，不能严格的按照流程来推进（比如一次异常事件，由于告警平台不支持，处理过程中可能触发很多重复告警；系统没有反馈原因的流程等），但是值班同学心里需要有这样的流程，确保每条告警都是清清楚楚在哪个阶段，没有含糊其辞之处。&lt;/p&gt;
&lt;p&gt;另外值班同学要强调几点注意事项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;确保能够收到所有告警&lt;/strong&gt;：可以通过接收人组解决，确保所有值班同学都在一个接收人组，如果有人员变动也方便修改&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上升线路&lt;/strong&gt;：需要判断问题的严重性，适合时机上升，增加资源快速把问题消灭再萌芽状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;明确根本原因&lt;/strong&gt;：确保弄清楚问题原因，而不是表面上恢复。比如单台机器 CPU 跑满告警，可能存在未知的死循环问题，如果仅仅重启进程恢复，很可能掩盖了问题，导致未来出现大面积的死循环引发故障&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后告警的处理，在心态上要做到：凡事最好能在不疑处有疑，不能在有疑处不疑。&lt;/p&gt;
&lt;h2 id=&#34;参考引用&#34;&gt;参考&amp;amp;引用&lt;/h2&gt;
&lt;p&gt;《SRC：Google 运维解密》
《MTTR/MTTF/MTBF 图解》：https://blog.csdn.net/starshinning975/article/details/102893787
《一篇文章了解监控告警》：https://zhuanlan.zhihu.com/p/60416209
《准确率、精度和召回率》：https://www.cnblogs.com/xuexuefirst/p/8858274.html
《告警配置的一些原则和经验》http://wsfdl.com/devops/2018/02/07/configure_alarm.html&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SWIG 跨语言调用</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swig_cross_language_call/</link>
        <pubDate>Mon, 10 Apr 2023 22:40:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swig_cross_language_call/</guid>
        <description>&lt;h2 id=&#34;一跨平台调用&#34;&gt;一、跨平台调用&lt;/h2&gt;
&lt;p&gt;在开发过程中，尤其是对外提供的类库，往往需要跨平台/跨语言支持，跨平台的优势很明显，开发成本极大降低，测试成本也相应降低，多端逻辑对齐等。所以有很多跨平台方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web 流派&lt;/strong&gt;：PhoneGap&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;支持 UI 开发&lt;/li&gt;
&lt;li&gt;跨平台：PhoneGap 目前支持的移动平台有：Android, iOS, Windows Phone, Windows 8, Firefox OS, Amazon Fire OS, BlackBerry 10, Ubuntu, Tizen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;运行效率慢&lt;/li&gt;
&lt;li&gt;PhoneGap 支持 API 调用范围有限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码转换流派&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语言之间转换：Java-OC（J2ObjC）&lt;/li&gt;
&lt;li&gt;Haxe：中间语言，本身不能编译运行，只能转换为其他语言，支持 JavaScript, C++, C#, Java, JVM, Python, Lua, PHP, Flash 多种语言，以对应语言原生代码运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;编译流派&lt;/strong&gt;：C/C++，Go&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Golang（gobind）&lt;/li&gt;
&lt;li&gt;C/C++（java: jni，go: cgo, python: ctypes)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二swig-是什么&#34;&gt;二、SWIG 是什么&lt;/h2&gt;
&lt;p&gt;C/C++库提供给不同平台和不同语言使用，存在的一些问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配层工作量较大：取决于 API 数量&lt;/li&gt;
&lt;li&gt;易错：涉及底层数据类型的转换&lt;/li&gt;
&lt;li&gt;不同语言实现不同：如 Android 平台使用，就需要提供 Java 接口的支持，可以通过实现 JNI 胶水层连接；提供 Go 语言使用，需要 cgo 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SWIG 就是为了解决跨语言调用的问题产生的工具，考虑到胶水层的形式固定，有利于通过代码自动生成，SWIG 就应运而生，作为一种提升效率的开发工具，它将用 C 和 C++ 编写的程序与各种高级编程语言连接起来。&lt;/p&gt;
&lt;h2 id=&#34;三swig-能做什么&#34;&gt;三、SWIG 能做什么&lt;/h2&gt;
&lt;p&gt;自动生成 C/C++代码不同高级语言的封装（胶水层），支持的语言 ：C#, D, Go, Guile, Java, Javascript, Lua, MzScheme/Racket, OCaml, Octave, Perl, PHP, Python, R, Ruby, Scilab, Tcl&lt;/p&gt;
&lt;p&gt;支持 ISO C99：所有的数据类型，指针、枚举、结构体、数组、typedef 等
支持 ISO C++98 to C++17：类，继承和多重继承，重载、静态方法、名字空间、模板、嵌套类、STL 等&lt;/p&gt;
&lt;p&gt;文档生成：支持 Doxygen 注释生成对应目标语言的文档（Java、Python）&lt;/p&gt;
&lt;h2 id=&#34;四show-一些例子&#34;&gt;四、Show 一些例子&lt;/h2&gt;
&lt;h3 id=&#34;1-java-调用-c-最简单例子&#34;&gt;1. Java 调用 C 最简单例子&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: tools.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;TestFunction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: tools.i
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;TestFunction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: main.java&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/home/bo.deng/libtest.so&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;TestFunction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;swig -java tools.i
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcc -c -fPIC tools.c tools_wrap.c -I/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.1.alios7.x86_64/include -I/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.1.alios7.x86_64/include/linux/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcc -shared tools.o tools_wrap.o -o libtest.so
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;javac main.java
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;java main
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-c-回调&#34;&gt;2. C++ 回调&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: include/shape.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#ifndef SHAPE_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define SHAPE_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Param&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;one&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;two&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Param&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Painter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drawShape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// SHAPE_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: src/shape.cpp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;shape.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Painter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;drawShape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Param&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;one&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;testddd&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;two&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;ddd&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;call java over&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: shape.i
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;directors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drawing&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;feature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;director&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;include/shape.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;std_string.i&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;include/shape.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;director 指令允许目标语言从当前类派生。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: main.java&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;com.test.shape.Shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;com.test.shape.Painter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;com.test.shape.Param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Circle&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Param&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getOne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getTwo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;drawing a circle&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getProperty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;user.dir&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/libdrawing.so&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;start...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Painter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;painter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Painter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;painter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;drawShape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Circle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;end...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main thread&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mkdir -p com/test/shape/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	swig -c++ -java -package com.test.shape -outdir com/test/shape/ shape.i
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	g++ -fPIC -c src/shape.cpp -Iinclude
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	g++ -fPIC -c shape_wrap.cxx -I/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.1.alios7.x86_64/include -I/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.1.alios7.x86_64/include/linux/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	g++ -shared shape.o shape_wrap.o -o libdrawing.so
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mkdir jar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	javac -d jar/ -sourcepath . com/test/shape/*.java
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	jar cf drawing.jar -C jar/ .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	javac -classpath drawing.jar main.java
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	java -classpath drawing.jar:. main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -rf com
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -rf jar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -f shape_wrap.cxx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -f shape_wrap.h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -f *.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -f *.so
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -f *.jar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -f *.class
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rm -f drawing_wrap.*
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3-go-语言调用&#34;&gt;3. Go 语言调用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// File: main.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;./drawing&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Cicle&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Cicle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Draw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;drawing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;callback:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetOne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetTwo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;cicle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Cicle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;cicle is &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cicle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;painter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;drawing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewPainter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;drawing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewDirectorShape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cicle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;painter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DrawShape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;drawing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DeleteShape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;drawing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DeletePainter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;painter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir drawing
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;swig -go -cgo -c++ -intgosize &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; -outdir drawing shape.i
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;GO111MODULE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;off go run main.go
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C/C++代码不用修改，跟 Java 的区别在于 Go 应用层逻辑 以及 编译命令不同。&lt;/p&gt;
&lt;h2 id=&#34;五其他高级功能&#34;&gt;五、其他高级功能&lt;/h2&gt;
&lt;p&gt;参阅文档：https://www.swig.org/Doc4.0/Contents.html#Contents&lt;/p&gt;
</description>
        </item>
        <item>
        <title>腾讯-育龙培训感悟</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/management-training-sentiment/</link>
        <pubDate>Sat, 26 Sep 2015 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/management-training-sentiment/</guid>
        <description>&lt;p&gt;育龙培训，通过读书、小组嘉宾采访和为期一天半的集中培训，受益良多，培训中讲师通过各种活动以及理论的讲解，深入浅出的解释了从一个技术骨干到管理者转身所必须的知识。其中有几点感触很深。&lt;/p&gt;
&lt;h1 id=&#34;什么是管理&#34;&gt;什么是管理&lt;/h1&gt;
&lt;p&gt;通过计划、组织、领导、控制四大环节来有效协调人、财、物等各类资源，以期达到组织目标的过程。通过组织，可以把松散的人员凝聚在一起，发挥1+1&amp;gt;2的效果，需要管理者有效的协调各种资源，使团队积极的朝着明确的目标前进。&lt;/p&gt;
&lt;h1 id=&#34;横向管理&#34;&gt;横向管理&lt;/h1&gt;
&lt;p&gt;管理者在工作中起到承上启下的作用，但在工作中容易忽略的而又非常重要的一点，就是横向管理，上下级之间、以及平级之间都需要逐步建立信任关系，工作之间建立一些友情，可以增加信任度，很多时候需要获取的各种资源，都需要横向管理获取，同级之间的横向信任是非常重要不可忽视的一个方面。&lt;/p&gt;
&lt;h1 id=&#34;目标重要性&#34;&gt;目标重要性&lt;/h1&gt;
&lt;p&gt;目标的重要性怎么强调都不过分，从公司的战略方向，部门的目标，组内的任务，以及组内成员个人之间目标和任务，都需要有一个清晰的规划和认识，带领团队首先就是要有目标，没有目标整个团队就没有方向，其次就是团队中每个人员的分工，每个人员都需要有明确的上升空间和发展空间，属于自己的职责和方向。&lt;/p&gt;
&lt;p&gt;团队有了清晰明确的目标，才能相互协作互补，发挥最大的价值，个人有了目标，才能更加积极的投入到工作中。团队的目标需要向上沟通，横向沟通等方法，明确组织方向，集思广益。向下制定目标，可以跟员工一对一沟通，让员工草拟计划，再进行沟通的方式，了解员工需求，以及让员工更加清楚的理解目标。&lt;/p&gt;
&lt;h1 id=&#34;技术角色抓换问题&#34;&gt;技术角色抓换问题&lt;/h1&gt;
&lt;p&gt;技术角色向管理角色转变时，最容易出现的问题就是超级业务员问题，技术方面业绩很好，往往发现教人去完成一项任务不如自己去做来得快，容易所有的事情都亲力亲为，过多的关注细节，会忽略其他更为重要的事情，需要懂得并合理的授权，合理管理和分配自己的时间，通过过程控制和流程控制等方法把控质量。&lt;/p&gt;
&lt;h1 id=&#34;过程控制&#34;&gt;过程控制&lt;/h1&gt;
&lt;p&gt;分解工作任务并授权后，需要采用阶段性检查、周期性检查、非正式场合检查等等方式，对于项目，需要了解节点的完成情况，各项资源是否到位，对风险的预防措施，对于人员，需要了解完成该项任务的意愿以及能力。实时了解任务进展，能够即时了解风险，发现问题，并调整策略。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>课程设计与开发入门</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/curriculum-development/</link>
        <pubDate>Fri, 25 Sep 2015 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/curriculum-development/</guid>
        <description>&lt;p&gt;学习知识的过程分为几个阶段，学习、应用、共享、创新。在上学的时候，我们多数情况都在不断的学习知识，工作以后，更多的是实践中锤炼自身的技艺，但能够做到开发课程去传承共享知识的人很少，工作中遇到的同事，如果经常写博客，参与一些开源项目等，技术往往比一般人更胜一筹，想做到共享知识，需要对知识的掌握和理解比会用更深入，而开发一门新的课程甚至写一本书，往往比写几篇博客更难，写博客需要理解一个点即可，而开发课程需要对知识体系有着完整的理解，甚至在讲课的过程中，需要实时的表达呈现方式，而且随时面对学员的提问，比写书在技巧性上又难了一些。&lt;/p&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;在印象中，往往认为讲师比较重要，好的讲师和不好的讲师差别很大，其实不尽然，最为一个好的课程设计，需要设计如何去讲，之间的起承转合，如何互动，如何检验学习效果，课件只是课程设计中很小的一个方面，如果只是设计一个课件，这时候讲师的作用就凸显出来了，所以往往我们看到的是讲师讲的很好，这只是因为课程开发的不完全而已。&lt;/p&gt;
&lt;p&gt;对成人授课，往往难度更大，成人原本知识经验都比较丰富，要进行讲授，必须要有更优质的内容，再腾讯培训一些技术课程的时候，往往觉得讲师讲的内容不好，而学习一些 HR 或者管理课程时，觉得收获颇丰，这也与自身的背景有关，如果不能提供给学员他们所不懂的更好的内容的时候，不管讲师如何出众，都无法扭转败局。而且，成人听课往往更关心如何应用于实践，是否能快速结合自身的项目进行应用这个非常重要。&lt;/p&gt;
&lt;h1 id=&#34;课程开发步骤&#34;&gt;课程开发步骤&lt;/h1&gt;
&lt;p&gt;课程开发可以分为七步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求分析&lt;/li&gt;
&lt;li&gt;知识萃取&lt;/li&gt;
&lt;li&gt;大纲搭建&lt;/li&gt;
&lt;li&gt;素材采编&lt;/li&gt;
&lt;li&gt;开场设计&lt;/li&gt;
&lt;li&gt;讲授设计&lt;/li&gt;
&lt;li&gt;结尾设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;需求分析&#34;&gt;需求分析&lt;/h2&gt;
&lt;p&gt;需求分析阶段的任务就是调查，了解一切与自己的学员相关的东西，知己知彼才能百战百胜。很多人讲授之前都不去进行需求分析，盲目的拍脑袋决定讲授什么内容学员收获最多，这样会提升讲课失败的概率。&lt;/p&gt;
&lt;p&gt;这里说到了解学员，往往很多人在讲授之前都去对学员做问卷调查，这当然是一种方法，不过如果只寄希望于通过学员来了解需求，是远远不够的。很多情况下，学员其实并不知道自己了解多少，想要了解什么，如果了解很多，可能也不需要来听这门课程了。通过学员只能在很浅的程度上了解需求。&lt;/p&gt;
&lt;p&gt;那应该如何做好需求分析呢？有两个因素，第一个是向谁去做需求分析，另一个怎么做需求分析。关于人，可以是学员，以及学员的上级，课程方面的专家，以及曾经学习过的一些典型的学员，要进行多纬度的了解。关于怎么做，可以了解培训的期望，学员的现状，学习的路径。了解了现状和目标，课程要做的就是弥补现状和目标之间的鸿沟。&lt;/p&gt;
&lt;h2 id=&#34;知识萃取&#34;&gt;知识萃取&lt;/h2&gt;
&lt;p&gt;知识萃取是整个课程设计中需要耗费最多精力的一步，知识萃取常见的错误是不进行知识的萃取，另一个是萃取的不到位。&lt;/p&gt;
&lt;p&gt;首先要了解的是知识萃取的分类，要讲述的内容是哪种类型的，分类之后便可使用更通用的规则进行提炼，知识分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知识：事实概念型&lt;/li&gt;
&lt;li&gt;态度：态度认知类&lt;/li&gt;
&lt;li&gt;技能：步骤情景类 &amp;amp; 分析决策类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中事实概念型的讲述方案：是什么、不是什么、有什么（分类，例子）、最什么（优势劣势），用于干什么（应用的场景）
态度认知类讲述方案：陈述后果，好处，信息，角色（正反两方面讲述）
步骤情景到要点：步骤，目标，要点，工具，对策
分析决策到方案：分解，分析，对策&lt;/p&gt;
&lt;h2 id=&#34;大纲搭建&#34;&gt;大纲搭建&lt;/h2&gt;
&lt;p&gt;课程大纲为了很好的展示整个课程的全貌，很多人没有大纲或者大纲逻辑顺序混乱，不方便学员记忆，又或者是深度不够，都是不行的，大纲搭建可以通过三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写大纲到三级：一级到场景，二级（why，what，how），三级深入萃取&lt;/li&gt;
&lt;li&gt;逻辑清晰码顺序：时间/步骤顺序，并列顺序，why-what-how 演绎顺序，内在的逻辑顺序类比自然界方式&lt;/li&gt;
&lt;li&gt;模型提炼好记忆：口诀法，缩略词法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;素材采编&#34;&gt;素材采编&lt;/h2&gt;
&lt;p&gt;开开发课程中，往往容易忽略素材的作用，选用很单一的素材或者素材不够精细。直接将内容不就行了，为什么要丰富的素材呢，这就要说到 90-20-8 法则，成年人能够带着理解认真吸收知识的时间是 90 分钟，而其中能够带着吸收的心智倾听的只有 20 分钟，每 8 分钟精力就会分散。如果没有合适有趣的素材进行注意力的吸引，效果往往会比较差。&lt;/p&gt;
&lt;p&gt;那应该如何进行素材的采编呢&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采编概念素材：可以通过打比方，找相似的方法，在现实世界中找到匹配的表达，或者一个电影片段，或者一个事物&lt;/li&gt;
&lt;li&gt;采编案例素材：举例子，五必问（背景、冲突、人物选择和行动、结果、评价）&lt;/li&gt;
&lt;li&gt;厘清课程素材：先开始，后来源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;丰富的素材能够激发学员的学习动力，可以有文字、图标、图片、音频、视频等等。这需要在日常生活中，注意留意生活，随时记录所需要的素材，如果到开讲前再去收集素材往往难以找到贴切的素材。&lt;/p&gt;
&lt;h2 id=&#34;开场设计&#34;&gt;开场设计&lt;/h2&gt;
&lt;p&gt;很多人讲课没有开场设计，单刀直入，或者不是基于教学内容单单为了吸引注意力，或者不理解学员的关注点等等，都是不好的方式，开场设计主要把大家的注意力吸引到课程中来，而且提起大家的学习兴趣，同时预告课程的安排和所要达成的目标。这样学员学习起来会更加清楚。&lt;/p&gt;
&lt;p&gt;好的开场设计可以分为三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;课程内容与学员连接：可以以一个直击痛点的案例，或者一个引发好奇的提问&lt;/li&gt;
&lt;li&gt;讲师和学员连接：讲师的介绍，主要在于破冰和托起&lt;/li&gt;
&lt;li&gt;预告课程的安排和目标：打造有图有真相的课程，安排与目标的预告&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外开场设计可以做一些互动游戏，合理的游戏需要耗费讲师不少的心血。&lt;/p&gt;
&lt;h2 id=&#34;讲授设计&#34;&gt;讲授设计&lt;/h2&gt;
&lt;p&gt;课程讲授过程是一个呈现的过程，课程讲授活动设计分为三个阶段：激活旧知（打比方，举例子，做对比，逆转换）、引入新知、练习反馈。很多课程中都缺少练习反馈的过程，如果有合适的练习和反馈，学员学到的东西将会更加牢固理解更加深入。&lt;/p&gt;
&lt;h2 id=&#34;结尾设计&#34;&gt;结尾设计&lt;/h2&gt;
&lt;p&gt;结尾设计的目的在于回顾和总结，强化之前的记忆，让整个体系更加完整的呈现在学员面前，有一些通用的方法，比如知识卡片，通过知识卡片总结，一人一句，你问我答，脑图回顾等等。&lt;/p&gt;
&lt;h1 id=&#34;深入学习&#34;&gt;深入学习&lt;/h1&gt;
&lt;p&gt;经典书籍：
《雇员培训与开发》 人民出版社  诺伊
《交互式培训》 企业管理出版社 斯托洛维奇
《SAM 课程设计与开发手册》 电子工业出版社 查理德-塞茨
《金字塔原理》 民主与建设出版社 芭芭拉明托
《博弈心理学》 北京联合出版公司 内藤谊人&lt;/p&gt;
&lt;p&gt;网站：
中人网 &lt;a class=&#34;link&#34; href=&#34;http://www.chinahrd.net&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.chinahrd.net&lt;/a&gt;
培训人社区  &lt;a class=&#34;link&#34; href=&#34;http://51clo.net&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://51clo.net&lt;/a&gt;
中训网 &lt;a class=&#34;link&#34; href=&#34;http://www.traningmag.com.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.traningmag.com.cn&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>腾讯-育龙-cola访谈记录</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/interview-cola/</link>
        <pubDate>Thu, 24 Sep 2015 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/interview-cola/</guid>
        <description>&lt;p&gt;育龙cola访谈记录&lt;/p&gt;
&lt;p&gt;时间 2015年9月24日，地点万利达303&lt;/p&gt;
&lt;h2 id=&#34;问题请问您刚上任时印象最深刻的困难是什么您是如何应对的&#34;&gt;问题：请问您刚上任时，印象最深刻的困难是什么，您是如何应对的？&lt;/h2&gt;
&lt;p&gt;答：刚上任的时候，当时是新的团队负责新的项目，最困难的是没有人，需要快速招人负责项目。&lt;/p&gt;
&lt;h2 id=&#34;问题您自从带团队以来团队管理的心得是什么&#34;&gt;问题：您自从带团队以来，团队管理的心得是什么？&lt;/h2&gt;
&lt;p&gt;答：带团队和带项目有些类似，但带团队更难，带团队需要管人，人的差异性更大。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带团队首先需要有目标，没有目标整个团队就没有方向。其次团队中每个人要分工明确，&lt;/li&gt;
&lt;li&gt;每个人都有自己负责的部分，理想的情况每个人都有明确的项目分配，并且都有同等的上升和发展空间，团队中都有属于自己的合适的位子和方向。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中最重要的是目标，个人的目标与个人的KPI挂钩，个人的KPI又与团队的核心目标挂钩，如果年终的时候不知道如何打考评，肯定是年初的KPI没有定好，团队的核心目标没有明确。&lt;/p&gt;
&lt;h2 id=&#34;问题请问如何在未授权的情况下带领同事完成目标&#34;&gt;问题：请问如何在未授权的情况下带领同事完成目标？&lt;/h2&gt;
&lt;p&gt;答：SNG向来有此传统，未授权的情况下先担负义务，有1-2年的leader考核期，如果任命leader，担任了管理职责，向下管理会方便很多，在不认命的情况下承担义务，特别考量一个人的管理情商和智商，如何应对平级管理的各种问题，如何管理资历老的员工，都会成为挑战，如果处理不好跟资历老的员工之间的关系，轻则离职，重则整个团队就会散了。&lt;/p&gt;
&lt;p&gt;从参加育龙项目开始，就会跟组员之间的关系发生微秒的变化，需要向leader和组员学习。&lt;/p&gt;
&lt;p&gt;一些具体的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;出现问题需要第一时间站出来，牵头去完成相应的项目；&lt;/li&gt;
&lt;li&gt;育龙项目的开始就是考核的开始，从育龙开始，可能会受人关注，自己的言行将会决定是否能够胜任leader；&lt;/li&gt;
&lt;li&gt;成为leader周围同事以及相关部门同事的意见很重要，要懂得如何向上管理，向下管理，横向管理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题新任的leader普遍哪些方面会做的不好&#34;&gt;问题：新任的leader，普遍哪些方面会做的不好？&lt;/h2&gt;
&lt;p&gt;答：非常常见的问题是角色转换，做为leader，管理任命之前，都是负责业务的一把好手，业绩很好，往往发现教人去完成一项任务不如自己去做来的快，容易做所有的事情都亲力亲为。做为管理者，需要对上级下级沟通，对内外部门沟通，过多的关注业务，会忽略其他更重要的事情，合理的分配自己的时间非常重要。&lt;/p&gt;
&lt;p&gt;教给下级任务，可以使用一些check表格的方法，一项项填写，通过规章流程可解决大部分的下级工作质量问题，有时间尽可能把业务模块化，模版化。&lt;/p&gt;
&lt;p&gt;另外，做为leader需要关心招聘，一定要了解自己的人员，人员是否适合自己的团队，做为leader，自己个人的高低已经显得不再重要了，自己团队的高低才是更应该关注的，团队的高低往往取决于团队中最差的人员。&lt;/p&gt;
&lt;h2 id=&#34;问题如果成员和你发生意见不统一且认为之前的leader与她更契合这时该如何处理&#34;&gt;问题：如果成员和你发生意见不统一，且认为之前的leader与她更契合，这时该如何处理。&lt;/h2&gt;
&lt;p&gt;答：首先要看这个人的能力是否团队中不可或缺的，能够给团队带来利益。团队中适应时间有长有短，对于毛刺的人，要看是不是一种“坏人”，说的问题是否有道理，这将会是另一种挑战和考核，能够合理的处理这种人，将会体现管理情商。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是情绪问题，可以利用一些有效沟通的方法，比如一起喝酒，一起出去活动等，尽量把话说开，沟通非常重要，沟通好了，这种问题便很容易解决；&lt;/li&gt;
&lt;li&gt;如果是因为老员工面子问题，可以给予对方足够的尊重，在重要的事情上多进行讨教，让对方觉得自己受倚重；&lt;/li&gt;
&lt;li&gt;如果是纯属给团队传播负能量，不能提供正向的促进，这种情况需要第一时间上升，跟自己的leader商量，进行上升处理；&lt;/li&gt;
&lt;li&gt;如果单纯的是跟之前的leader做法不一致导致不适应，可以进步一沟通，人跟人没有一模一样的，而且很多时候两人做法比较有默契是因为时间问题，可以沟通，说明白问题，相处一段时间，逐渐建立彼此的新任；&lt;/li&gt;
&lt;li&gt;如果是新任的leader，或者空降的leader，在团队中的信任感是零，容易产生各种误解，要及时的把误解说开，沟通是非常重要的，可以快速建立彼此的信任；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的一些沟通方法，比如可以一起吃饭，活动，爬山，这样不仅可建立自己跟下级之间的信任，也可以使下级团队更加有凝聚力。另外很多人都有各种“隐藏”的才能，挖掘这种才能能够使他更加活跃，能够更好的融入团队。组长活跃的话能够带动组内活跃气氛，气氛活跃能够缓解情绪问题。&lt;/p&gt;
&lt;p&gt;另外，工作和朋友有时并不一定要分的很开，可以有一定交叉，工作之间建立一些友情，可以建立信任度，同级之间的横向管理横向信任是非常重要不可忽视的一个方面。&lt;/p&gt;
&lt;h2 id=&#34;问题如何进行向上管理对于老板安排的任务如果觉得不合理应如何处理&#34;&gt;问题：如何进行向上管理，对于老板安排的任务，如果觉得不合理，应如何处理？&lt;/h2&gt;
&lt;p&gt;答：最重要的一句话：站在领导的位子上想问题。很多时候自己觉得不合理，90%以上的情况是因为自己有些信息没有掌握导致的，这里可以私下沟通，老板能够告诉的会尽量告诉，有些情况不能说的，也不用问，只要去做好交代的任务，过一周、一个月，可能有些信息暴漏出来，就会理解当时的做法了。&lt;/p&gt;
&lt;p&gt;比如之前在空间投放搜狗浏览器的广告，而且是免费的，做任务的人就很不理解，为什么要帮一个毫不相关的产品。后面发现腾讯入股搜狗，一切不理解便成为理解了。&lt;/p&gt;
&lt;p&gt;所以有些时候可以私下跟领导沟通，如果实在不能告诉，只让把这件事做好，那就应该积极的做好这件事情，等到过段时间，可能便会顺理成章的做法了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux性能调优之内核篇</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/linux-performance-kernel/</link>
        <pubDate>Thu, 03 Jul 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/linux-performance-kernel/</guid>
        <description>&lt;h1 id=&#34;进程管理&#34;&gt;进程管理&lt;/h1&gt;
&lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;p&gt;进程管理是操作系统一个重要的内容，包括进程调度，中断管理，信号，进程优先级，进程状态和切换，进程内存管理等各个方面。进程是可执行文件在系统中的执行实例，内核中的表达为&lt;code&gt;task_struct&lt;/code&gt;，包含了进程的所有信息。&lt;/p&gt;
&lt;p&gt;进程可通过fork一份相同的进程，具有fork之前完全一样的状态。fork的性能在 60-8000/s。之所以有这么大的跨越，在于不同的进程使用了不同数量的页表，如果进程使用内存很少，页表数量很少，fork的性能便会很高，如果进程映射的内存很多，页表数量很多，fork虽然由于写时复制的优化，可以不进行内存的复制，但还是需要复制页表，会导致性能急剧下降。&lt;/p&gt;
&lt;p&gt;而单CPU的进程之间的切换性能，在30w-100w/s之间。K级以上并发，稳定在30w/s左右。&lt;/p&gt;
&lt;p&gt;更加详细的内容可查阅Linux内核代码，&lt;a class=&#34;link&#34; href=&#34;../linux_kernel/linux-kernel-process-sched/&#34; &gt;进程调度&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;p&gt;线程可以认为是更轻量级的进程，线程与进程的区别在于线程之间可共享资源，除了栈空间独享以外，其他的资源如内存空间，文件，都可以共享。&lt;/p&gt;
&lt;p&gt;线程可通过&lt;code&gt;pthread_create&lt;/code&gt;创建，由于共享内存等资源，所以性能会更高，创建性能在5w-10w/s，随着并发数的增加而降低，并发1w创建性能会稳定在5w/s。&lt;/p&gt;
&lt;p&gt;线程切换的效率，单CPU切换在50w-150w之间，K级以上并发，稳定在50w/s左右。&lt;/p&gt;
&lt;h2 id=&#34;中断&#34;&gt;中断&lt;/h2&gt;
&lt;p&gt;进程管理中，中断也是非常重要的一个方面，目前的中断信息，可通过虚拟文件系统&lt;code&gt;/proc/interrupt&lt;/code&gt;查看。对于多核CPU，之前的内核版本有出现过中断在一个CPU，处理网络包导致单CPU过载的情况。&lt;/p&gt;
&lt;h1 id=&#34;函数调用&#34;&gt;函数调用&lt;/h1&gt;
&lt;p&gt;函数调用分为两种，一种有系统调用，跟普通函数调用的区别在于系统调用会进行内核态和用户态的切换，性能略有下降，以架构师的水准要求自己，需要了解主要函数调用的瓶颈。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;函数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;性能(次/S)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ntohl&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2.5亿&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;memset 1k&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;150w&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;getppid&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1000w&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;getimeofday&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;30w-400w&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;socket&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;10w-50w&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;sendto&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;40w&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;更详细系统调用相关内容，可参考：&lt;a class=&#34;link&#34; href=&#34;../linux_kernel/reading/linux-kernel-system-call/&#34; &gt;系统调用&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;文件系统&#34;&gt;文件系统&lt;/h1&gt;
&lt;p&gt;文件系统是一个复杂的系统，其包含的模块也非常丰富，对于性能来讲，需要了解的是文件系统和硬件之间有一层 Page Cache，当读写文件时，并不一定非要从磁盘读取，如果 Page Cache 中存在，直接操作Cache层，性能会有大幅提高。但同时存在的一个问题是，如果只写入Cache层，当系统宕机后写入的内容将会丢失，内核启用pdflush进程进行后台回写，当到达一定条件就把Cache层的变更写入硬件，系统函数&lt;code&gt;fsync&lt;/code&gt;可以把更改写入磁盘，对数据安全性要求非常高的模块，就必须更改完成后调用&lt;code&gt;fsync&lt;/code&gt;把数据刷入磁盘硬件，当然，由于绕过了Cache系统，性能会大幅下降，而且会造成系统性能的不稳定。&lt;/p&gt;
&lt;p&gt;在&amp;rsquo;/proc/vm&amp;rsquo;文件系统下，有参数进行设置系统执行pdflush的执行条件。&lt;code&gt;dirty_background_ratio&lt;/code&gt;表示脏页占内存多少比例时，开始进行回收。&lt;code&gt;dirty_expire_centisecs&lt;/code&gt;表示当脏页存在多长时间以后回收。&lt;/p&gt;
&lt;h1 id=&#34;系统指标&#34;&gt;系统指标&lt;/h1&gt;
&lt;p&gt;Linux系统可以查看各种执行参数，不同的参数对应不同子系统的性能状况，了解哪些参数是需要了解的，哪些参数对应的含义，是了解当前系统执行性能必须要了解的，下面逐一查看各项指标的含义。&lt;/p&gt;
&lt;h2 id=&#34;cpu&#34;&gt;CPU&lt;/h2&gt;
&lt;p&gt;判别CPU当前执行效能，可通过以下指标查看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU利用率：CPU利用率直接体现了CPU使用情况，长期处于80%到90%以上，可能CPU出现瓶颈&lt;/li&gt;
&lt;li&gt;用户态时间：展现了CPU用户态的执行时间&lt;/li&gt;
&lt;li&gt;系统时间：展现了内核态执行时间&lt;/li&gt;
&lt;li&gt;Waiting：等待时间，如果出现大量的等待，IO可能出现瓶颈&lt;/li&gt;
&lt;li&gt;Context switch：上下文切换&lt;/li&gt;
&lt;li&gt;Interrupts：中断&lt;/li&gt;
&lt;li&gt;Load average：等待CPU的进程队列大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存&#34;&gt;内存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;空闲内存&lt;/li&gt;
&lt;li&gt;swap使用大小&lt;/li&gt;
&lt;li&gt;Buffer和Cache大小&lt;/li&gt;
&lt;li&gt;Slabs 大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;收包和发包量&lt;/li&gt;
&lt;li&gt;收包和发包大小&lt;/li&gt;
&lt;li&gt;丢包量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磁盘&#34;&gt;磁盘&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;iowait，CPU等待IO时间&lt;/li&gt;
&lt;li&gt;平均等待时间&lt;/li&gt;
&lt;li&gt;执行时间&lt;/li&gt;
&lt;li&gt;write和read每秒次数&lt;/li&gt;
&lt;li&gt;write和read每秒大小&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linux性能调优之硬件篇</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/linux-performance-hardware/</link>
        <pubDate>Wed, 02 Jul 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/linux-performance-hardware/</guid>
        <description>&lt;h2 id=&#34;cpu性能&#34;&gt;CPU性能&lt;/h2&gt;
&lt;p&gt;早期工程师热衷于提升单核CPU的性能，但随着时间发展，很快就意识到，仅仅提升单核性能会产生过多的热量而且无法带来相应的性能改善，于是多核的时代便来临了。&lt;/p&gt;
&lt;p&gt;经典的多核CPU架构为SMP，在一个计算机上汇集一组CPU，他们之间对称工作，无主次或者从属关系，共享相同的物理内存及总线。每个CPU可以有多个核心，每个核心有各自的L1d Cache（L1指令缓存）及Lli Cache（L1指令缓存），同一个CPU的多个核心共享L2及L3 Cache。不同的CPU共享系统总线和内存地址。&lt;/p&gt;
&lt;p&gt;SMP架构主要的特征就是共享，共享系统中的所有资源，内存，IO，由于多CPU对前端总线的竞争，SMP的扩展能力非常有限，所以目前主流服务器架构一般为 NUMA。系统有多个NUMA节点，每个节点是一个SMP结构，并且具有独立的本地内存，IO槽口等。&lt;/p&gt;
&lt;p&gt;NUMA节点可以快速访问本地内存，也可以通过NUMA互联模块访问其他NUMA节点的内存，但访问本地内存的速度远远高于远程访问速度，所以，应用开发过程中，需要尽可能减少不同NUMA节点之间的通信。&lt;/p&gt;
&lt;h2 id=&#34;io-总线&#34;&gt;IO 总线&lt;/h2&gt;
&lt;p&gt;很多存储系统的瓶颈都在于IO，以Intel x48主板为例，是典型的南、北桥架构，北桥芯片通过前端总线与CPU相连，内存模块，以及PCI-E设备（如高端SSD设备Fusion-IO）挂接在北桥上，北桥和南桥通过DMI相连，DMI宽带为1G/s，网卡，硬盘，以及中低端固态硬盘挂接在南桥上，如果采用SATA2接口，最大宽带为300M/s。&lt;/p&gt;
&lt;h2 id=&#34;磁盘&#34;&gt;磁盘&lt;/h2&gt;
&lt;p&gt;磁盘读写性能分两个部分，一个是磁头的移动，一个是读写效率，性能瓶颈主要在于磁头的移动。15000转的SATA盘的顺序读取宽带可以达到100MB以上，由于磁头寻道时间大约10ms，顺序读取1MB数据的时间为：磁盘寻址时间+数据读取时间=20ms。应用程序设计时要考虑随机读写的问题，尽量要减少磁盘的读写，或者把随机读写转化为顺序读写。&lt;/p&gt;
&lt;p&gt;固态硬盘SSD的应用越来越广泛，SSD特点是随机读取延迟小，能够提供很高的IOPS（每秒读写性能）。主要问题在于容量有限，价格较高，而且容易损坏。&lt;/p&gt;
&lt;p&gt;不同存储的对比如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;类别&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;IOPS&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;每GB价格（元）&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;随机读取&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;随机写入&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;内存&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;千万&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;150&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;友好&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;友好&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SSD盘&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;35000&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;20&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;友好&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;写入放大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SAS磁盘&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;180&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;磁盘寻道&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;磁盘寻道&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SATA磁盘&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;90&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0.5&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;磁盘寻道&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;磁盘寻道&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;p&gt;传统的网络数据中心是三层的拓扑结构，分为核心层、汇聚层和接入层。接入层交换机包含48个1G端口以及4个10G的上行端口，汇聚层以及核心层的交换机包含128个10G的端口。统一个接入层下的服务器之间宽带为1G，不同接入层交换机下的服务器之间的宽带小于1G，由于同一个接入层的服务器常部署于在一个机架，应用设计的时候需要考虑服务是否在一个机架内。&lt;/p&gt;
&lt;p&gt;为了减少系统对网络拓扑结构的依赖，Google将网络修改为扁平化拓扑结构，三级CLOS网络，同一个集群内最多支持20480台服务器，任何两台机器之间有1G宽带，方便将整个集群做成一个资源池。&lt;/p&gt;
&lt;p&gt;单机房内网络来回1ms左右，北京和深圳之间，网络来回延迟达到30ms以上。&lt;/p&gt;
&lt;h2 id=&#34;性能参数&#34;&gt;性能参数&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;类别&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;延迟&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;访问 L1 Cache&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0.5ns&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;分支预测失败&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;5ns&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;访问 L2 Cache&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;7ns&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Mutex锁操作&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;100ns&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;内存访问&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;100ns&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;千兆网络发送1MB数据&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;10ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;从内存顺序读取1MB数据&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0.25 ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;机房内网络来回&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0.5ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;异地机房来回&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;30-100ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SATA磁盘寻道&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;10ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;从SATA磁盘顺序读取 1MB 数据&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;20ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;固态SSD访问延迟&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;01-0.2ms&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        </item>
        <item>
        <title>Linux性能调优之工具篇</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/linux-performance-monitor-tools/</link>
        <pubDate>Tue, 01 Jul 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/linux-performance-monitor-tools/</guid>
        <description>&lt;p&gt;在Linux性能调优之前，首先需要了解当前服务的运行状态，找到程序瓶颈，这就需要用到Linux上一系列性能监控工具，以下对常用工具做一些总结。&lt;/p&gt;
&lt;p&gt;先来看一张各种工具的图谱，要想了解这张图中所有工具的确切含义，需要对Linux操作系统，以及内核实现有着一定的了解，所有的工具，都可以man具体的使用细节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/pKopgkk.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;323&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;top&#34;&gt;top&lt;/h2&gt;
&lt;p&gt;top 工具是查看进程信息的常用工具，默认情况下，进程显示会按照cpu负载排序，也可以按照pid，time和内存使用率进行排序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;53&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;411&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;days&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;55&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;nb&#34;&gt;load&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;average&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2.75&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2.65&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2.43&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Tasks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;233&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;running&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;232&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sleeping&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stopped&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zombie&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;19.9&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;us&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;4.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ni&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;71.9&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;2.7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;1.5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;si&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Mem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;8052640&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;8001296&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;used&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;51344&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;51668&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Swap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;2104504&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;25832&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;used&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;2078672&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;6776596&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cached&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;PID&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;USER&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;PR&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;NI&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;VIRT&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;RES&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;SHR&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CPU&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MEM&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;TIME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;COMMAND&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;18161&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mqq&lt;/span&gt;       &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3796&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.7&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;927&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;166&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;22.1&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;9171&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IphonePushServi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;mi&#34;&gt;830&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mqq&lt;/span&gt;       &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;342&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;199&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;198&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;23&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;2.5&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;49542&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;VideoRelay&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;mi&#34;&gt;1342&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;admin&lt;/span&gt;     &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;     &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;209&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;54.07&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;32390&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mqq&lt;/span&gt;       &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;502&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5164&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2524&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;0.1&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;162&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;26.01&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tafnode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;16238&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mqq&lt;/span&gt;       &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;5664&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1320&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;876&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;00.02&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;各行含义如下：&lt;/p&gt;
&lt;h3 id=&#34;第一行系统信息&#34;&gt;第一行：系统信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;20:40:53：系统当前时间&lt;/li&gt;
&lt;li&gt;up 411 days,  2:55：系统已经启动时间&lt;/li&gt;
&lt;li&gt;1 user：当前登陆的用户数&lt;/li&gt;
&lt;li&gt;load average：当前机器负载，三个数分别是1分钟、5分钟、15分钟的负载情况，程序每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第二行进程信息&#34;&gt;第二行：进程信息&lt;/h3&gt;
&lt;p&gt;依次分别是，总进成数，运行进程数，sleep进程数，stop进程数，还有僵尸进程数&lt;/p&gt;
&lt;h3 id=&#34;第三行cpu信息&#34;&gt;第三行：cpu信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;us：用户空间占用CPU的百分比&lt;/li&gt;
&lt;li&gt;sy：内核空间占用CPU的百分比&lt;/li&gt;
&lt;li&gt;ni：改变过优先级的进程占用CPU的百分比&lt;/li&gt;
&lt;li&gt;id：空闲CPU百分比&lt;/li&gt;
&lt;li&gt;wa：IO等待占用CPU的百分比&lt;/li&gt;
&lt;li&gt;hi：硬中断（Hardware IRQ）占用CPU的百分比&lt;/li&gt;
&lt;li&gt;si：软中断（Software Interrupts）占用CPU的百分比&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第四行内存信息&#34;&gt;第四行：内存信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;total：总内存大小&lt;/li&gt;
&lt;li&gt;used：已经使用内存大小&lt;/li&gt;
&lt;li&gt;free：空闲内存大小&lt;/li&gt;
&lt;li&gt;buffers：缓存内存大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第五行交换区信息&#34;&gt;第五行：交换区信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;total：总交换区大小&lt;/li&gt;
&lt;li&gt;used：已经使用交换区大小&lt;/li&gt;
&lt;li&gt;free：空闲交换区大小&lt;/li&gt;
&lt;li&gt;cached：cached缓存大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;列含义&#34;&gt;列含义&lt;/h3&gt;
&lt;p&gt;各列含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID：进程ID&lt;/li&gt;
&lt;li&gt;USER：创建者&lt;/li&gt;
&lt;li&gt;PRI：进程优先级&lt;/li&gt;
&lt;li&gt;NI：nick level，负值表示高优先级&lt;/li&gt;
&lt;li&gt;VIRT：进程使用的虚拟内存总量，单位kb（VIRT=SWAP+RES）&lt;/li&gt;
&lt;li&gt;RES：进程使用的、未被换出的物理内存大小，单位kb（RES=CODE+DATA）&lt;/li&gt;
&lt;li&gt;SHR：共享内存大小，单位kb&lt;/li&gt;
&lt;li&gt;S：进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程&lt;/li&gt;
&lt;li&gt;%CPU：上次更新到现在的CPU时间占用百分比&lt;/li&gt;
&lt;li&gt;%MEM：进程使用的物理内存百分比&lt;/li&gt;
&lt;li&gt;TIME+：进程使用的CPU时间总计，单位1/100秒&lt;/li&gt;
&lt;li&gt;COMMAND：进程名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，按&lt;code&gt;1&lt;/code&gt;可以显示各个cpu情况，&lt;code&gt;top -H&lt;/code&gt;可以显示各个线程情况。&lt;/p&gt;
&lt;h2 id=&#34;vmstat&#34;&gt;vmstat&lt;/h2&gt;
&lt;p&gt;vmstat 可以查看进程、内存、分页、IO和CPU等信息，执行&lt;code&gt;vmstat 2&lt;/code&gt;(2秒统计一次)，输出如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;procs -----------memory---------- ---swap-- -----io---- -system-- -----cpu------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 4  0  25832  50440  52928 6841116    0    0   125   192    0    0  6  2 91  0  0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 2  0  25832  50440  52932 6839432    0    0     0     0 48744 61153 19  6 76  0  0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 2  0  25832  53176  52944 6836144    0    0     0   370 48132 63201 19  6 75  0  0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 2  0  25832  52184  52952 6836428    0    0     0    30 48525 63944 19  5 75  0  0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：第一行数据显示系统上次启动后到现在的平均负载，需要排除在外。&lt;/p&gt;
&lt;h3 id=&#34;procs&#34;&gt;procs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;r：等待执行的进程数（显示cpu正在执行和等待cpu资源的进程数，该数字大于cpu个数，可能出现cpu性能瓶颈）&lt;/li&gt;
&lt;li&gt;b：等待IO的进程数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;memory&#34;&gt;memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;swpd：正在使用的虚拟内存大小&lt;/li&gt;
&lt;li&gt;free：空闲内存大小&lt;/li&gt;
&lt;li&gt;buff：已用的 buff 大小，对块设备的读写进行缓冲&lt;/li&gt;
&lt;li&gt;cache：文件系统缓存 cache 大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;swap&#34;&gt;swap&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;si：每秒从交换区写入内存的大小（kb/s）&lt;/li&gt;
&lt;li&gt;so：每秒从内存写到交换区的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;io&#34;&gt;io&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;bi：每秒读取的块数（读磁盘）&lt;/li&gt;
&lt;li&gt;bo：每秒写入的块数（写磁盘）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;system&#34;&gt;system&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;in：每秒中断数，包括时钟中断&lt;/li&gt;
&lt;li&gt;cs：每秒上下文切换数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpu&#34;&gt;cpu&lt;/h3&gt;
&lt;p&gt;含义见 top-cpu信息&lt;/p&gt;
&lt;h2 id=&#34;uptime&#34;&gt;uptime&lt;/h2&gt;
&lt;p&gt;见 top 第一行：系统信息&lt;/p&gt;
&lt;h2 id=&#34;free&#34;&gt;free&lt;/h2&gt;
&lt;p&gt;free 命令主要查看内存的使用情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             total       used       free     shared    buffers     cached
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Mem:       8052640    8000400      52240          0      52872    6853252
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-/+ buffers/cache:    1094276    6958364
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Swap:      2104504      25832    2078672
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二行含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;total：总物理内存大小&lt;/li&gt;
&lt;li&gt;used：已使用内存大小（包括系统cache）&lt;/li&gt;
&lt;li&gt;free：空闲内存大小&lt;/li&gt;
&lt;li&gt;shared：多个进程共享的内存大小&lt;/li&gt;
&lt;li&gt;buffers：buffer大小（块设备缓存）&lt;/li&gt;
&lt;li&gt;cached：cache大小（文件系统缓存）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三行：&lt;/p&gt;
&lt;p&gt;used/free：已使用内存大小和空闲内存大小，跟第二行相同字段的区别在于减去了buffer和cache，buffer和cache从操作系统角度来讲是已经使用的内存，但当系统可用内存不足时，操作系统会释放buffer和cache，对进程来讲，这部分内存也是可用的。&lt;/p&gt;
&lt;p&gt;第四行：参考 top&lt;/p&gt;
&lt;h2 id=&#34;iostat&#34;&gt;iostat&lt;/h2&gt;
&lt;p&gt;此命令用户输出cpu和磁盘io相关的统计信息，默认不加参数输出的是系统启动后到现在的统计情况，一般当系统启动很长时间以后，不具有太大的参考意义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Linux 2.6.32.43-tlinux-1.0.8-state (10_135_11_35_kqq)   01/13/2015      _x86_64_
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;avg-cpu:  %user   %nice %system %iowait  %steal   %idle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           5.64    0.49    2.84    0.41    0.00   91.20
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sda              25.64      2006.79      3075.79 71288307775 109262888974
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sda1              0.99        14.09         5.05  500582972  179528792
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sda2              0.00         0.00         0.00      13182     142936
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sda3              3.54        25.77        80.34  915263981 2853850978
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sda4             21.11      1966.93      2990.39 69872425096 106229366268
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;字段含义如下：&lt;/p&gt;
&lt;h3 id=&#34;cpu-1&#34;&gt;cpu&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;%user: 在用户级别运行所使用的CPU的百分比&lt;/li&gt;
&lt;li&gt;%nice: nice操作所使用的CPU的百分比&lt;/li&gt;
&lt;li&gt;%sys: 在系统级别(kernel)运行所使用CPU的百分比&lt;/li&gt;
&lt;li&gt;%iowait: CPU等待硬件I/O时,所占用CPU百分比&lt;/li&gt;
&lt;li&gt;%idle: CPU空闲时间的百分比&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;device&#34;&gt;Device&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;tps: 每秒钟发送到的I/O请求数&lt;/li&gt;
&lt;li&gt;Blk_read /s: 每秒读取的block数&lt;/li&gt;
&lt;li&gt;Blk_wrtn/s: 每秒写入的block数&lt;/li&gt;
&lt;li&gt;Blk_read:   读入的block总数&lt;/li&gt;
&lt;li&gt;Blk_wrtn:  写入的block总数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，iostate可以加入一些参数执行更为丰富的功能：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iostat -d 2&lt;/code&gt;：每隔两秒统计一次（注：第一行仍然显示系统启动至今的统计）
&lt;code&gt;iostat -x -d 2&lt;/code&gt;：显示更加详细的信息，2秒统计一次
&lt;code&gt;iostat -d 2 6&lt;/code&gt;：两秒统计一次，统计6次&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;-x&lt;/code&gt;参数显示详细信息，具体字段如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sda               0.50     0.00   19.50    4.50   332.00  1772.00   166.00   886.00    87.67     0.27   77.67   3.08   7.40
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rrqm/s（wrqm/s）：将读（写）入请求合并后,每秒发送到设备的读（写）入请求数&lt;/li&gt;
&lt;li&gt;r/s（w/s）：每秒发送到设备的读（写）入请求数&lt;/li&gt;
&lt;li&gt;rsec/s（wsec/s）：每秒从设备读（写）入的扇区数&lt;/li&gt;
&lt;li&gt;rkB/s（wkB/s）：每秒从设备读（写）入的数据量,单位为K&lt;/li&gt;
&lt;li&gt;avgrq-sz：发送到设备的请求的平均大小，单位是扇区&lt;/li&gt;
&lt;li&gt;avgqu-sz： 发送到设备的请求的平均队列长度&lt;/li&gt;
&lt;li&gt;await：I/O请求平均执行时间，包括发送请求和执行的时间，单位是毫秒&lt;/li&gt;
&lt;li&gt;svctm：发送到设备的I/O请求的平均执行时间，单位是毫秒&lt;/li&gt;
&lt;li&gt;%util：在I/O请求发送到设备期间，占用CPU时间的百分比（此值越大，表示设备占用率越高，100时表示设备已占满）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sar&#34;&gt;sar&lt;/h2&gt;
&lt;p&gt;sar 可以显示多种系统资源，具体命令格式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sar [options] [-A] [-o file] t [n]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在命令行中，n 和 t 两个参数组合起来定义采样间隔和次数，t为采样间隔，是必须有的参数，n为采样次数，是可选的，默认值是1，-o file表示将命令结果以二进制格式存放在文件中，file 在此处不是关键字，是文件名。options 为命令行选项。&lt;/p&gt;
&lt;p&gt;sar 常用的命令选项有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-A：所有报告的总和&lt;/li&gt;
&lt;li&gt;-u：CPU利用率&lt;/li&gt;
&lt;li&gt;-v：进程、I节点、文件和锁表状态&lt;/li&gt;
&lt;li&gt;-d：硬盘使用报告&lt;/li&gt;
&lt;li&gt;-r：没有使用的内存页面和硬盘块&lt;/li&gt;
&lt;li&gt;-g：串口I/O的情况&lt;/li&gt;
&lt;li&gt;-b：缓冲区使用情况&lt;/li&gt;
&lt;li&gt;-a：文件读写情况&lt;/li&gt;
&lt;li&gt;-c：系统调用情况&lt;/li&gt;
&lt;li&gt;-R：进程的活动情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;iotop&#34;&gt;iotop&lt;/h2&gt;
&lt;p&gt;有时机器磁盘使用率过高，想知道哪个进程占用磁盘过大，可使用 iotop 命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iotop –b –n 3 –d 5&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-h, &amp;ndash;help				#显示帮助信息&lt;/li&gt;
&lt;li&gt;-o, &amp;ndash;only				#显示进程或者线程实际上正在做的I/O，而不是全部的，可以随时切换按o&lt;/li&gt;
&lt;li&gt;-b, &amp;ndash;batch				#运行在非交互式的模式&lt;/li&gt;
&lt;li&gt;-n NUM, &amp;ndash;iter=NUM		#在非交互式模式下，设置显示的次数，&lt;/li&gt;
&lt;li&gt;-d SEC, &amp;ndash;delay=SEC		#设置显示的间隔秒数，支持非整数值&lt;/li&gt;
&lt;li&gt;-p PID, &amp;ndash;pid=PID			#只显示指定PID的信息&lt;/li&gt;
&lt;li&gt;-u USER, &amp;ndash;user=USER		#显示指定的用户的进程的信息&lt;/li&gt;
&lt;li&gt;-P, &amp;ndash;processes			#只显示进程，一般为显示所有的线程&lt;/li&gt;
&lt;li&gt;-a, &amp;ndash;accumulated			#显示从iotop启动后每个线程完成了的IO总数&lt;/li&gt;
&lt;li&gt;-k, &amp;ndash;kilobytes			#以千字节显示&lt;/li&gt;
&lt;li&gt;-t, &amp;ndash;time				#在每一行前添加一个当前的时间&lt;/li&gt;
&lt;li&gt;-q, &amp;ndash;quiet				#suppress some lines of header (implies &amp;ndash;batch). This option can be specified up to three times to remove header lines.&lt;/li&gt;
&lt;li&gt;-q     					## column names are only printed on the first iteration,&lt;/li&gt;
&lt;li&gt;-qq    					## column names are never printed,&lt;/li&gt;
&lt;li&gt;-qqq   					## the I/O summary is never printed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mpstat&#34;&gt;mpstat&lt;/h2&gt;
&lt;p&gt;mpstat 主要显示cpu相关信息，跟 vmstat 相比优点在于可以分别显示各个cpu的情况。执行&lt;code&gt;mpstat -P ALL 1&lt;/code&gt;，显示所有CPU状态，采样间隔1s。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;09:52:44 PM  CPU    %user   %nice    %sys %iowait    %irq   %soft  %steal  %idle    %intr/s    %guest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;09:52:45 PM  all   19.43    0.00    4.86    3.86    0.00    1.99    0.00   69.86   50984.00    0.00
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;09:52:45 PM    0   33.33    0.00    5.05    0.00    0.00    2.02    0.00   59.60    4623.00    0.00
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;09:52:45 PM    1   27.72    0.00    4.95    0.00    0.00    0.99    0.00   66.34    5771.00    0.00
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;%user：表示处理用户进程所使用 CPU 的百分比&lt;/li&gt;
&lt;li&gt;%nice：表示使用 nice 命令对进程进行降级时 CPU 的百分比&lt;/li&gt;
&lt;li&gt;%sys：表示内核进程使用的 CPU 百分比&lt;/li&gt;
&lt;li&gt;%iowait：表示等待进行 I/O 所使用的 CPU 时间百分比&lt;/li&gt;
&lt;li&gt;%irq：表示用于处理系统中断的 CPU 百分比&lt;/li&gt;
&lt;li&gt;%soft：表示用于软件中断的 CPU 百分比&lt;/li&gt;
&lt;li&gt;%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比&lt;/li&gt;
&lt;li&gt;%idle：显示 CPU 的空闲时间&lt;/li&gt;
&lt;li&gt;%intr/s：显示每秒 CPU 接收的中断总数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pmap&#34;&gt;pmap&lt;/h2&gt;
&lt;p&gt;pmap 用于查看进程的内存映像信息。使用方式：&lt;code&gt;pmap -d &amp;lt;pid&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;18161: IphonePushServi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;START               SIZE     RSS     PSS   DIRTY    SWAP PERM OFFSET   DEVICE MAPPING
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0000000000400000   7292K   3252K   3252K      0K      0K r-xp 0000000000000000 08:04  IphonePushService
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0000000000c1f000    116K     92K     92K     44K      0K rw-p 000000000071f000 08:04  IphonePushService
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;字段含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;START: 内存开始地址&lt;/li&gt;
&lt;li&gt;SIZE: 占用内存的字节数（KB）&lt;/li&gt;
&lt;li&gt;RSS: 保留内存的字节数（KB）&lt;/li&gt;
&lt;li&gt;Dirty: 脏页的字节数（包括共享和私有的）&lt;/li&gt;
&lt;li&gt;PERM: 内存的权限&lt;/li&gt;
&lt;li&gt;Offset: 文件偏移&lt;/li&gt;
&lt;li&gt;Device: 设备名 (major:minor)&lt;/li&gt;
&lt;li&gt;MAPPING: 对应的映像文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;netstat&#34;&gt;netstat&lt;/h2&gt;
&lt;p&gt;netstat 是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。&lt;/p&gt;
&lt;p&gt;该命令的一般形式：&lt;code&gt;netstat [-a][-e][-n][-o][-p Protocol][-r][-s][Interval]&lt;/code&gt;，执行 &lt;code&gt;netstat -anop&lt;/code&gt; 显示信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name Timer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN      -                off (0.00/0/0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      -                off (0.00/0/0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcp        0      0 127.0.0.1:8088          0.0.0.0:*               LISTEN      24346/tunnel     off (0.00/0/0)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中需要关注&lt;code&gt;Recv-Q&lt;/code&gt;，&lt;code&gt;Send-Q&lt;/code&gt;，分别表示发送队列和接受队列大小，当&lt;code&gt;Recv-Q&lt;/code&gt;过大，意味着当前程序无法及时接收数据包，&lt;code&gt;Send-Q&lt;/code&gt;过大，表示对端网络状况不好或者达到对端性能瓶颈。&lt;/p&gt;
&lt;h2 id=&#34;tcpdump&#34;&gt;tcpdump&lt;/h2&gt;
&lt;p&gt;tcpdump 可以截获网络数据包，对于网络协议的联调和测试有很大的辅助作用。&lt;/p&gt;
&lt;p&gt;tcpdump 它的命令格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcpdump [-adeflnNOpqStvx] [-c 数量] [-F filename] [-i 网络接口] [-r 文件名] [ -s snaplen ] [ -T 类型 ] [ -w 文件名 ] [表达式]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;选项说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a 将网络地址和广播地址转变成名字&lt;/li&gt;
&lt;li&gt;-d 　将匹配信息包的代码以人们能够理解的汇编格式给出&lt;/li&gt;
&lt;li&gt;-dd 　将匹配信息包的代码以c语言程序段的格式给出&lt;/li&gt;
&lt;li&gt;-ddd 　将匹配信息包的代码以十进制的形式给出&lt;/li&gt;
&lt;li&gt;-e 　在输出行打印出数据链路层的头部信息&lt;/li&gt;
&lt;li&gt;-f 　将外部的Internet地址以数字的形式打印出来&lt;/li&gt;
&lt;li&gt;-l 　使标准输出变为缓冲行形式&lt;/li&gt;
&lt;li&gt;-n 　不把网络地址转换成名字&lt;/li&gt;
&lt;li&gt;-t 　在输出的每一行不打印时间戳&lt;/li&gt;
&lt;li&gt;-v 　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息&lt;/li&gt;
&lt;li&gt;-vv 　输出详细的报文信息&lt;/li&gt;
&lt;li&gt;-c 　在收到指定的包的数目后，tcpdump就会停止&lt;/li&gt;
&lt;li&gt;-F 　从指定的文件中读取表达式，忽略其它的表达式&lt;/li&gt;
&lt;li&gt;-i 　指定监听的网络接口&lt;/li&gt;
&lt;li&gt;-r 　从指定的文件中读取包(这些包一般通过-w选项产生)&lt;/li&gt;
&lt;li&gt;-w 　直接将包写入文件中，并不分析和打印出来&lt;/li&gt;
&lt;li&gt;-T 　将监听到的包直接解释为指定的类型的报文，常见的类型有 rpc 和 snmp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;strace&#34;&gt;strace&lt;/h2&gt;
&lt;p&gt;strace 可以查看一个进程所调用的系统api情况，在某些情况下，知道系统所调用的api，可以判断程序运行时的一些状态，该命令使用方式：&lt;code&gt;strace -p &amp;lt;PID&amp;gt;&lt;/code&gt;。可以查看调用的api和参数。&lt;/p&gt;
&lt;h2 id=&#34;lsof&#34;&gt;lsof&lt;/h2&gt;
&lt;p&gt;lsof 是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以 文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议(TCP)和用户数据报协议(UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符，通过lsof工具能够查看这个列表的详细信息。&lt;/p&gt;
&lt;p&gt;lsof 的使用方法可以参考这里。这里列出几种常见的用法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看文件系统阻塞 &lt;code&gt;lsof /boot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看端口号被哪个进程占用 &lt;code&gt;lsof -i :3306&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看用户打开哪些文件 &lt;code&gt;lsof -u username&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看进程打开哪些文件 &lt;code&gt;lsof -p 4838&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看远程已打开的网络链接&lt;code&gt; lsof -i @192.168.34.128&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;proc文件系统&#34;&gt;proc文件系统&lt;/h2&gt;
&lt;p&gt;在Linux上&lt;code&gt;/proc/&lt;/code&gt;是很特殊的文件系统，存储了内核当前运行状态的虚拟文件系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/proc/meminfo&lt;/code&gt;：当前系统内存状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc/cpuinfo&lt;/code&gt;：cpu状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc/&amp;lt;PID&amp;gt;&lt;/code&gt;：PID进程信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc/&amp;lt;PID&amp;gt;/cmdline&lt;/code&gt;：进程执行命令行信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc/&amp;lt;PID&amp;gt;/exe&lt;/code&gt;：软链接，指向当前执行进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc/sys/net/ipv4/tcp_wmem&lt;/code&gt;：tcp write buffer值，分别表示：最小，默认，最大&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;benchmark&#34;&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;除了监控系统和程序状态的工具，另外还有一些工具用于测试系统本身固有的性能，如果两台机器之间本身的网络传输有瓶颈，不论程序写的多优秀，也不能突破这种限制。所以适当的时候，或者评估阶段，有时候通过测试系统固有的特定，是一个好的选择。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;工具&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;功能&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Lmbench&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;反应时间测评工具，上下文切换，网络：连接的建立，管道，文件系统的建立和删除，内存读入反应时间等等&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;IOzone&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;测试不同的操作系统中文件系统的读写性能&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;netperf&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;测试网络的性能&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;bonnie&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;磁盘IO和文件系统测试&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;iperf&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;网络测试&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ab(Apache)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;web server 测试&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中 Lmbench 可以测试读写内存，网络建立，上下文切换等性能，这可以提供给我们很好的参考，作为架构师，一定需要了解各种性能指标，甚至主要api调用性能，才能更合理的使用。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>overcommit 对 fork 的影响</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/redis-failed-when-out-of-memory/</link>
        <pubDate>Tue, 10 Jun 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/redis-failed-when-out-of-memory/</guid>
        <description>&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;
&lt;p&gt;线上的一个服务使用Redis作为中转队列，今天读写队列操作突然错误，相关功能处于不可用状态，错误显示读队列时返回异常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RDB 是 Redis 持久化数据的一种方式，其主要原理就是在某个时间点把内存中的所有数据的快照保存一份到磁盘上。在条件达到时通过fork一个子进程把内存中的数据写到一个临时文件中来实现保存数据快照。&lt;/p&gt;
&lt;p&gt;查看 Redis 的日志发现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:11.059 * 1 changes in 900 seconds. Saving...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:11.060 # Can&amp;#39;t save in background: fork: Cannot allocate memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:17.067 * 1 changes in 900 seconds. Saving...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[23830] 14 Jan 20:13:17.068 # Can&amp;#39;t save in background: fork: Cannot allocate memory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;原因&#34;&gt;原因&lt;/h1&gt;
&lt;p&gt;看到问题应该是由于fork出来一个进程后台持久化数据，由于内存不足导致fork失败，当Redis持久化失败时，设置当前为禁写的状态（读队列会删除元素，也算写操作）。使用info查看Redis状态，&lt;code&gt;rdb_last_bgsave_status&lt;/code&gt;显示为 err。此时即使重新设置状态为ok也无用，因为很快就会下一轮fork，状态会被重置。&lt;/p&gt;
&lt;h1 id=&#34;overcommit&#34;&gt;overcommit&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://redis.io/topics/faq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;有相关信息，需要设置&lt;code&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory&lt;/code&gt;，查阅&lt;a class=&#34;link&#34; href=&#34;http://www.win.tue.nl/~aeb/linux/lk/lk-9.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux Memory &lt;/a&gt;发现，&lt;code&gt;overcommit_memory&lt;/code&gt; 指定了Linux内存分配的策略。可选值：0，1，2。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。&lt;/li&gt;
&lt;li&gt;1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。&lt;/li&gt;
&lt;li&gt;2：表示内核允许分配超过所有物理内存和交换空间总和的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体什么含义呢？当使用malloc等函数，向系统申请内存时，一种情况是有可用内存时返回成功，无可用内存时返回失败&lt;code&gt;NULL&lt;/code&gt;，另一种情况是都返回成功，以便能运行更大的程序，因为申请内存后，可能不会立即使用，当使用时发现内存不足时，会发生OOM killer，它会选择杀死一些进程（用户态进程，不是内核线程），以便释放内存。选择进程的函数是&lt;code&gt;oom_badness&lt;/code&gt;函数(在&lt;code&gt;mm/oom_kill.c&lt;/code&gt;中)，该函数会计算每个进程的点数(0~1000)。点数越高，这个进程越有可能被杀死。每个进程的点数跟&lt;code&gt;oom_score_adj&lt;/code&gt;有关，而且&lt;code&gt;oom_score_adj&lt;/code&gt;可以被设置(-1000最低，1000最高)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;overcommit_memory&lt;/code&gt;的三种状态分别表示为三种&lt;code&gt;overcommit&lt;/code&gt;策略(&lt;code&gt;Documentation/vm/overcommit-accounting&lt;/code&gt;)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：启发式策略。合理的overcommit会被接受，不合理的overcommit会被拒绝。&lt;/li&gt;
&lt;li&gt;1：任何overcommit都会被接受。&lt;/li&gt;
&lt;li&gt;2：当系统分配的内存超过&lt;code&gt;swap+N%*物理RAM&lt;/code&gt;(N%由&lt;code&gt;vm.overcommit_ratio&lt;/code&gt;决定)时，会拒绝commit。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;overcommit 的策略通过&lt;code&gt;vm.overcommit_memory&lt;/code&gt;设置
overcommit的百分比由&lt;code&gt;vm.overcommit_ratio&lt;/code&gt;设置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;overcommit_memory&lt;/code&gt;设置为0时，Redis fork Linux会假定子进程占用同样多的内存空间（根据实际映射的物理内存决定），如果free空间不足，会发生错误导致无法正常fork。&lt;/p&gt;
&lt;h1 id=&#34;复盘&#34;&gt;复盘&lt;/h1&gt;
&lt;p&gt;复盘一下发现：写入量过大，导致fork时内存不足，fork失败，Redis这种情况下会切换成紧写的状态。导致Redis不可用，如果设置 &lt;code&gt;overcommit_memory&lt;/code&gt; 为1，看到Redis上一次dump数据花费了60s左右，内存使用12G，每条数据大小500字节左右，60s时间队列读取速度为4M，基本上相当于2G数据量，可以看到变化的数据有20%不到，根据写时复制的原则，fork就不会有问题了。&lt;/p&gt;
&lt;p&gt;不过Redis作为队列，在消息流动比较大，而且消息时效性比较强的情况下，可以禁用数据持久化功能，提升效率。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>算法学习笔记-最长公共子序列</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/algorithm-lcs/</link>
        <pubDate>Mon, 02 Jun 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/algorithm-lcs/</guid>
        <description>&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;子序列：一个给定序列的子序列是指该给定序列去掉零个或多个元素，子序列并非需要在原序列中连续。
公共子序列：给定两个序列X和Y，如果序列Z既是X的一个子序列又是Y的一个子序列，就称序列Z是X和Y的公共子序列。
最长公共子序列：如果没有比公共子序列Z元素更多的子序列，则称Z为最长公共子序列。&lt;/p&gt;
&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;
&lt;p&gt;问题描述：给定两个序列&lt;code&gt;X={x1, x2, x3, …, xm}&lt;/code&gt;和&lt;code&gt;Y={y1, y2, y3, …, yn}&lt;/code&gt;，找出X和Y的最长公共子序列。&lt;/p&gt;
&lt;h1 id=&#34;解决&#34;&gt;解决&lt;/h1&gt;
&lt;p&gt;解决最长公共子序列一个比较直接暴力的办法是枚举所有X的子序列，检查是否同时是Y的子序列，从公共子序列中找到最长的一个。&lt;/p&gt;
&lt;p&gt;X中元素有m个，X中的子序列有&lt;code&gt;2^m&lt;/code&gt;个，算法的复杂度需要指数时间，最于长序列来讲耗时过长。&lt;/p&gt;
&lt;p&gt;另一种比较合理的解决办法是&lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/algorithm-dynamic-programming.html&#34; &gt;动态规划&lt;/a&gt;。LCS具有最优子序列结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	X={x1, x2, x3, …, xm}和Y={y1, y2, y3, …, yn} 为两个序列，Z={z1, z2, …, zk} 为X和Y的任意一个LCS。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	1）如果xm=yn，则 zk=xm=yn而且Z(k-1)是X(m-1)和Y(n-1)的一个LCS。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	2）如果xm!=yn，则zk!=xm表示Z是X(m-1)和Y的一个LCS。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	3）如果xm!=yn，则zk!=yn表示Z是X和Y(n-1)的一个LCS。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最优子结构是使用动态规划的基础，由以上结论便可归纳出具体的计算方法：&lt;/p&gt;
&lt;p&gt;标记c[i,j]是Xi和Xj的最长公共子序列，则有：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	c[i,j] = 0                i=0 or j=0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	c[i,j] = c[i-1,j-1] + 1             i,j&amp;gt;0 and xi == yj
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	c[i,j] =max{c[i,j-1], c[i-1,j]}         i,j&amp;gt;0 and xi != yj
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过递归便可得到所有i,j下最长公共子序列。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;cp&#34;&gt;#define MAX_ELEM_LEN    100
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MAX_ELEM_LEN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MAX_ELEM_LEN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;find_LCS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max_elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;find_LCS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max_elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果需要得到具体的子序列，可从&lt;code&gt;c[i,j]&lt;/code&gt;回溯，很容易找到最大子序列是什么，从而得到整个序列。&lt;/p&gt;
&lt;h1 id=&#34;复杂度&#34;&gt;复杂度&lt;/h1&gt;
&lt;p&gt;这里的空间复杂度和时间复杂度都是O(m+n)，如果只要得到最大公共子序列的大小，而不求具体的序列，可以优化空间复杂度，虽然结果是个二维数组，但使用的时候仅仅用到上一层，这里完全可以优化一下空间复杂度，仅用O(m)便可实现。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>算法学习笔记-动态规划</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/algorithm-dynamic-programming/</link>
        <pubDate>Sun, 01 Jun 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/algorithm-dynamic-programming/</guid>
        <description>&lt;p&gt;动态规划是一种非常常见的算法，但是在学习算法很久以后才理解什么是动态规划，因为动态规划实在是“名不符其实”，从名称上很难直观的对算法有个认识，要说动态规划，还得从分治法说起。&lt;/p&gt;
&lt;h1 id=&#34;分治法&#34;&gt;分治法&lt;/h1&gt;
&lt;p&gt;分治法几乎学过程序的人都能理解，简而言之就是分而治之，一个问题很复杂很难解决，就设法把大问题转化为若干个小问题，小问题解决经过汇总，大问题也就迎刃而解了。&lt;/p&gt;
&lt;p&gt;举个例子，在某公司，要设计开发一个大型项目，上百人一窝蜂去解决这个问题效率显然很低，这时CTO会把项目分解成若干子项目，分给各部门总监，总监拿到项目又进行模块分解，分给手下的各个小组，由各个小组负责开发完成具体的模块，在总监指导下完成整合，再由CTO汇总在一起，就合理的分工完成一个大型的项目了。这就是分治法。&lt;/p&gt;
&lt;p&gt;那动态规划跟分治法有什么关系呢？再说上面的例子，当各个小组负责开发时，发现有些模块是重复的！比如网络框架，如果各个小组各自为战，每个小组都会开发一套自己的网络框架，这显然会造成大量的人员浪费。CTO考虑到这点，就会想，为什么不构建一个所有小组都能通用的公共库呢？当一个小组开发完成一个功能，就放入公共库，其他小组再开发前，先在公共库查找，如果已经有了，就不用再开发了，这就节省了大量的重复工作。&lt;/p&gt;
&lt;p&gt;其中用一个公共的“Table”记录已经完成的工作，避免重复运算，这种解决问题的思路，就是动态规划了。&lt;/p&gt;
&lt;h1 id=&#34;动态规划&#34;&gt;动态规划&lt;/h1&gt;
&lt;p&gt;现在就知道什么是动态规划了，动态规划类似于分治法，适用于分治法有重复的子问题，动态规划使用一个table保存计算结果，确保每个子问题只被运算一次。&lt;/p&gt;
&lt;p&gt;动态规划被用于解决&amp;quot;最优解&amp;quot;问题，举上面的例子，如果CTO不知道如何分配任务，想知道由哪个小组做哪个模块才能最快，需要进行多次“尝试”，把问题的各种分配方法都试一次，让各小组解决，看如何分配才能最快，这显然其中有很多重复的开发，但如果把某个小组执行某个模块需要多长时间都记录下来，可以最大程度上减少开发。（注意这里的问题已经不是解决这个项目了，而且怎么分解项目能达到最优解，table里存的变成某个小组完成某个模块的时间，求最优解往往要比求一个解复杂很多），这就是求最优解的应用了。&lt;/p&gt;
&lt;h1 id=&#34;解题步骤&#34;&gt;解题步骤&lt;/h1&gt;
&lt;p&gt;现在对动态规划有了一个感性的认识，接下来需要看看面对具体的问题该如何解决了，现看看动态规划通用的解题方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析最优解特征&lt;/li&gt;
&lt;li&gt;递归定义最优解&lt;/li&gt;
&lt;li&gt;自底向上求解&lt;/li&gt;
&lt;li&gt;构造最优解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只是一个抽象的步骤，接下来通过动态规划一个典型的应用“背包问题”来说明一下具体是如何实现的。&lt;/p&gt;
&lt;h1 id=&#34;0-1背包问题&#34;&gt;0-1背包问题&lt;/h1&gt;
&lt;h2 id=&#34;题目&#34;&gt;题目&lt;/h2&gt;
&lt;p&gt;有N件物品和一个容量为V的背包。第i件物品的重量是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。&lt;/p&gt;
&lt;h2 id=&#34;分析最优解特征&#34;&gt;分析最优解特征&lt;/h2&gt;
&lt;p&gt;如果题目中N件物品都只有一件，就是典型的0-1背包问题，这里先来看看0-1背包问题如何解决。感性的认识一下题目，每个商品只有放入背包和不放入背包两种，如果先挑单体重量价值最大的，也有可能体积太大无法装下其他货物，还不如放两个价值不是最大的划算，乍一看还是挺难解决的。接下来使用动态规划详细分析一下题目。&lt;/p&gt;
&lt;p&gt;首先什么是一个解，就是一种背包方法，解的值就是背包中物品的最大价值。最优解就是不同的取法中最大的价值，再来看看这个最优解的递归特征，所谓的递归特征，就是如何把大问题化为小问题。这里考虑把N件物品转化为N-1件物品，考虑最后一件物品（索引从0开始）：c[N-1], w[N-1]，只有两种可能：不放入背包和放入背包，如果最优解中没有物品obj(N-1)，那么最优解其实就是N-1个物品的最优解，如果obj(N-1)存在最优解中，那么也可以把这个问题转换为N-1个物品的最优解，只是背包的容量就剩下V-c[N-1]了，这样不论哪种情况，都可以N个物品的问题，转化为N-1个物品的问题。这就是最优解的递归特性。&lt;/p&gt;
&lt;h2 id=&#34;递归定义最优解&#34;&gt;递归定义最优解&lt;/h2&gt;
&lt;p&gt;分析完递归特性以后，便很容易定义一个递归公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/keep/2014/0_0-1package.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;0-1 package&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;N=1 只有一个物品的时候很容易解决，直接看能不能放下即可，N&amp;gt;1的时候，想办法利用最优解的递归特性转换为N-1，使我们解决的问题少了一个纬度，是解决这类问题的关键。&lt;/p&gt;
&lt;p&gt;其实如果学过数学归纳法，会发现这个思路很相似，数学归纳法是已知f(0)成立，要证明f(N-1)成立的情况下f(N)成立，解题关键是怎么推导f(N-1)到f(N)，这里的递归结构同理，已知f(0)，要想办法从f(N-1)的解推出f(N)的解。&lt;/p&gt;
&lt;h2 id=&#34;自底向上求解&#34;&gt;自底向上求解&lt;/h2&gt;
&lt;p&gt;公式有了，只要用程序实现即可，这里的自底向上，是指从0到N逐个求解，因为公式本身具有递归特性，所以用递归解决这个问题最为直接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int Package(int N, int c[], int w[], int V)
{
	int w_contain = 0;
	int w_without = 0;
	
	if (N == 1 &amp;amp;&amp;amp; c[0] &amp;gt;= V) {
		return w[0];
	}
	if (N == 1 &amp;amp;&amp;amp; c[0] &amp;lt; V) {
		return 0;
	}
	
	w_without = Package(N-1, c, w, V);
	w_contain = Package(N-1, c, w, V - c[N-1]) + w[N-1];
	if (w_contain &amp;gt; w_without) {
		return w_contain;
	}
	else {
		return w_without;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那说了半天，动态规划怎么还没用呢？接下来可以看一下这个代码的复杂度，很容易能看出来，每次代码都会走两个分支，复杂度是 O(2^n)，指数级别的复杂度很大，如果n很大的情况下，代码就不具有可行性了。那如何优化呢，这就需要动态规划了，保存什么结果呢，可以看出其中的N和V都是变量，所以需要以这两个为key存储最优解。代码就优化为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int table[N][V] = {};

int init()
{
	for (int i = 0; i &amp;lt; V * N; i++) {
		table[i] = -1;
	}
}

int Package(int N, int c[], int w[], int V)
{
	int w_contain = 0;
	int w_without = 0;
	
	if (N == 1 &amp;amp;&amp;amp; c[0] &amp;gt;= V) {
		return w[0];
	}
	if (N == 1 &amp;amp;&amp;amp; c[0] &amp;lt; V) {
		return 0;
	}
	
	w_without = table[N-1][V];
	if (w_without == -1) {
		w_without = Package(N-1, c, w, V);
		table[N-1][V] = w_without;
	}
	
	w_contain = table[N-1][V - c[N-1]];
	if (w_contain == -1) {
		w_contain = Package(N-1, c, w, V - c[N-1]) + w[N-1];
		table[N-1][V - c[N-1]] = w_contain;
	}
	
	return (w_contain &amp;gt; w_without) ? w_contain : w_without;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过动态规划的优化，因为table表里的值最多计算一次，时间复杂度变成O(N&lt;em&gt;V)，当然也增加了O(N&lt;/em&gt;V)的空间复杂度，是典型的用空间换时间做法。&lt;/p&gt;
&lt;h2 id=&#34;空间优化&#34;&gt;空间优化&lt;/h2&gt;
&lt;p&gt;如果仔细考虑一下，会发现其实空间还可以进一步优化，因为计算过程中，f(N)依赖于f(N-1)，并不依赖于N-1之前的结果，完全可以在计算过程中，使f(N)覆盖掉f(N-1)的结果，节省空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int table[V] = {};

int Package(int N, int c[], int w[], int V)
{
	for (int i = 0; i &amp;lt; N; i++) {
		for (int j = V; j &amp;gt; c[i]; V++) {
			int w_contain = table[j-c[i]] + w[i];
			int w_without = table[j];
			table[j] = (w_contain &amp;gt; w_without) ? w_contain : w_without;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为需要一层一层计算，所以递归代码改成了迭代。空间复杂度缩小至O(V)，时间复杂度仍然是O(N*V)。&lt;/p&gt;
&lt;h2 id=&#34;构造最优解&#34;&gt;构造最优解&lt;/h2&gt;
&lt;p&gt;解了半天，终于能知道最大能背多少价值的东西了，但是如何取才能得到最优解呢？通过优化方法计算，已经没法得知怎么才能是最优解了，因为计算的过程已经被抹杀了，但是使用非空间优化的方法，很容易获取，只需要把最优解table[N-1][V]是怎么计算出来的倒推回去即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int table[N][V] = {};

bool result[N] = {};

void ConstructResult(int N, int c[], int w[], int V)
{
	for (int i = N-1; i &amp;gt;=0; i++) {
		if (table[i-1][V] &amp;gt; table[i-1][V-c[i]] + w[i]) {
			printf(&amp;quot;1\t&amp;quot;);
			V -= w[i];
		}
		else {
			printf(&amp;quot;0\t&amp;quot;);
		}
	}
	print(&amp;quot;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照刚才计算的路程倒推回去，便可知道如何取才能得到最优解，只是按照这种方法打印出来的是倒序，需要调整一下顺序。&lt;/p&gt;
&lt;h1 id=&#34;有界背包问题&#34;&gt;有界背包问题&lt;/h1&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;刚才只是最简单的一种背包问题，0-1背包，其中一个物品只有一个，如果再加一个条件，一个物品可以有有限多个，这个问题就变成了有界背包问题。对于有界背包问题如何解决呢？&lt;/p&gt;
&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;
&lt;p&gt;其实有界背包问题可以很容易转换为0-1背包问题，如果一个物品可以选择n次，只需要把一个物品重复n个，就成了n个物品的0-1背包问题。通过动态规划便可顺利解决了。&lt;/p&gt;
&lt;h1 id=&#34;无界解背包问题&#34;&gt;无界解背包问题&lt;/h1&gt;
&lt;p&gt;如果把0-1背包的问题再变化一下，没种物品可以无限选择，就不能用有界背包的解法把问题转换为0-1背包了。当然可以借用0-1背包的思路，0-1背包在递归的时候会考虑存在和不存在的情况，从而把问题转换为N-1的子问题，而无界背包问题同样可以考虑这个物品不出现、出现1次、2次。。。等多种情况，把问题降维到N-1。只是要比0-1背包复杂好多。&lt;/p&gt;
&lt;p&gt;另外，动态规划还有一些其他应用，比如 &lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/algorithm-lcs.html&#34; &gt;最长公共子序列&lt;/a&gt;，可以进一步学习动态规划的应用。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-进程调度</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-process-sched/</link>
        <pubDate>Fri, 23 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-process-sched/</guid>
        <description>&lt;p&gt;现代操作系统都可以同时运行若干进程，对于单核CPU，给定时刻只会有一个进程运行，CPU快速的在各个进程中切换，给用户以多个进程同时运行的错觉，对于多核CPU，可以真正并发运行多个进程，取决于CPU的数目。&lt;/p&gt;
&lt;p&gt;内核在各个进程切换过程中，必须做到进程之间不能互相干扰，而且需要CPU时间必须在各种应用程序中尽可能公平的共享，进程管理和调度有两个主要任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核决定各个进程分配多长时间，何时切换到下一个进程；&lt;/li&gt;
&lt;li&gt;进程从A切换到B时，需要确保进程B的执行环境与上一次撤销其处理资源时完全相同；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个任务称之为调度器的内核子系统的职责。&lt;/p&gt;
&lt;h1 id=&#34;进程生命周期&#34;&gt;进程生命周期&lt;/h1&gt;
&lt;p&gt;进程不是总是可以立即运行，有时必须等待外部信号，在信号发生时进程无法运行。当调度器在进程之间切换时，必须知道系统中每个进程的状态。进程可能有以下几种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行：进程正在运行&lt;/li&gt;
&lt;li&gt;等待：进程能够运行，但没有分到时间片，调度器下一次可以选择此进程&lt;/li&gt;
&lt;li&gt;睡眠：进程正在睡眠无法运行，正在等待外部事件&lt;/li&gt;
&lt;li&gt;僵尸：进程资源已经释放，但还保留进程表中的项&lt;/li&gt;
&lt;li&gt;终止：进程退出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux进程管理还需另外两种状态选项：用户状态和核心态。用户态受到各种限制，内核态却有无上的权利。进程通常处于用户状态，只能访问自身数据，无法干扰其他进程。如果进程想要访问系统数据或者功能，必须切换到核心态，用户态切换到核心态有两种方法，第一种是系统调用(系统调用)[/reading/linux-kernel-system-call.html]，另一种是通过中断。内核的抢占调度模型建立了一个层次结构，用户判断哪些进程状态可以由其他状态抢占。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通进程总是可能被抢占&lt;/li&gt;
&lt;li&gt;如果进程处于核心态并在处理系统调用，那么其他进程是无法抢占，但中断可以终止系统调用&lt;/li&gt;
&lt;li&gt;中断可以暂停出于用户状态和核心态的进程，中断有最高优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核有一个内核抢占的选项，支持紧急情况下切换到另一个进程，甚至当前处于核心态执行系统调用。&lt;/p&gt;
&lt;h1 id=&#34;进程表示&#34;&gt;进程表示&lt;/h1&gt;
&lt;p&gt;Linux内核涉及进程和进程所有算法都围绕一个名为 &lt;code&gt;task_struct&lt;/code&gt; 的数据结构建立，该结构定义在 &lt;code&gt;include/sched.h&lt;/code&gt; 中，这是系统中重要的一个结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 结构复杂，要想都搞清楚着实不易，但该结构可以分为各个部分，每个部分表示进程的不同方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态和执行信息：如待定信号，进程ID（pid），父进程及其他有关进程的指针，优先级和程序执行有关的信息&lt;/li&gt;
&lt;li&gt;有关分配的虚拟内存信息&lt;/li&gt;
&lt;li&gt;进程身份凭据，如用户ID，组ID及权限&lt;/li&gt;
&lt;li&gt;使用的文件包含程序代码的二进制文件，以及进程所处理的所有文件的文件系统信息&lt;/li&gt;
&lt;li&gt;线程信息记录该进程特定于CPU的运行时间数据&lt;/li&gt;
&lt;li&gt;在与其他应用程序协作时所需的进程间通信有关的信息&lt;/li&gt;
&lt;li&gt;该进程所用的信号处理程序，用于响应到来的信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 的许多成员并非简单类型变量，而是其他数据结构的指针。下面介绍一些结构的重要数据成员。&lt;/p&gt;
&lt;h2 id=&#34;当前状态-state&#34;&gt;当前状态 state&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt;指定了当前状态，可以使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TASK_RUNNING&lt;/code&gt;：进程处于可运行状态，这并不意味着实际分配了CPU，进程可能会一直等到调度器选中它&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;：针对等待某事件或其他资源的睡眠进程设置的。在内核发送信号给进程表明事件已经发生，进程状态变为 &lt;code&gt;TASK_RUNNING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt;：用于因内核指示而停用的睡眠进程，他们不能由外部信号唤醒，只能由内核亲自唤醒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_STOPPED&lt;/code&gt;：表示进程特意停止运行，例如由调度器暂停&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TASK_TRACED&lt;/code&gt;：本来不是进程状态，用于从停止的进程中，将当前被调试的那些与常规的进程区分开&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面常量可以用于&lt;code&gt;struct task_struct&lt;/code&gt;进程状态字段，也可以用于&lt;code&gt;exit_state&lt;/code&gt;字段，后者明确地用于退出进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXIT_ZOMBIE&lt;/code&gt;：僵尸进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXIT_DEAD&lt;/code&gt;：状态则是指&lt;code&gt;wait&lt;/code&gt;系统调用已经发出，而进程完全从系统移除之前的状态，只有多个线程对同一个进程发出&lt;code&gt;wait&lt;/code&gt;调用时，才有意义&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;资源限制-rlimit&#34;&gt;资源限制 rlimit&lt;/h2&gt;
&lt;p&gt;Linux提供资源限制功能，该机制利用了&lt;code&gt;task_struct&lt;/code&gt;中的 rlim 数组，数组项类型为 &lt;code&gt;struct rlimit&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rlimit&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;rlim_cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;rlim_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述定义可以用于多种不同的资源类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rlim_cur&lt;/code&gt;：是进程当前资源限制，也称之为软限制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rlim_max&lt;/code&gt;：是该限制的最大容许值，称之为硬限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统调用&lt;code&gt;setrlimit&lt;/code&gt;来增减当前限制，但不能超过&lt;code&gt;rlim_max&lt;/code&gt;指定的值。&lt;code&gt;rlim&lt;/code&gt;数组中的位置标志了受限资源的类型，这也是内核需要定义的处理器常数，将资源与位置关联起来的原因。如果某一类资源没有限制，则将&lt;code&gt;rlim_max&lt;/code&gt;设置为&lt;code&gt;RLIM_INFINITY&lt;/code&gt;。以下是几种宏定义：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;常数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;语义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_CPU&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;按毫秒计算的最大CPU时间&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_FSIZE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;允许的最大文件长度&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_DATA&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;数据段的最大长度&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_STACK&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;（用户态）栈最大长度&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_CORE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;内存转储文件最大长度&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_NOFILE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;打开文件最大数目&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_SIGPENDING&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;待决信号的最大数目&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;RLIMIT_MSGQUEUE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;信息队列最大数目&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在&lt;code&gt;proc&lt;/code&gt;文件系统中，可以从文件&lt;code&gt;/proc/self/limits&lt;/code&gt;查看当前&lt;code&gt;rlimit&lt;/code&gt;限制。&lt;/p&gt;
&lt;h2 id=&#34;进程类型&#34;&gt;进程类型&lt;/h2&gt;
&lt;p&gt;典型的UNIX进程包括：由二进制代码组成的应用程序、单线程、分配给应用程序的一组资源。新进程是由&lt;code&gt;fork&lt;/code&gt;和&lt;code&gt;exec&lt;/code&gt;系统调用完成的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork 生成当前进程的一个相同副本，成为子进程。&lt;/li&gt;
&lt;li&gt;exec 从一个可执行文件加载另一个应用程序，来代替当前运行的进程。&lt;/li&gt;
&lt;li&gt;clone 工作原理基本与fork相同，但新进程不是独立于父进程的，可以与其共享某些资源，如父进程的内存数据等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;clone&lt;/code&gt; 用于实现线程，但仅仅系统调用还不能做到这点，还需要用户空间库才能提供完整实现，如Linuxthreads和Next Generation Posix Threads等。&lt;/p&gt;
&lt;h2 id=&#34;命名空间&#34;&gt;命名空间&lt;/h2&gt;
&lt;p&gt;命名空间提供了虚拟化的一种轻量级形式，传统上，在Linux以及其他衍生的UINX扁蹄中，许多资源是全局管理的，例如系统中的所有进程按照惯例都是通过PID标识的，这意味着内核必须管理一个全局的PID列表，而且，所有调用者通过uname系统调用返回的系统相关信息都是相同的。用户的管理方式相同，即各个用户是通过一个全局唯一的UID号标识。&lt;/p&gt;
&lt;p&gt;有些情况下，如提供Web主机的提供商给每个用户提供Linux计算机全部访问权限，包括root权限在内，传统上，要为每个用户准备一台计算机，代价很高，使用KVM虚拟机是另一种办法，但资源分配做的不是很好，计算机各个用户都需要一个独立的内核，以及一份完全安装好的用户层应用。&lt;/p&gt;
&lt;p&gt;命名空间提供了一种不同的解决方案，所需资源较少，命令空间只使用一个内核，前述的所有全局资源都通过命令空间抽象起来，这使得可以将一组进程放置到容器中，各个容器彼此隔离，隔离可以使得容器的成员与其他容器毫无关系，但也可以通过允许容器进程一定的共享，来降低容器之间的间隔。例如，容器可以设置为使用自身的PID集合，但仍然与其他容器共享部分文件系统。&lt;/p&gt;
&lt;p&gt;Linux 系统对简单形式的命令空间的支持已经有很长时间了，主要是chroot系统调用，该方法可以将进程限制到文件系统的某一部分。因而是一种简单的命名空间机制，但真正的命名空间能够控制的功能远超文件系统视图。&lt;/p&gt;
&lt;p&gt;新命令空间可以用两种方法创建：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork 或 clone 系统调用创建新进程时，有特定选项可以控制是与父进程共享命名空间，还是建立新的命名空间&lt;/li&gt;
&lt;li&gt;unshare 系统调用将进程的某些部分从父进程分离，其中也包括命名空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在通过上述两种方式从父进程命名空间分离后，从该进程角度看，改变全局属性不会传播到父进程命名空间，而父进程修改也不会传播到子进程。&lt;/p&gt;
&lt;p&gt;命名空间的实现需要两个部分：每个子系统的命名空间结构，将此前所有的全局组建包装的命名空间中；将给定进程关联到所属各个命名空间的机制。&lt;/p&gt;
&lt;p&gt;子系统此前的全局属性现在封装到命名空间中，每个进程关联到一个选定的命名空间，每个可以感知命名空间的内核子系统都必须提供一个数据结构，将所有通过命名空间形式提供的对象集中起来。&lt;code&gt;struct nsproxy&lt;/code&gt;用户汇集指向特定于子系统的命名空间包装器的指针：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nsproxy&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;atomic_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uts_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uts_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ipc_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ipc_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mnt_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mnt_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid_namespace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;net&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;net_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当前内核的以下范围可以感知到命名空间：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UTS（UNIX Timesharing System）命名空间包含了运行内核的名称、版本、底层体系结构类型等信息&lt;/li&gt;
&lt;li&gt;保存在&lt;code&gt;struct ipc_namespace&lt;/code&gt; 中的所有与进程间通信IPC有关信息&lt;/li&gt;
&lt;li&gt;已经装载的文件系统的视图，在&lt;code&gt;struct mnt_namespace&lt;/code&gt;中给出&lt;/li&gt;
&lt;li&gt;有关进程ID的信息，由&lt;code&gt;struct pid_namespace&lt;/code&gt;提供&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct net_ns&lt;/code&gt; 包含所有网络相关的命名空间参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 结构成员 &lt;code&gt;struct nsproxy *nsproxy&lt;/code&gt;保存关联到自身的命名空间视图。因为使用指针，多个进程可以共享一组名字空间，这样，修改给定的命名空间，对所有属于该命名空间的进程都是可见的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;init_nsproxy&lt;/code&gt;定义了初始的全局命名空间，其中维护了指向各子系统初始的命名空间对象的指针：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nsproxy&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init_nsproxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ATOMIC_INIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uts_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_uts_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ipc_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_ipc_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mnt_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_pid_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#ifdef CONFIG_NET
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;net_ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;进程id号&#34;&gt;进程ID号&lt;/h2&gt;
&lt;p&gt;UNIX进程总会分配一个号码用于在命令空间中唯一的标志它们，该号码被称作PID。用fork和clone产生的每个进程都会由内核自动地分配唯一的新的PID值。&lt;/p&gt;
&lt;p&gt;进程除了PID这个值还有其他的ID，有下列几种可能的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处于某个线程组中的所有统一的线程组ID（TGID），如果进程没有使用线程，则PID和TGID相同，线程组中的主进程被称作组长。通过clone组建的所有线程&lt;code&gt;task_struct&lt;/code&gt;的&lt;code&gt;group_leader&lt;/code&gt;成员，会指向组长的&lt;code&gt;task_struct&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;独立进程可以组成进程组（&lt;code&gt;setpgrp&lt;/code&gt;系统调用），进程组成员的&lt;code&gt;task_struct&lt;/code&gt;成员&lt;code&gt;pgrp&lt;/code&gt;属性都相同，即组长PID。&lt;/li&gt;
&lt;li&gt;几个进程组可以合并成一个会话。会话中所有进程都有相同的会话ID，保存在&lt;code&gt;task_struct&lt;/code&gt;的&lt;code&gt;session&lt;/code&gt;成员中。SID可以使用&lt;code&gt;setsid&lt;/code&gt;系统调用设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程关系&#34;&gt;进程关系&lt;/h2&gt;
&lt;p&gt;除了源于ID连接的关系外，内核还负责管理建立在UNIX进程创建模型之上的家族关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果进程A分支形成进程B，进程A称之为父进程二进程B是子进程&lt;/li&gt;
&lt;li&gt;如果进程B再次分支建立进程C，进程A和进程C之间称之为祖孙关系&lt;/li&gt;
&lt;li&gt;如果进程A分支若干次形成B1，B2&amp;hellip; 各个B进程之间成为兄弟进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 数据结构提供了两个链表表头，用于实现这些关系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;children&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sibling&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;进程管理相关的系统调用&#34;&gt;进程管理相关的系统调用&lt;/h1&gt;
&lt;h2 id=&#34;进程复制&#34;&gt;进程复制&lt;/h2&gt;
&lt;p&gt;Linux内核提供三个函数复制进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt;：这是重量级调用，因为它提供了一个完整副本，然后作为子进程执行，为减少调用相关的工作量，Linux使用了写时复制（copy-on-write）技术&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vfork&lt;/code&gt;：类似fork，但并不创建父进程数据副本，相反，父子进程之间共享数据，这节省了大量CPU时间，vfork设计用于子进程执行execve系统调用加载新程序的情况，但由于fork函数实现了写时复制功能，所以vfork在性能方面不再有优势，应避免使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clone&lt;/code&gt; 产生线程，可以对父子进程之间的共享、复制进行精确控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;写时复制&#34;&gt;写时复制&lt;/h2&gt;
&lt;p&gt;内核使用写时复制技术，以防止在&lt;code&gt;fork&lt;/code&gt;执行时将父进程的所有数据复制到子进程，该技术利用了下述事实，进程通常只使用了其内存页的一小部分，在调用&lt;code&gt;fork&lt;/code&gt;时，内核通常会复制父进程的每个内存页，这样有两个不好的负面效应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了大量的内存&lt;/li&gt;
&lt;li&gt;复制操作耗费很长时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果应用程序在进程复制之后使用&lt;code&gt;exec&lt;/code&gt;立即加载程序，那么负面效应会更严重。这意味着，此前复制操作是完全多余的。内核可以使用技巧来规避这个问题，并不复制整个地址空间，而是复制其页表，这样建立了虚拟地址和物理内存页之间的联系。&lt;code&gt;fork&lt;/code&gt;之后父子进程地址空间指向相同的物理内存页。&lt;/p&gt;
&lt;p&gt;这时父子进程不能修改彼此的页，这也是两个进程页表对其标志了只读的原因。如果两个进程只读内存页，二者共享空间不会有问题，只要有一个进程试图向复制的内存页写入，处理器会向内核报告缺页异常。内核查看额外的内存管理数据结构，如果是COW页，内核会创建当前进程的副本。这里的实现需要了解内存管理方面的知识。&lt;/p&gt;
&lt;p&gt;COW机制使得内核尽可能延迟内存页复制，当然大多数情况下，可能都不需要复制，节省了大量的时间。&lt;/p&gt;
&lt;h2 id=&#34;执行系统调用&#34;&gt;执行系统调用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;,&lt;code&gt;vfork&lt;/code&gt;,&lt;code&gt;clone&lt;/code&gt;系统调用的入口分别是&lt;code&gt;sys_fork&lt;/code&gt;,&lt;code&gt;sys_vfork&lt;/code&gt;,&lt;code&gt;sys_clone&lt;/code&gt;函数。其定义依赖于具体的体系结构。上述函数任务是从处理器寄存器中提取用户空间提供的信息，调用体系结构无关的&lt;code&gt;do_fork&lt;/code&gt;函数，后者负责进程复制。函数原型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// kernel/fork.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clone_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stack_start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stack_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent_tidptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;child_tidptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clone_flags&lt;/code&gt; 是一个标志集合，用来指定控制复制过程中的一些属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_stack&lt;/code&gt; 是用户状态下栈的起始地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;regs&lt;/code&gt; 是一个指向寄存器集合的指针，其中以原始形式保存了调用参数。该参数使用的数据类型是特定于体系结构的&lt;code&gt;struct pt_regs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack_size&lt;/code&gt; 是用户状态下栈的大小，通常没有必要，设置为0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parent_tidptr&lt;/code&gt;和&lt;code&gt;child_tidptr&lt;/code&gt; 是指向用户空间中地址的两个指针，分别指向父子进程的TID，NPTL（Native Posix Threads Library）库的线程实现需要这两个参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的fork变体，主要是通过标志集合区分，多数体系结构上，典型的fork调用实现方式于IA-32处理器相同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// arch/x86/kernel/process.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sys_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SIGCHLD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用的唯一标志是 SIGCHLD，这意味着在子进程终止后发送 SIGCHLD 信号通知父进程。如果&lt;code&gt;do_fork&lt;/code&gt;成功，则新建进程的PID作为系统调用的结果返回，否则返回负值错误码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sys_vfork&lt;/code&gt;的实现与&lt;code&gt;sys_fork&lt;/code&gt;只是略微不同，前者使用了额外的标志&lt;code&gt;CLONE_VFORK&lt;/code&gt;和&lt;code&gt;CLONE_VM&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sys_clone&lt;/code&gt;的实现方式与上述调用相似，差别在于&lt;code&gt;do_fork&lt;/code&gt;调用如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// arch/x86/kernel/process_32.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sys_clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clone_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;child_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clone_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;child_tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标志不再是硬编码，可以通过各个寄存器参数传递到系统调用。而且，也不再复制父进程的栈，可以指定新的栈地址。&lt;/p&gt;
&lt;h2 id=&#34;do_fork-的实现&#34;&gt;do_fork 的实现&lt;/h2&gt;
&lt;p&gt;所有三个fork机制最终都调用了&lt;code&gt;do_fork&lt;/code&gt;，其代码流程如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;do_fork
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- copy_process
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 确定PID
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 初始化vfork的完成处理程序
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- wake_up_new_task
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 是否设置了CLONE_VFORK 标志 -&amp;gt; wait_for_completion
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;do_fork&lt;/code&gt;以调用&lt;code&gt;copy_process&lt;/code&gt;开始，后者执行生成新进程的实际工作，根据指定标志重用父进程的数据，子进程生成之后，内核必须执行以下收尾操作：&lt;/p&gt;
&lt;p&gt;进程复制&lt;code&gt;do_fork&lt;/code&gt;实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;copy_process&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;检查标志&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dup_task_struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;检查资源限制&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;初始化&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sched_fork&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;复制进程各个部分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_semundo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_files&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_fs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_sighand&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_signal&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_mm&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_namespaces&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_thread&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;|-----&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;设置各个&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ID&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、进程关系&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;复制进程的行为受到相当多的标志的控制，clone(2) 的手册详细讲述了这些标志，标志可以参考手册。该函数也需要做一些错误判断，Linux函数有时候会在成功的时候返回结构体指针，失败的情况下返回错误码，但函数只能返回一个值，所以Linux做了一个特殊处理，虽然一般而言指针可以指向内存任何位置，而Linux支持的每个体系结构的虚拟地址从0到4Kib的区域，该区域没有任何有意义的信息，因此内核可以重用此地址范围来编码错误。&lt;/p&gt;
&lt;p&gt;当检查完标志后，使用&lt;code&gt;dup_task_struct&lt;/code&gt;来建立父进程&lt;code&gt;task_struct&lt;/code&gt;的副本，父进程的&lt;code&gt;task_struct&lt;/code&gt;实例只有一个成员不同，新进程分配了一个新的核心态，即&lt;code&gt;task_struct-&amp;gt;stack&lt;/code&gt;。通常栈和&lt;code&gt;thread_info&lt;/code&gt;一同保存在一个联合之中，&lt;code&gt;thread_info&lt;/code&gt;保存了线程所需的所有特定于处理器的底层信息。&lt;/p&gt;
&lt;h2 id=&#34;内核线程&#34;&gt;内核线程&lt;/h2&gt;
&lt;p&gt;内核线程是直接由内核本身启动的进程，内核线程实际上是将内核函数委托给独立的进程，内核线程经常称之为守护线程，用于执行下列任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;周期性的修改内存页与页来源块设备同步&lt;/li&gt;
&lt;li&gt;如果内存页很少使用，写入交换区&lt;/li&gt;
&lt;li&gt;管理延迟动作&lt;/li&gt;
&lt;li&gt;实现文件系统的事务日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上，有两种类型的内核线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程启动后一直等待，直至内核请求线程执行某一特定操作&lt;/li&gt;
&lt;li&gt;线程启动后按周期性间隔运行，检测特定资源的使用，在用量超出或低于预期的限制时采取行动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用&lt;code&gt;kernel_thread&lt;/code&gt;函数可启动一个内核线程，定义是特定于体系结构的，但原型总是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kernel_thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;产生的线程将执行用fn指针传递的函数，用arg指定的参数自动传个fn，flags可指定CLONE标志。&lt;code&gt;kernel_thread&lt;/code&gt;第一个任务是构建一个&lt;code&gt;pt_regs&lt;/code&gt;实例，对其中的寄存器指定适当的值，这与普通的&lt;code&gt;fork&lt;/code&gt;类似，接下来调用&lt;code&gt;do_fork&lt;/code&gt;函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CLONE_VM&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CLONE_UNTRACED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;内核线程可以用两种方法实现，古老的方法内核中一些地方仍然在使用该方法，将一个函数直接传递给&lt;code&gt;kernel_thread&lt;/code&gt;，该函数接下来负责帮助内核调用&lt;code&gt;daemonize&lt;/code&gt;以转换为守护进程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该函数从内核线程释放其父进程的所有资源，不然这些资源会一直锁定到线程结束。这是不可取的，因为守护线程通常运行到系统关机，因为守护进程只操作内核地址区域。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;daemonize&lt;/code&gt; 阻塞信号的接收。&lt;/li&gt;
&lt;li&gt;将init用作守护进程的父进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核线程的现代方法是辅助函数&lt;code&gt;kthread_create&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kthread_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threadfn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;namefmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;p&#34;&gt;...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改函数创建一个新的内核线程，其名称由&lt;code&gt;namefmt&lt;/code&gt;给出，最初该线程是停止的，需要使用&lt;code&gt;wake_up_process&lt;/code&gt;启动它，此后，会调用threadfn给出的线程函数，而data则作为参数。&lt;/p&gt;
&lt;p&gt;另一个备选方案是宏&lt;code&gt;kthread_run&lt;/code&gt;，它会调用&lt;code&gt;kthread_create&lt;/code&gt;创建新线程，但立即唤醒它，还可使用&lt;code&gt;kthread_create_cpu&lt;/code&gt;代替&lt;code&gt;kthread_create&lt;/code&gt;创建内核线程，使之绑定到特定的CPU。&lt;/p&gt;
&lt;p&gt;内核线程会出现在系统进程列表中，在ps的输出中由放括号包围，以便与普通进程区分。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cppbreak@ThinkPad:~$ ps fax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  PID TTY      STAT   TIME COMMAND
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    2 ?        S      0:00 [kthreadd]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    3 ?        S      0:00  \_ [ksoftirqd/0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    6 ?        S      0:02  \_ [migration/0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    7 ?        S      0:00  \_ [watchdog/0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    8 ?        S      0:00  \_ [migration/1]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    9 ?        S      0:00  \_ [kworker/1:0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   10 ?        S      0:00  \_ [ksoftirqd/1]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   12 ?        S      0:00  \_ [watchdog/1]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   13 ?        S      0:01  \_ [migration/2]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;启动新程序-execve&#34;&gt;启动新程序 execve&lt;/h2&gt;
&lt;p&gt;Linux 通过用新代码替换现存程序，即可启动新程序。Linux提供的 &lt;code&gt;execve&lt;/code&gt; 系统调用可实现此功能。该函数的入口点是体系相关的&lt;code&gt;sys_execve&lt;/code&gt; 函数，该函数把具体的工作委托给&lt;code&gt;do_execve&lt;/code&gt;实现具体功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_execve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__envp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里不仅用参数传递了寄存器集合和可执行文件的名称filename，而且还传递了指向程序的参数和环境指针。这里argv和envp都是指针数组，而且指向用户空间，&lt;code&gt;__user&lt;/code&gt;注释允许自动化工具检测是否所有处理都正确。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;do_execve&lt;/code&gt; 代码执行流程如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;do_execv
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 打开可执行文件
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- bprm_init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                |----- mm_alloc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                |----- init_new_context
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                |----- __bprm_mm_init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- prepare_binprm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- 复制环境和参数数组内容
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    |----- search_binary_handler
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先要打开可执行文件，换言之，内核找到相关的inode并生成一个文件描述符，用于寻址文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bprm_init&lt;/code&gt;接下来处理若干管理性任务：&lt;code&gt;mm_alloc&lt;/code&gt;生成一个新的&lt;code&gt;mm_struct&lt;/code&gt;实例来管理进程地址空间。&lt;code&gt;init_new_context&lt;/code&gt;是一个特定于体系结构的函数，用于初始化该实例，而&lt;code&gt;__bprm_mm_init&lt;/code&gt;则建立初始化的栈。&lt;/p&gt;
&lt;p&gt;新进程的各个参数，例如euid，egid，参数列表，环境等等，这里会合并成一个类型为&lt;code&gt;linux_binprm&lt;/code&gt;的结构，&lt;code&gt;prepare_binprm&lt;/code&gt;用于提供一些父进程相关的值，特别是 UID 和 GID。&lt;/p&gt;
&lt;p&gt;Linux 支持可执行文件的各种不同组织格式，标准格式是ELF。Linux还支持其他不同的二进制格式，通过函数&lt;code&gt;search_binary_handler&lt;/code&gt;在&lt;code&gt;do_execve&lt;/code&gt;结束时查找一种适当的二进制格式。各种格式根据不同特点（文件开始时的“魔数”）识别。二进制格式处理程序执行以下操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;释放原进程所使用的所有资源&lt;/li&gt;
&lt;li&gt;将应用程序映射到虚拟地址空间中。
&lt;ul&gt;
&lt;li&gt;text段包含程序的可执行代码，&lt;code&gt;start_code&lt;/code&gt;和&lt;code&gt;end_code&lt;/code&gt;指定该段在地址空间中驻留的区域&lt;/li&gt;
&lt;li&gt;预先初始化的数据，位于&lt;code&gt;start_data&lt;/code&gt;和&lt;code&gt;end_data&lt;/code&gt;之间，映射自可执行文件对应段&lt;/li&gt;
&lt;li&gt;堆用户动态内存分配，置于虚拟地址空间中，&lt;code&gt;start_brk&lt;/code&gt;和&lt;code&gt;brk&lt;/code&gt;指定了其边界&lt;/li&gt;
&lt;li&gt;栈的位置由&lt;code&gt;start_stack&lt;/code&gt;定义，大多数计算机的栈都是自动向下增长&lt;/li&gt;
&lt;li&gt;程序的参数和环境也映射到虚拟地址空间中，分别位于&lt;code&gt;arg_start&lt;/code&gt;和&lt;code&gt;arg_end&lt;/code&gt;之间，以及&lt;code&gt;env_start&lt;/code&gt;和&lt;code&gt;env_end&lt;/code&gt;之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设置进程的指令指针和其他特定于体系结构的寄存器，以便在调度器选择该进程时开始执行程序的main函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux内核中，每种二进制格式都表示为下列数据结构的一个实例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linux_binfmt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load_binary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linux_binprm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;pt_regs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;regs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load_shlib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;core_dump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;coredump_params&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cprm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min_coredump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/* minimal dump size */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;linux支持的部分二进制格式有&lt;code&gt;flat_format&lt;/code&gt;, &lt;code&gt;script_format&lt;/code&gt;, &lt;code&gt;misc_format&lt;/code&gt;, &lt;code&gt;elf_format&lt;/code&gt;, &lt;code&gt;elf_fdpic_format&lt;/code&gt;, &lt;code&gt;irix_format&lt;/code&gt;, &lt;code&gt;som_format&lt;/code&gt;, &lt;code&gt;aout_format&lt;/code&gt;。每种二进制格式必须提供下面三个函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;load_binary&lt;/code&gt; 用于加载普通程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load_shlib&lt;/code&gt; 用于加载共享库，即动态库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;core_dump&lt;/code&gt; 用于程序错误的情况下输出内存转储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每种格式首先必须用&lt;code&gt;register_binfmt&lt;/code&gt;向内核注册。该函数的目的是向一个链表增加一个新的二进制格式，该链表的表头是&lt;code&gt;fs/exec.c&lt;/code&gt;中的全局变量&lt;code&gt;formats&lt;/code&gt;，&lt;code&gt;linux_binfmt&lt;/code&gt;实例通过其&lt;code&gt;next&lt;/code&gt;成员彼此连接起来。&lt;/p&gt;
&lt;h2 id=&#34;退出进程&#34;&gt;退出进程&lt;/h2&gt;
&lt;p&gt;进程必须用exit系统调用终止，这使得内核有机会将该进程使用的资源放回系统。该调用的入口点是 &lt;code&gt;sys_exit&lt;/code&gt; 函数，需要一个错误码作为其参数，以便退出进程，最终调用&lt;code&gt;do_exit&lt;/code&gt;函数实现，该函数实现就是将各个引用计数器减1。如果引用计数器归0就将相应的内存区域返还给内存管理模块。&lt;/p&gt;
&lt;h1 id=&#34;调度器的实现&#34;&gt;调度器的实现&lt;/h1&gt;
&lt;p&gt;内存中保存了对每个进程的唯一描述，通过若干结构与其他进程连接起来，调度器任务便是程序之间共享CPU时间，创造并执行的错觉，该任务分为两个不同部分：一个涉及调度策略，另一个涉及上下文切换。&lt;/p&gt;
&lt;h2 id=&#34;概观&#34;&gt;概观&lt;/h2&gt;
&lt;p&gt;内核必须提供一种方法，在进程之间尽可能公平地共享CPU时间，而同时又要考虑不同的任务优先级。&lt;code&gt;schedule&lt;/code&gt;函数是理解调度操作的起点，该函数定义在&lt;code&gt;kernel/sched.c&lt;/code&gt;中，是内核代码最常用的函数之一。&lt;/p&gt;
&lt;h1 id=&#34;完全公平调度类&#34;&gt;完全公平调度类&lt;/h1&gt;
&lt;h1 id=&#34;实时调度类&#34;&gt;实时调度类&lt;/h1&gt;
&lt;h1 id=&#34;调度器增强&#34;&gt;调度器增强&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-启动协议</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-boot-protocol/</link>
        <pubDate>Thu, 22 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-boot-protocol/</guid>
        <description>&lt;p&gt;Linux 是非常出色的操作系统，通过阅读内核源码，能够清楚的理解现代操作系统的构架和任意细节，但 Linux 内核代码非常庞大，而且有很多与硬件相关的细节，阅读代码有些吃力，不过只要了解内核代码的构架，可对自己迷惑的部分单独分析。&lt;/p&gt;
&lt;p&gt;我在这里对我分析的部分做一个记录，一来防止以后遗忘，二来把分析过程写出来能更加清楚的理解内核。分析的内核版本为 2.6.34，可从 这里 下载，或者使用 lxr 在线阅读代码。&lt;/p&gt;
&lt;p&gt;Linux源码 arch 目录下是构架相关的代码，其中有x86，arm等不同平台的实现，这里仅看x86平台，boot目录是系统启动部分代码，我将会逐一分析启动代码。&lt;/p&gt;
&lt;p&gt;2.6.34 版本较之以前有了很大的变动，内核启动过程需要大量的汇编操作，这个版本尽量去除汇编，仅仅在必须的地方提供汇编提供接口，供c代码调用。&lt;/p&gt;
&lt;p&gt;先来看引导协议部分代码， arch/x86/boot/header.S&lt;/p&gt;
&lt;p&gt;在之前BIOS中断部分讲过引导程序，位于启动介质0柱面0磁道1扇区的512字节，以0x55AA结尾，header.S中也同样含有这段代码，但是仅仅输出几行文字，并没有做实质性操作，Linux内核把引导的工作交付给专业的引导程序如grub、lilo，BIOS启动时首先加载grub程序，grub作为引导程序根据配置再去加载相应的内核。如此一来便需要grub和内核之间遵循一定的协议，协议文档位于 linux-2.6.34\Documentation\x86\boot.txt，可以作为参考。&lt;/p&gt;
&lt;p&gt;header.S开始的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	.code16
	.section &amp;quot;.bstext&amp;quot;, &amp;quot;ax&amp;quot;

	.global bootsect_start
bootsect_start:

	# Normalize the start address
	ljmp	$BOOTSEG, $start2

start2:
	movw	%cs, %ax
	movw	%ax, %ds
	movw	%ax, %es
	movw	%ax, %ss
	xorw	%sp, %sp
	sti
	cld

	movw	$bugger_off_msg, %si

msg_loop:
	lodsb
	andb	%al, %al
	jz	bs_die
	movb	$0xe, %ah
	movw	$7, %bx
	int	$0x10
	jmp	msg_loop

bs_die:
	# Allow the user to press a key, then reboot
	xorw	%ax, %ax
	int	$0x16
	int	$0x19

	# int 0x19 should never return.  In case it does anyway,
	# invoke the BIOS reset code...
	ljmp	$0xf000,$0xfff0

	.section &amp;quot;.bsdata&amp;quot;, &amp;quot;a&amp;quot;
bugger_off_msg:
	.ascii	&amp;quot;Direct booting from floppy is no longer supported.\r\n&amp;quot;
	.ascii	&amp;quot;Please use a boot loader program instead.\r\n&amp;quot;
	.ascii	&amp;quot;\n&amp;quot;
	.ascii	&amp;quot;Remove disk and press any key to reboot . . .\r\n&amp;quot;
	.byte	0

	# Kernel attributes; used by setup.  This is part 1 of the
	# header, from the old boot sector.

	.section &amp;quot;.header&amp;quot;, &amp;quot;a&amp;quot;
	.globl	hdr
hdr:
setup_sects:	.byte 0			/* Filled in by build.c */
root_flags:	.word ROOT_RDONLY
syssize:	.long 0			/* Filled in by build.c */
ram_size:	.word 0			/* Obsolete */
vid_mode:	.word SVGA_MODE
root_dev:	.word 0			/* Filled in by build.c */
boot_flag:	.word 0xAA55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分是完整的引导区代码，这段代码有三个段，.bstext .bsdata .header，由编译脚本setup.ld可以看到，.header是编译到497地址，除去一些变量，到boot_flag: .word 0xAA55刚好位于512字节，是一个引导扇区的长度。.bsdata 段仅定义了一个字符串，指明boot方式不再支持。&lt;/p&gt;
&lt;p&gt;来看下代码部分 .bstext 段，首先由start2初始化一些变量，&lt;code&gt;msg_loop&lt;/code&gt;调用int $0×10输出文字，bs_die部分首先调用int $0×16输入一个字符，然后调用int $0×19重启系统。&lt;/p&gt;
&lt;p&gt;可以看到这里的引导程序并没有做什么操作，也不会被执行到，真正的代码再之后才开始，之前说过内核的引导是靠grub等引导程序，他们之间有一定的协议，协议有一个协议头，再看header.S之后的代码都是一些变量的定义，所以得先看一下协议头到底是什么，在boot.txt文档中有以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The header looks like:

Offset	Proto	Name		Meaning
/Size

01F1/1	ALL(1	setup_sects	The size of the setup in sectors
01F2/2	ALL	root_flags	If set, the root is mounted readonly
01F4/4	2.04+(2	syssize		The size of the 32-bit code in 16-byte paras
01F8/2	ALL	ram_size	DO NOT USE - for bootsect.S use only
01FA/2	ALL	vid_mode	Video mode control
01FC/2	ALL	root_dev	Default root device number
01FE/2	ALL	boot_flag	0xAA55 magic number
0200/2	2.00+	jump		Jump instruction
0202/4	2.00+	header		Magic signature &amp;quot;HdrS&amp;quot;
0206/2	2.00+	version		Boot protocol version supported
...
0258/8	2.10+	pref_address	Preferred loading address
0260/4	2.10+	init_size	Linear memory required during initialization
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说的正是协议头的定义，这里的01F1/1前面表示地址，后面表示大小，01F1十进制为497，刚好与.header段的起始地址相同，看来，.header段名副其实，正是启动协议的头部信息，一直到236行的init_size定义为止。头部内容的详细信息在boot.txt文件中已有详细解释，不过现在还不需要知道，头部大部分信息由grub填充，供操作系统使用。后面会看到内核获取这些信息。&lt;/p&gt;
&lt;p&gt;好了，header.S后面的.entrytext段就是真正的内核入口了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	movw	$0x0000, %ax		# Reset disk controller
	movb	$0x80, %dl		# All disks
	int	$0x13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里调用BIOS的13号中断重置硬盘。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	movw	$__bss_start, %di
	movw	$_end+3, %cx
	xorl	%eax, %eax
	subw	%di, %cx
	shrw	$2, %cx
	rep; stosl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__bss_start&lt;/code&gt;是bss段的起始地址，_end为结束位置，这两个符号定义于setup.ld脚本，这段代码既是对此段清零。&lt;/p&gt;
&lt;p&gt;接下来调用main函数 calll main，这里的main是c函数，定义于main.c。&lt;/p&gt;
&lt;p&gt;之后有符号&lt;code&gt;setup_bad&lt;/code&gt;，调用puts输出”No setup signature found…\n”，最后定义了一个函数die，执行休息指令hlt的死循环。&lt;/p&gt;
&lt;p&gt;最后再来看main函数中的开始部分代码 linux-2.6.34\arch\x86\boot\main.c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void main(void)
{
	/* First, copy the boot header into the &amp;quot;zeropage&amp;quot; */
	copy_boot_params();

	/* End of heap check */
	init_heap();
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到main首先调用copy_boot_params函数，在29行有其定义，其中关键的一句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;memcpy(&amp;amp;boot_params.hdr, &amp;amp;hdr, sizeof hdr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hdr 是引导协议头部0x1f1地址处，即刚才分析的.header段开始的标号，&lt;code&gt;boot_params&lt;/code&gt;为结构体&lt;code&gt;boot_params&lt;/code&gt;的实例，存储启动参数相关信息，结构定义于arch/x86/include/asm/bootparam.h:85，成员hdr定义为&lt;code&gt;struct setup_header hdr;&lt;/code&gt;而&lt;code&gt;setup_header&lt;/code&gt;结构定义于相同文件的24行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct setup_header {
	__u8	setup_sects;
	__u16	root_flags;
	__u32	syssize;
	__u16	ram_size;
#define RAMDISK_IMAGE_START_MASK	0x07FF
#define RAMDISK_PROMPT_FLAG		0x8000
#define RAMDISK_LOAD_FLAG		0x4000
	__u16	vid_mode;
	__u16	root_dev;
	__u16	boot_flag;
	__u16	jump;
	__u32	header;
	__u16	version;
	__u32	realmode_swtch;
	__u16	start_sys;
	__u16	kernel_version;
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到其中的成员正是引导协议头部，拷贝代码正是把grub填充的启动信息复制到结构实例boot_params.hdr中，以便在c程序中使用。&lt;/p&gt;
&lt;p&gt;最后总结一下grub的引导过程，grub被BIOS载入内存并获得控制权后，读取配置信息/boot/grub.conf，载入实模式代码到0×090000，并根据内核镜像的前512字节中的.header信息，将大内核载入到内存，并交控制权于内核执行。载入内存地址的计算公式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;is_bzImage = (protocol &amp;gt;= 0x0200) &amp;amp;&amp;amp; (loadflags &amp;amp; 0x01);
load_address = is_bzImage ? 0x100000 : 0x10000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里通过分析header.S，对引导协议做了一些说明，更详尽的说明在文档 Documentation\x86\boot.txt，可随时对其查阅。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-VFS</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-vfs-source/</link>
        <pubDate>Wed, 21 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-vfs-source/</guid>
        <description>&lt;p&gt;Linux 文件系统有着复杂的结构，仅仅概念就有file，dentry，inode，vfsmount，super_block等等，还有他们之间的关联，细节虽然繁多，但只要抓住主干框架，其他的细节通过阅读源码都可顺利成章的理解。这里Linux运行平台版本和分析的源码都以linux-2.6.36.2作为基准，其他相近版本的差别很小。也很容易理解。这里先归纳一下 Linux 文件系统的概念和机制。&lt;/p&gt;
&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;之前已经提到，Linux 文件系统的概念繁多，这里做一些简短的介绍，不会清楚解释每一个细节，只会去“感性”的解释，程序虽然是一种很理性化的东西，但想以一个更高的层次去看他，必须对其有所“感觉”。&lt;/p&gt;
&lt;h2 id=&#34;分层&#34;&gt;分层&lt;/h2&gt;
&lt;p&gt;Linux 秉承了 Unix 的 KISS 原则：Keep It Simple, Stupid！简洁的一个最主要体现就是：万物皆文件。不论是虚拟文件，或是驱动设备，对用户态程序而言都与操作普通文件方式无异（也有少数设备操作例外，比如网络设备）。这种机制的实现得益于VFS，VFS作为一个中间层，抽象底层驱动的差异。万物皆文件的思想与Java中的万物皆对象的思想相同，都是面向对象的体现，所不同的是，万物皆文件是从更高层次进行抽象，VFS仅仅为一个接口层，底层的文件系统或者设备驱动都是接口的实现，这便是多态的思想，只不过C++的类多态机制是细节上的多态，而Linux的多态却是系统级别的多态；类级别的多态容易跌入细节的泥沼，而系统级别的面向对象实现可以合理的为体系分层，使实现更为清晰，虽然面向对象，但仍保持 Simple，Linux 虽然使用纯 C 实现，却是体现面向对象思想的典范。&lt;/p&gt;
&lt;p&gt;VFS 作为一个接口层，需要对上层提供统一的调用接口，同时又要为底层提供实现接口，以致VFS需要引入一些概念。&lt;/p&gt;
&lt;h2 id=&#34;inode&#34;&gt;inode&lt;/h2&gt;
&lt;p&gt;内核使用 inode 表示文件信息数据，最重要的是存储了文件操作的集合 file_operations 和 inode 集合 &lt;code&gt;inode_operations&lt;/code&gt; ，这里的操作集合全部是函数指针，作为抽象接口，具体函数由底层设备提供。&lt;code&gt;file_operations&lt;/code&gt; 实现文件内容操作，如read、write等等，&lt;code&gt;inode_operations&lt;/code&gt; 实现 inode 本身操作，如mkdir, link 等等，另外，inode并非硬盘中的实体，仅存在于内存。&lt;/p&gt;
&lt;h2 id=&#34;file&#34;&gt;file&lt;/h2&gt;
&lt;p&gt;inode 对所有进程可见，仍有一套进程相关的结构，files_struct保存打开文件信息，其中包含 file 结构，file 结构包含文件读写偏移。另外进程还保存一套文件系统信息 fs_struct。&lt;/p&gt;
&lt;h2 id=&#34;dentry&#34;&gt;dentry&lt;/h2&gt;
&lt;p&gt;dentry 为目录缓存，包含目录对应 inode，以及 dentry_operations，以及 d_subdirs 子文件子目录列表。&lt;/p&gt;
&lt;h2 id=&#34;file_system_type&#34;&gt;file_system_type&lt;/h2&gt;
&lt;p&gt;file_system_type 用来表示文件系统，比如 ext2，ext3 结构，所有文件系统组成链表，新文件系统使用 &lt;code&gt;register_filesystem&lt;/code&gt; 向内核注册，函数只是简单的把 &lt;code&gt;file_system_type&lt;/code&gt; 插入链表，其中最关键的成员就是 get_sb，得到 &lt;code&gt;super_block&lt;/code&gt; 结构。&lt;/p&gt;
&lt;h2 id=&#34;super_block&#34;&gt;super_block&lt;/h2&gt;
&lt;p&gt;super_block 储存了文件系统本身和挂载点有关信息，设备块大小，所有inode链表。&lt;/p&gt;
&lt;h2 id=&#34;vfsmount&#34;&gt;vfsmount&lt;/h2&gt;
&lt;p&gt;对于挂接点，还需保存一个 vfsmount 结构，保存了挂接信息，每一个挂接点都包含一个 vfsmount 结构实体。vfsmount 和 &lt;code&gt;super_block&lt;/code&gt; 对与挂接点来说，都是唯一的。&lt;/p&gt;
&lt;h2 id=&#34;path&#34;&gt;path&lt;/h2&gt;
&lt;p&gt;path 包含 vfsmount 和 dentry 结构。&lt;/p&gt;
&lt;h2 id=&#34;nameidata&#34;&gt;nameidata&lt;/h2&gt;
&lt;p&gt;nameidata 结构用于查找，想查找函数传递参数，并保存结果，包括 dentry 和 vfsmount 结构。&lt;/p&gt;
&lt;h1 id=&#34;sys_mount-实现&#34;&gt;sys_mount 实现&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sys_mount&lt;/code&gt; 展现了文件系统加载的所有细节，为学习文件系统提供一个很好的切入点，首先来看 &lt;code&gt;sys_mount&lt;/code&gt; 的函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 源码中的原型
SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,
		char __user *, type, unsigned long, flags, void __user *, data)

# 根据宏推演开来展现原型
#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)

#define SYSCALL_DEFINEx(x, sname, ...)				\
	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__

#define __SYSCALL_DEFINEx(x, name, ...)					\
	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__)

#define __SC_DECL1(t1, a1)	t1 a1
#define __SC_DECL2(t2, a2, ...) t2 a2, __SC_DECL1(__VA_ARGS__)
#define __SC_DECL3(t3, a3, ...) t3 a3, __SC_DECL2(__VA_ARGS__)
#define __SC_DECL4(t4, a4, ...) t4 a4, __SC_DECL3(__VA_ARGS__)
#define __SC_DECL5(t5, a5, ...) t5 a5, __SC_DECL4(__VA_ARGS__)

# 最终展开宏之后的原型为
asmlinkage long sys_mount(char __user * dev_name, char __user * dir_name,	\
		char __user * type, unsigned long flags, void __user * data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数 dev_name 是设备名，如/dev/sda1；dir_name 是目标挂接点路径，如/mnt/target/；type 是文件系统类型，如ext2、ext3等；flags 是mount标志；data是附加选项值。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;sys_mount&lt;/code&gt;的字符串参数都是 &lt;code&gt;__user&lt;/code&gt; 内存，所以在 sys_mount 开始处，首先使用&lt;code&gt;copy_mount_string&lt;/code&gt;等函数把用户空间的字串复制到内核空间。之后再去调用 &lt;code&gt;do_mount&lt;/code&gt; 完成具体的操作。&lt;code&gt;do_mount&lt;/code&gt; 的原型与 &lt;code&gt;sys_mount&lt;/code&gt; 相对应，仅是参数全部已经转换成内核空间的地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long do_mount(char *dev_name, char *dir_name, char *type_page,
		  unsigned long flags, void *data_page)
{
	/** 省略无关部分 */

	/* ... and get the mountpoint */
	retval = kern_path(dir_name, LOOKUP_FOLLOW, &amp;amp;path);
	if (retval)
		return retval;

	retval = security_sb_mount(dev_name, &amp;amp;path,
				   type_page, flags, data_page);
	if (retval)
		goto dput_out;

	/** 省略flags判断分支 */

		retval = do_new_mount(&amp;amp;path, type_page, flags, mnt_flags,
				      dev_name, data_page);
dput_out:
	path_put(&amp;amp;path);
	return retval;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;do_mount&lt;/code&gt; 的主干是非常清晰的，开始省去一些参数校验代码，紧接着调用 &lt;code&gt;kern_path&lt;/code&gt; 根据 &lt;code&gt;dir_name&lt;/code&gt; 指示的路径名获取其 path 结构，&lt;code&gt;security_sb_mount&lt;/code&gt; 做一些安全校验工作，如果没有设置，这个函数为空，否则去调用 &lt;code&gt;security_ops-&amp;gt;sb_mount&lt;/code&gt; 成员实现。这里不去研究 LSM 安全模块，省去这个函数的分析。紧接着根据flags进行判断，决定是重新加载，或者移动，或者更改文件系统，这里仅跟加载新的 mount 作为分析对象，其他部分类似。最后使用&lt;code&gt;path_put&lt;/code&gt;回收path资源。&lt;/p&gt;
&lt;p&gt;这里可以看书，&lt;code&gt;do_mount&lt;/code&gt;其实也只是一个分发函数，首先获得path，然后调用各分支的mount函数，接下来分析 &lt;code&gt;kern_path&lt;/code&gt; 和 &lt;code&gt;do_new_mount&lt;/code&gt; 函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int kern_path(const char *name, unsigned int flags, struct path *path)
{
	struct nameidata nd;
	int res = do_path_lookup(AT_FDCWD, name, flags, &amp;amp;nd);
	if (!res)
		*path = nd.path;
	return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kern_path&lt;/code&gt; 很明显，构建一个 nameidata 对象，使用 &lt;code&gt;do_path_lookup&lt;/code&gt; 函数由路径名 name 得到 nameidata 对象，path 仅是 nameidata 对象的一个成员，把这个成员返回给上层。也就是 &lt;code&gt;kern_path&lt;/code&gt; 调用了更为广泛的 &lt;code&gt;do_path_lookup&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int do_path_lookup(int dfd, const char *name,
				unsigned int flags, struct nameidata *nd)
{
	int retval = path_init(dfd, name, flags, nd);
	if (!retval)
		retval = path_walk(name, nd);
	if (unlikely(!retval &amp;amp;&amp;amp; !audit_dummy_context() &amp;amp;&amp;amp; nd-&amp;gt;path.dentry &amp;amp;&amp;amp;
				nd-&amp;gt;path.dentry-&amp;gt;d_inode))
		audit_inode(name, nd-&amp;gt;path.dentry);
	if (nd-&amp;gt;root.mnt) {
		path_put(&amp;amp;nd-&amp;gt;root);
		nd-&amp;gt;root.mnt = NULL;
	}
	return retval;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;do_path_lookup&lt;/code&gt; 又去调用了 &lt;code&gt;path_init&lt;/code&gt; 和 &lt;code&gt;path_walk&lt;/code&gt; 函数实现功能，&lt;code&gt;path_init&lt;/code&gt; 代码很易懂，根据路径名 name 获取当前相对 name 的 nameidata 结构，如果 name 是以/开始的绝对路径，&lt;code&gt;nameidata-&amp;gt;path&lt;/code&gt; 即为根，否则，如果name是相对路径，nameidata-&amp;gt;path 为当前路径的path，也就是不管name是相对路径还是绝对的，对此时的 nameidata 来讲都可以认为是相对路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;path_walk&lt;/code&gt; 便是根据 nameidata 找到相对路径 name 的 path 节点。&lt;code&gt;path_walk&lt;/code&gt; 本身也没有做这件事，只是把参数又传递给 &lt;code&gt;link_path_walk&lt;/code&gt; 去具体操作，&lt;code&gt;link_path_walk&lt;/code&gt; 的操作便复杂了许多，需要处理各种奇怪的路径名，这里先无视这段复杂的代码，继续向后分析，至少已经知道 &lt;code&gt;link_path_walk&lt;/code&gt; 所实现的功能，不怕他写的复杂，就怕你猜不到他在做什么。&lt;/p&gt;
&lt;p&gt;如此便已清楚 &lt;code&gt;kern_path&lt;/code&gt; 的功能，接下来看 &lt;code&gt;do_new_mount&lt;/code&gt; 的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int do_new_mount(struct path *path, char *type, int flags,
			int mnt_flags, char *name, void *data)
{
	struct vfsmount *mnt;

	if (!type)
		return -EINVAL;

	/* we need capabilities... */
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	lock_kernel();
	mnt = do_kern_mount(type, flags, name, data);
	unlock_kernel();
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	return do_add_mount(mnt, path, mnt_flags, NULL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;do_new_mount&lt;/code&gt; 也分为两步，第一步调用 &lt;code&gt;do_kern_mount&lt;/code&gt; 创建 vfsmount 挂接点结构，之后调用 &lt;code&gt;do_add_mount&lt;/code&gt; 挂接 mnt 到文件系统树。再来一步一步分析，从 &lt;code&gt;do_kern_mount&lt;/code&gt; 开始：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct vfsmount *
do_kern_mount(const char *fstype, int flags, const char *name, void *data)
{
	struct file_system_type *type = get_fs_type(fstype);
	struct vfsmount *mnt;
	if (!type)
		return ERR_PTR(-ENODEV);
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) &amp;amp;&amp;amp; (type-&amp;gt;fs_flags &amp;amp; FS_HAS_SUBTYPE) &amp;amp;&amp;amp;
	    !mnt-&amp;gt;mnt_sb-&amp;gt;s_subtype)
		mnt = fs_set_subtype(mnt, fstype);
	put_filesystem(type);
	return mnt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;do_kern_mount&lt;/code&gt; 从主干来看，首先调用 &lt;code&gt;get_fs_type&lt;/code&gt; 得到文件系统的 &lt;code&gt;file_system_type&lt;/code&gt; 结构，之后调用 &lt;code&gt;vfs_kern_mount&lt;/code&gt; 生成 vfsmount 结构。&lt;code&gt;get_fs_type&lt;/code&gt; 所作工作比较简单，直接调用&lt;code&gt;__get_fs_type&lt;/code&gt;函数从当前已加载的 &lt;code&gt;file_systems&lt;/code&gt; 查找对应文件系统，如果未找到，便以文件系统名为模块名调用 request_module 加载模块，如果加载成功，对应模块会调用 &lt;code&gt;register_filesystem&lt;/code&gt; 把自己的 &lt;code&gt;file_system_type&lt;/code&gt; 结构插入 &lt;code&gt;file_systems&lt;/code&gt; 链表，&lt;code&gt;get_fs_type&lt;/code&gt;会再次进行查找。如果查找失败，便返回 NULL。&lt;/p&gt;
&lt;p&gt;在得到 &lt;code&gt;file_system_type&lt;/code&gt; 文件系统结构后，调用 &lt;code&gt;vfs_kern_mount&lt;/code&gt; 创建 mnt 挂接点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct vfsmount *
vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
{
	/** 省去无关代码 */
	mnt = alloc_vfsmnt(name);
	if (!mnt)
		goto out;

	if (flags &amp;amp; MS_KERNMOUNT)
		mnt-&amp;gt;mnt_flags = MNT_INTERNAL;

	/** 省去无关代码 */

	error = type-&amp;gt;get_sb(type, flags, name, data, mnt);
	if (error &amp;lt; 0) 		goto out_free_secdata; 	/** 省去 LSM 安全模块代码 */ 	mnt-&amp;gt;mnt_mountpoint = mnt-&amp;gt;mnt_root;
	mnt-&amp;gt;mnt_parent = mnt;
	up_write(&amp;amp;mnt-&amp;gt;mnt_sb-&amp;gt;s_umount);
	free_secdata(secdata);
	return mnt;

	/** 省去错误清理代码 */

	return ERR_PTR(error);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过抽取函数的骨干，可以清楚看到函数所作操作，首先 alloc_vfsmnt 为 vfsmount 结构分配空间，并初始化成员。再调用对应文件系统的 file_system_type 成员 get_sb 填充 mnt结构。分配空间并初始化代码并无关键之处，而 get_sb 函数却是相应文件系统的实现，比如 ext2 的 ext2_get_sb 函数。&lt;/p&gt;
&lt;p&gt;先不去研究文件系统的具体实现，这与VFS无关，&lt;code&gt;do_kern_mount&lt;/code&gt; 便以分析完毕，所作功能便是为 vfsmount 分配空间，再去调用文件系统的 &lt;code&gt;get_sb&lt;/code&gt; 实现填充 vfsmount 结构。&lt;/p&gt;
&lt;p&gt;接下来查看 &lt;code&gt;do_add_mount&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int do_add_mount(struct vfsmount *newmnt, struct path *path,
		 int mnt_flags, struct list_head *fslist)
{
	int err;

	mnt_flags &amp;amp;= ~(MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL);

	down_write(&amp;amp;namespace_sem);
	/* Something was mounted here while we slept */
	while (d_mountpoint(path-&amp;gt;dentry) &amp;amp;&amp;amp;
	       follow_down(path))
		;
	err = -EINVAL;
	if (!(mnt_flags &amp;amp; MNT_SHRINKABLE) &amp;amp;&amp;amp; !check_mnt(path-&amp;gt;mnt))
		goto unlock;

	/* Refuse the same filesystem on the same mount point */
	err = -EBUSY;
	if (path-&amp;gt;mnt-&amp;gt;mnt_sb == newmnt-&amp;gt;mnt_sb &amp;amp;&amp;amp;
	    path-&amp;gt;mnt-&amp;gt;mnt_root == path-&amp;gt;dentry)
		goto unlock;

	err = -EINVAL;
	if (S_ISLNK(newmnt-&amp;gt;mnt_root-&amp;gt;d_inode-&amp;gt;i_mode))
		goto unlock;

	newmnt-&amp;gt;mnt_flags = mnt_flags;
	if ((err = graft_tree(newmnt, path)))
		goto unlock;

	if (fslist) /* add to the specified expiration list */
		list_add_tail(&amp;amp;newmnt-&amp;gt;mnt_expire, fslist);

	up_write(&amp;amp;namespace_sem);
	return 0;

unlock:
	up_write(&amp;amp;namespace_sem);
	mntput(newmnt);
	return err;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数开始调用 &lt;code&gt;d_mountpoint&lt;/code&gt; 和 &lt;code&gt;follow_down&lt;/code&gt; 查看是否已经有 mnt 挂接到 path 位置，之后便调用 &lt;code&gt;graft_tree&lt;/code&gt; 把 newmnt 挂接到 path 位置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int graft_tree(struct vfsmount *mnt, struct path *path)
{
	int err;
	if (mnt-&amp;gt;mnt_sb-&amp;gt;s_flags &amp;amp; MS_NOUSER)
		return -EINVAL;

	/** 检测是否文件夹 */
	if (S_ISDIR(path-&amp;gt;dentry-&amp;gt;d_inode-&amp;gt;i_mode) !=
	      S_ISDIR(mnt-&amp;gt;mnt_root-&amp;gt;d_inode-&amp;gt;i_mode))
		return -ENOTDIR;

	err = -ENOENT;
	mutex_lock(&amp;amp;path-&amp;gt;dentry-&amp;gt;d_inode-&amp;gt;i_mutex);

	/** 检测路径的标志，是否允许 mount */
	if (cant_mount(path-&amp;gt;dentry))
		goto out_unlock;

	/** 挂接 mnt */
	if (!d_unlinked(path-&amp;gt;dentry))
		err = attach_recursive_mnt(mnt, path, NULL);
out_unlock:
	mutex_unlock(&amp;amp;path-&amp;gt;dentry-&amp;gt;d_inode-&amp;gt;i_mutex);
	return err;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看来这里的关键点便是 &lt;code&gt;attach_recursive_mnt&lt;/code&gt; 函数，它挂接 mnt 到 path 路径上，甚至内核源码本身也为这个函数使用了很大篇幅的注释。此函数调用 &lt;code&gt;mnt_set_mountpoint&lt;/code&gt; ，增加目标挂接点 mounted 计数，最后调用 &lt;code&gt;commit_tree&lt;/code&gt; 把当前 mnt 添加至全局散列表和父文件系统的子文件系统链。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核笔记-中断和异常</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-interrupt-and-exception/</link>
        <pubDate>Tue, 20 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-interrupt-and-exception/</guid>
        <description>&lt;h1 id=&#34;中断和异常的定义&#34;&gt;中断和异常的定义&lt;/h1&gt;
&lt;p&gt;中断和异常其实都属于中断，中断分为同步中断和异步中断，同步中断指处理器发生的异常，如除0错误；异步中断指CPU外部事件引发，如IO设备中断，因为中断可以发生在任何时刻，与当前CPU时钟周期没有任何关系。&lt;/p&gt;
&lt;p&gt;为了描述简单，通常称异步中断为中断，同步中断为异常。&lt;/p&gt;
&lt;h1 id=&#34;中断分类&#34;&gt;中断分类：&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;faults类异常：系统可以恢复，需要重新执行导致异常的指令。
traps类型异常：系统可以恢复，用户取得系统服务的一种手段。
abort异常：不可恢复。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中断分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可屏蔽中断&lt;/li&gt;
&lt;li&gt;不可屏蔽中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断描述符表IDT用于存放中断和异常处理函数信息，其中中断描述符表中的每个表项由8个字节组成，叫门描述符。&lt;/p&gt;
&lt;p&gt;Linux内核中中断请求IRQ用数据结构 &lt;code&gt;struct irq_desc&lt;/code&gt; 表示。&lt;/p&gt;
&lt;p&gt;中断描述符表初始化，在&lt;code&gt;start_kernel&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;异常初始化 strap_init
中断初始化 init_IRQ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中断处理过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;驱动程序调用 request_irq请求中断号为irq的中断请求线的使用权
内核`common_interrrpt`调用`do_IRQ`
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;异常处理过程&#34;&gt;异常处理过程：&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;响应的处理程序执行
do_trap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;延时处理机制&lt;/p&gt;
&lt;p&gt;由于中断处理必须非常快，当系统穿过中断门后系统处于中断禁用状态，这时系统要么不能响应所有外部中断，要么不能响应当前中断源的中断，在这个过程中，会导致新的中断无法及时处理或者丢失中断请求。&lt;/p&gt;
&lt;p&gt;Linux内核提供的延时机制分为softirq，tasklet，work queue。&lt;/p&gt;
&lt;h1 id=&#34;softirq机制&#34;&gt;softirq机制：&lt;/h1&gt;
&lt;p&gt;softirq在内核中由结构体&lt;code&gt;softirq_action&lt;/code&gt;表示，内核预设的softirq存储于&lt;code&gt;softirq_vec&lt;/code&gt;数组中，初始化函数为：&lt;code&gt;open_softirq&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;系统运行过程中，会在合适的地方调用&lt;code&gt;local_softirq_pending&lt;/code&gt;检查是否游softirq需要处理，如果需要便调用函数do_softirq处理，这些检查点包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;中断处理退出函数irq_exit
内核线程ksoftirqd
内核网络子系统显示调用
local_bh_enable
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;tasklet延时处理机制&#34;&gt;tasklet延时处理机制：&lt;/h1&gt;
&lt;p&gt;tasklet在内核中的表示tasklet_struct，这个结构描述了处理函数等信息，该结构可以使用DECLARE_TASKLET或者DECLARE_TASKLET_DISABLED宏进行定义。在中断处理上半部会调用 tasklet_schedule函数激活下半部的处理。最终系统会调用tasklet_action处理任务。&lt;/p&gt;
&lt;p&gt;work queue延时处理：&lt;/p&gt;
&lt;p&gt;内核使用&lt;code&gt;workqueue_struct&lt;/code&gt;记录工作队列信息，每个具体work由结构&lt;code&gt;work_struct&lt;/code&gt;定义，初始化工作队列可以用函数&lt;code&gt;create_workqueue&lt;/code&gt;，激活工作队列使用&lt;code&gt;schedule_work&lt;/code&gt;，处理工作队列函数&lt;code&gt;run_workqueue&lt;/code&gt;。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linxu内核笔记-虚拟地址空间</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-virtual-address/</link>
        <pubDate>Tue, 20 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-virtual-address/</guid>
        <description>&lt;p&gt;在程序中打印变量地址时，往往再不同的程序中都可能打印相同的地址，显然他们并不是占用相同的物理空间，他们之所以地址相同，得益于内核提供的虚拟地址空间的机制。&lt;/p&gt;
&lt;p&gt;在进程结构 &lt;code&gt;task_struct&lt;/code&gt; 中包含一个&lt;code&gt;mm_struct&lt;/code&gt;实例，这个实例便保存的进程的虚拟地址空间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct mm_struct {
        struct vm_area_struct * mmap;           /* list of VMAs */
        struct rb_root mm_rb;
        struct vm_area_struct * mmap_cache;     /* last find_vma result */
        ...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vm_area_struct&lt;/code&gt;结构中存储映射的虚拟内存细节，每个&lt;code&gt;vm_area_struct&lt;/code&gt;节点即存储在单链表mmap中，又存储于红黑树&lt;code&gt;mm_rb&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;内核提供了若干函数对内存映射区域操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查找给定地址后的第一个区域  find_vma
确认边界区间是否在一个现存的vma区域 find_vma_intersection
区域合并 vma_merge
插入区域 insert_vm_struct
创建区域 get_unmapped_area
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;物理内存和虚拟地址的映射通过 &lt;code&gt;vm_area_struct&lt;/code&gt;中的函数指针&lt;code&gt;vm_operations_struct&lt;/code&gt;来对应，这里的映射函数不了解设备的具体信息，需要file的一个成员&lt;code&gt;address_space&lt;/code&gt;来补充，二者通常使用以下方式关联：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const struct vm_operations_struct generic_file_vm_ops = {
        .fault          = filemap_fault,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虚拟地址的映射可以通过系统调用 mmap和munmap。&lt;/p&gt;
&lt;p&gt;堆是进程中动态分配内存的内存区域，对程序员来说使用malloc便可分配内存，使用起来非常便捷，但是malloc在用户态做了很多操作，对底层地用来讲，仅仅使用brk来扩张和收缩堆。&lt;/p&gt;
&lt;p&gt;堆是连续的内存空间，扩张自下至上，&lt;code&gt;mm_struct&lt;/code&gt;中包含了起始和结束地址&lt;code&gt;start_brk&lt;/code&gt;和&lt;code&gt;brk&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外系统分配虚拟地址时并不会马上关联到文件或者内存，当用户实际访问内存时才会进行分配，访问虚拟地址空间，如果内存页尚未映射，便会产生缺页异常，由系统捕获，随后调用 do_page_fault进行内存映射，这是一个非常复杂的实现。&lt;/p&gt;
&lt;p&gt;另外，内核提供了一系列函数从内核空间和用户空间交换数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy_from_user
get_user
strncopy_from_user
put_user
copy_to_user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，每个进程都都有自己独立的虚拟空间，这里的硬件实现原理便是页表项，每个进程都有自己的一组页表项，fork进程时需要复制一份独立的页表项，这也是创建进程相对创建线程的瓶颈所在，如果一个进程独立的页表项很少，fork的性能会很好，如果有大量的页表项，fork的性能便不看忍受了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 内核调试</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-debugging/</link>
        <pubDate>Mon, 19 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-debugging/</guid>
        <description>&lt;h1 id=&#34;uml调试linux内核&#34;&gt;UML调试Linux内核&lt;/h1&gt;
&lt;p&gt;最近看了些Linux内核源码，之前认为最好的调试内核源码最好的方式使用Qemu虚拟机，结合GDB调试，虽然在网上也看到一些这种调试方式的弊端，但感觉虚拟机支持调试是最完美的事情，虽然Bochs更为灵活甚至内置调试器，但速度太慢。&lt;/p&gt;
&lt;p&gt;之 前一直觉得KGDB这种双机调试的方式很不完美，还必须使用一个调试机，不过在Windows下使用WinDbg调试虚拟机多了，感觉这种方式很合理，起 码被调试机当机的情况下，调试机还是活的。而且这样看上去很酷，而且比SoftICE这样“不稳定”的调试方式要好的多。&lt;/p&gt;
&lt;p&gt;这两天看到一种 UML（User Mode Linux）的调试方式，居然早已加入内核，我才听闻，真是落后时代啊。这种UML方式是把linux内核当作本地一个普通的应用程序执行，当然也很方便 调试，这个类似于Xen虚拟机。不过在64位Fedora上没有配好环境，在i386却很容易配置，打开控制台转到内核源码，例如&lt;code&gt;linux- 2.6.34&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;编译内核命令要在普通方式后加入构架um参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置内核
make menuconfig ARCH=um
# 编译内核
make linux ARCH=um
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译完成后会在源码根目录下生成可执行文件 linux。&lt;/p&gt;
&lt;p&gt;到这里似乎很简单，下面需要创建 Linux 根文件系统，也就是除内核以外的硬盘文件，这个根文件系统包括Linux文件组织数，以及启动系统所必须的一些辅助程序。&lt;/p&gt;
&lt;p&gt;一种方法就是手工制作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建一个2G的文件作为硬盘
dd if=/dev/zero of=rootfs.img bs=1M count=2048
# 格式化文件
mkfs.ext3 rootfs.img
# 映射此文件到主机文件夹
mount -o loop rootfs.img /mnt/temp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此便可通过拷贝文件到&lt;code&gt;/mnt/temp/&lt;/code&gt;目录，等同于拷贝文件到rootfs.img硬盘文件。这里可以直接通过主机的文件目录组织去构建跟文件系统，也可以直接安装一个linux到此目录。&lt;/p&gt;
&lt;p&gt;使用最简单的方式就是直接使用现成的根文件系统。在UML网站 &lt;a class=&#34;link&#34; href=&#34;http://user-mode-linux.sourceforge.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The User-mode Linux Kernel Home Page&lt;/a&gt; 有相关链接可以下载，比如下载 DSL-4.4-root_fs.bz2 文件，首先解压运行之：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bunzip2 DSL-4.4-root_fs.bz2
./linux ubda=DSL-4.4-root_fs

#登录之后出现root提示符
root@console[/]#
#关闭UML
root@console[/]# shutdown -h 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于根文件系统需要慢慢积累。&lt;/p&gt;
&lt;p&gt;接下来看看如何调试内核，由官方文档 &lt;a class=&#34;link&#34; href=&#34;http://user-mode-linux.sourceforge.net/hacking.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kernel Hacking with UML&lt;/a&gt; 所言，直接使用 gdb linux 便可调试，不过我在启动一开始便遇到段错误，单步运行居然还能继续，之后便陷入无休止的trap中。&lt;/p&gt;
&lt;p&gt;继续 google（最能找到答案的往往在国外的论坛，而且常常需要翻墙），最后找到两个设置，是SIGSEGV和SIGUSR1信号不中断继续运行，最终居然可以，这点让人百思不得其解，还是先看看现象如何：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gdb linux
(gdb) br start_kernel
Breakpoint 1 at 0x80493bb: file init/main.c, line 533.
(gdb) handle SIGSEGV pass nostop noprint
Signal        Stop      Print   Pass to program Description
SIGSEGV       No        No      Yes             Segmentation fault
(gdb) handle SIGUSR1 pass nostop noprint
Signal        Stop      Print   Pass to program Description
SIGUSR1       No        No      Yes             User defined signal 1
(gdb) r ubda=DSL-4.4-root_fs
Starting program: /home/cpp/fox/kernel/linux-2.6.34/linux ubda=DSL-4.4-root_fs
Locating the bottom of the address space ... 0x1000
Locating the top of the address space ... 0xc0000000
Core dump limits :
        soft - 0
        hard - NONE
Checking that ptrace can change system call numbers...OK
Checking syscall emulation patch for ptrace...OK
Checking advanced syscall emulation patch for ptrace...OK
Checking for tmpfs mount on /dev/shm...OK
Checking PROT_EXEC mmap in /dev/shm/...OK
Checking for the skas3 patch in the host:
  - /proc/mm...not found: No such file or directory
  - PTRACE_FAULTINFO...not found
  - PTRACE_LDT...not found
UML running in SKAS0 mode

Breakpoint 1, start_kernel () at init/main.c:533
533             smp_setup_prhandleocessor_id();
(gdb)

# 注释，gdb 启动参数的设置
(gdb) r arg1 arg2 ...
(gdb) set args arg1 arg2 ...
# handle 指定如何处理一个信号，详尽的解释可查阅帮助
(gdb) help handle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;居然一切顺利的断到了start_kernel，哈哈，不管如何，总算能够调试内核了。接下来还有UML虚拟机的网络配置，UML使用了一个取巧的方式就是利用 tun 和 iptables ，好在我也研究了大半年，明天继续。&lt;/p&gt;
&lt;p&gt;另外有个GDB调试的问题，明明遇到了SIGSEG，为什么还能继续呢？莫非这个信号是自己发出的？还有之后的SEGTRAP信号是怎么发出来的？要弄清楚这个问题，或许还得查阅UML代码。&lt;/p&gt;
&lt;h1 id=&#34;uml网络配置&#34;&gt;UML网络配置&lt;/h1&gt;
&lt;p&gt;UML支持多种方式的网络，一般使用tap/tun模拟UML虚拟机中的eth0驱动，仅仅这种方式也能分为桥接和NAT等等，手工配置网络也有助于理解网络的运行方式。&lt;/p&gt;
&lt;p&gt;根据官方文档 &lt;a class=&#34;link&#34; href=&#34;http://user-mode-linux.sourceforge.net/network.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Simple UML Networking&lt;/a&gt; 下载 &lt;code&gt;uml_utilities&lt;/code&gt; ，其实也就使用了一个工具 tunctl，这个工具很简单，就是启动 tun 驱动，首先得先查看是否加载 tun 驱动，当然首先需要有root权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看用户 ID （tunctl 使用）
[cpp@dark tunctl]$ id
uid=500(cpp) gid=500(cpp) groups=500(cpp) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

# 切换管理员权限
[cpp@dark tunctl]$ su
Password:

# 查看tun驱动是否加载
[root@dark tunctl]# lsmod | grep tun

# 没有则加载tun驱动
[root@dark tunctl]# modprobe tun

# 再次查看
[root@dark tunctl]# lsmod | grep tun
tun                    13014  0

# 查看普通用户是否有读写tun设备权限
[root@dark tunctl]# ls /dev/net/tun -l
crw-rw-rw-. 1 root root 10, 200 Dec  8 11:19 /dev/net/tun

# 启动tun，设置用户ID
# 随后驱动以tap模式启动，设备为 tap0
[root@dark tunctl]# ./tunctl -u 500
Set &#39;tap0&#39; persistent and owned by uid 500

# 查看所有网卡状态，可以看到已经有tap0接口
[root@dark tunctl]#ifconfig -a
eth1      Link encap:Ethernet  HWaddr 08:00:27:54:D1:F5
          inet addr:10.33.33.34  Bcast:10.255.255.255  Mask:255.0.0.0
          inet6 addr: fe80::a00:27ff:fe54:d1f5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:555523 errors:13 dropped:0 overruns:0 frame:0
          TX packets:70630 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:424000963 (404.3 MiB)  TX bytes:4827144 (4.6 MiB)
          Interrupt:19 Base address:0xd020

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:102 errors:0 dropped:0 overruns:0 frame:0
          TX packets:102 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:13444 (13.1 KiB)  TX bytes:13444 (13.1 KiB)

tap0      Link encap:Ethernet  HWaddr DA:47:96:23:59:AA
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

# 激活tap网卡并设置IP地址
[root@dark cpp]# ifconfig tap0 192.168.33.33 up

# 完毕后删除网卡可使用命令
[root@dark tunctl]# ./tunctl -d tap0

到这里已经设置好tun/tap网卡，接下来启动UML虚拟机并且配置网络：

# 启动UML虚拟机，设置网卡为tap
[cpp@dark linux-2.6.36]$ ./linux eth0=tuntap,tap0 ubda=Gentoo-10.0-AMD64-root_fs

# 启动过程中出现
eth0: broadcasting for a lease
eth0: timed out
# 说明并没有连通网络

# 启动虚拟机后检测网卡配置
eth0: broadcasting for a lease
eth0: timed out
eth0: trying to use old lease in `/var/lib/dhcpcd/dhcpcd-eth0.lease&#39;
localhost ~ # ifconfig
eth0      Link encap:Ethernet  HWaddr b2:9d:a5:12:b9:45
          inet addr:169.254.186.160  Bcast:169.254.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:1578 (1.5 KiB)
          Interrupt:5

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到UML虚拟机已经有网卡配置，但是并无法连通网络。连通网络有几种方式，像virtualbox等虚拟机的NAT和桥接等等，按照UML这种设计方式，应该可以配置出来任意类型，这里尝试配置桥接模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 设置IP路由转发
[root@dark linux-2.6.36]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
[root@dark linux-2.6.36]# echo 1 &amp;gt; /proc/sys/net/ipv4/conf/tap0/proxy_arp

# 创建网桥 （brctl 位于 bridge-utils 软件包）
[root@dark linux-2.6.36]# brctl addbr br0
# 把 eth1 和 tap0 加入网桥
[root@dark linux-2.6.36]# brctl addif br0 eth1
[root@dark linux-2.6.36]# brctl addif br0 tap0

# 修改br0网桥的网络配置并激活
[root@dark linux-2.6.36]# ifconfig eth1 10.33.33.35 up
[root@dark linux-2.6.36]# ifconfig tap0 10.33.33.36 up
[root@dark linux-2.6.36]# ifconfig br0 10.33.33.34 up

# 启动UML虚拟机，设置网卡为tap
[cpp@dark linux-2.6.36]$ ./linux eth0=tuntap,tap0 ubda=Gentoo-10.0-AMD64-root_fs

# 设置UML虚拟机网络配置
localhost ~ # ifconfig eth0 10.33.33.36 netmask 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过设置网桥后发现仍然无法连通本地10.33.33.35，却可以ping通远程机器地址，真是抓狂，抓包发现tap0网卡arp解 析有问题，进一步查看发现tap0网卡的mac地址与虚拟机内eth0网卡mac地址不同，也就是UML内部重新创建一个网卡而并没有直接使用tap0， 只是通过tap0收发数据，但为什么远程机器可以接受但是本地地址无法接受呢？本地网卡把10.33.33.36当成了本机tap0，而外网地址把 10.33.33.36当成了UML虚拟机，故能连通，也就是UML虚拟机跟主机tap0并不相同，是两个独立的机器，把UML虚拟机设置为 10.33.33.37，发现所有机器都可以连通。这样就把UML虚拟机桥接到网络上了。&lt;/p&gt;
&lt;p&gt;现在设置NAT网络，把系统网络状态恢复到开始， 重新设置tap驱动，地址为192.168.33.33，启动虚拟机，设置ip地址为 192.168.33.34，这样 192.168.33.* 就相当于一个小局域网，192.168.33.34 通过 192.168.33.33 转发，设置完毕以后二者便可通信，也省去了桥接的麻烦，只是需要操纵 iptables。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在 UML 虚拟机内设置默认路由
localhost ~ # route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.33.33
# 查看路由表，看到已经添加了 default 网关为 192.168.33.33
localhost ~ # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.33.0    *               255.255.255.0   U     0      0        0 eth0
loopback        *               255.0.0.0       U     0      0        0 lo
default         192.168.33.33   0.0.0.0         UG    0      0        0 eth0

# 设置IP路由转发
[root@dark linux-2.6.36]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward

# 设置SNAT源地址转换 10.33.33.34 为eth1地址
[root@dark linux-2.6.36]# iptables -t nat -A POSTROUTING -o eth1 -j SNAT --to-source 10.33.33.34

# 如果此时不通，可检查iptables的其他规则和UML与主机的路由表配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样便可做成NAT的效果，比桥接方式简单的多，只是需要知道iptables的用法。当然以上配置每次重启将会消失，可以写到配置开机自动设置。&lt;/p&gt;
&lt;h1 id=&#34;qemu调试linux内核&#34;&gt;Qemu调试Linux内核&lt;/h1&gt;
&lt;p&gt;通过UML可以方便的在本机调试Linux内核，UML是一种特殊的虚拟机，另外一种更为灵活的虚拟机是Qemu，Qemu是一种完全仿真虚拟机， 可以在i386平台仿真任意其他处理器构架，而且支持GDB调试，这里尝试一下使用Qemu调试Linux内核，Qemu参数-kernel可以直接指定 内核启动，这与UML有相似之处。&lt;/p&gt;
&lt;p&gt;首先需要编译安装Qemu，这里并没有什么疑惑之处，直接从官方网站下载源码，使用Linux最常用的编译命令即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认选项会编译所有处理器构架虚拟机
# 可以 ./configure --help 查看编译特定平台的配置

cpp@dark:~/qemu-0.12.4$ ./configure --target-list=i386-softmmu
cpp@dark:~/qemu-0.12.4$ make
cpp@dark:~/qemu-0.12.4$ make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来以默认选项编译内核，不过巨崩溃的是内核默认没有DEBUG_INFO选项，所以虽然能在导出符号部分断下来，但是没有源码，所以需要选则Compile the kernel with debug info选项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认选项
cpp@dark:~/linux-2.6.34$ make defconfig
# 配置菜单，选择调试信息
cpp@dark:~/linux-2.6.34$ make menuconfig
# 编译内核
cpp@dark:~/linux-2.6.34$ make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用Qemu加载内核启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cpp@dark:~/linux-2.6.34$ qemu -s -S -kernel arch/x86/boot/bzImage -hda rootfs.img -append &amp;quot;root=/dev/sda&amp;quot;
# 其中一些选项的解释如下
# -s 监听tcp:1234端口以等待GDB连接
# -S 虚拟机启动后停止，以便GDB连接后调试启动过程
# -kernel 压缩内核
# -hda 硬盘
# -appand 启动参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里系统很容易启动不了，如果系统由于VFS加载错误无法启动，首先尝试启动参数root=/dev/sda为root=/dev /hda，hda是IDE硬盘标识，sda为SCSI硬盘，这要看内核识别成哪种，如果仍然不行，那要检测rootfs.img根文件系统的格式跟内核所 支持的格式是否匹配，2.6.34支持ext3格式，如果格式错误，可以利用 Linux 内核调试1 里的方法，自己手工创建一个ext3格式的文件，然后mount到临时文件，把其他根文件系统全部拷贝进去即可。&lt;/p&gt;
&lt;p&gt;这 样启动Qemu之后，发现系统一片黑屏，这里因为Qemu启动参数被设置为禁止，Qemu本身具有显示窗口和控制窗口，利用 Ctrl+Alt+2 进入控制台，c命令继续虚拟机，Ctrl+Alt+1 返回显示窗口，Qemu的控制台可以控制很多选项，从这点来看要比VMware等要灵活一些，UML本身也支持运行时控制。&lt;/p&gt;
&lt;p&gt;接下来使用GDB启动虚拟机，当系统停止在启动之后时，用GDB加载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 启动GDB，GDB加载未压缩内核
cpp@dark:~/linux-2.6.34$ gdb vmlinux
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;i486-slackware-linux&amp;quot;...
(gdb)

# 设置断点
(gdb) br start_kernel
Breakpoint 1 at 0xc172f5d4: file init/main.c, line 533.

# 连接Qemu监听端口1234
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
[New Thread 1]
0x0000fff0 in ?? ()

# 继续Qemu虚拟机执行
(gdb) c
Continuing.

# 内核解压之后很快便到达断点
Breakpoint 1, start_kernel () at init/main.c:533
533             smp_setup_processor_id();
(gdb)

# 接下来便可任意调试内核
(gdb) list
528     asmlinkage void __init start_kernel(void)
529     {
530             char * command_line;
531             extern struct kernel_param __start___param[], __stop___param[];
532
533             smp_setup_processor_id();
534
535             /*
536              * Need to run as early as possible, to initialize the
537              * lockdep hash:
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Qemu由于是完全仿真实现，所以可以在任意平台调试其他构架内核，理论上甚至可以在Windows平台交叉编译Linux内核，再去由Qemu加载调试（交叉编译比较麻烦，需要先编译目标构架的binutil，而后链接内核）。&lt;/p&gt;
&lt;h1 id=&#34;uml和qemu调试内核模块&#34;&gt;UML和Qemu调试内核模块&lt;/h1&gt;
&lt;p&gt;这次来看如何调试内核模块，也就是驱动程序，模块的调试跟普通程序略有不同，不论是内核还是普通应用程序，在连接之后便以得知代码将要加载的位置，用户态程序有虚拟地址映射机制，而内核独占物理内存。内核运行与共享的内核地址空间，所以不能使用相同的线性地址，只能由内核加载模块时指定起始地址，模块中都以此为偏移运行。所以内核的调试不能使用普通的方式，需要知道模块的加载地址。&lt;/p&gt;
&lt;p&gt;而且Qemu的调试原理与UML相似，也可用相同的方法进行模块的调试，这里仅以UML模块调试举例&lt;/p&gt;
&lt;p&gt;首先需要完成一个内核模块，这里可以照搬之前的 Linux 内核调试 ，保存源文件为go.c，完成Makefile和编译工作，内核源码以编译UML的内核为准：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Makefile 内容
obj-m := go.o

# 编译命令
[cpp@dark go]$ make -C /home/cpp/fox/linux-2.6.36 M=$PWD modules ARCH=um

接下来启动带网络的UML，拷贝go.ko模块文件到UML虚拟机中，之后启动GDB：

# 查看 linux 进程 ID
[cpp@dark linux-2.6.36]$ ps -A | grep linux
 7333 pts/0    00:00:38 linux
 7340 pts/0    00:00:00 linux
 7341 pts/0    00:00:00 linux
 7342 pts/0    00:00:00 linux
 7343 pts/0    00:00:00 linux
 7481 pts/0    00:00:00 linux
 7546 pts/0    00:00:00 linux
 9864 pts/0    00:00:00 linux
 9866 pts/0    00:00:00 linux
 9868 pts/0    00:00:00 linux

# 启动 GDB
[cpp@dark linux-2.6.36]$ gdb linux
GNU gdb (GDB) Fedora (7.1-18.fc13)
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-redhat-linux-gnu&amp;quot;.
For bug reporting instructions, please see:...
Reading symbols from /home/cpp/fox/linux-2.6.36/linux...done.

# attach 到 linux 进程，attach第一个进程
(gdb) attach 7333

# 忽略段错误
(gdb) handle SIGSEGV pass nostop noprint

# 对 sys_init_module 设置断点，截获模块加载事件
(gdb) br sys_init_module
Breakpoint 1 at 0x60052421: file kernel/module.c, line 2696.

# 继续执行
(gdb) c
Continuing.

# 在虚拟机中加载 go.ko 模块
localhost ~ # insmod go.ko

# 主机GDB截获断点
Breakpoint 1, sys_init_module (umod=0x603030, len=124282,
    uargs=0x603010) at kernel/module.c:2696
2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb)
# 模块加载 load_module 调用结果
(gdb) n 2691 {
(gdb) n 2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb) n 2700 mod = load_module(umod, len, uargs);
(gdb) n 2701 if (IS_ERR(mod))
(gdb) print mod
$1 = (struct module *) 0x628482b0

# 从 include/linux/module.h 查看 module.h结构
# struct module_sect_attrs *sect_attrs; 为模块的段属性
# 查看模块名
(gdb) print mod-&amp;gt;name
$2 = &amp;quot;go&amp;quot;, &#39;\000&#39;
# 查看模块段个数
(gdb) print mod-&amp;gt;sect_attrs-&amp;gt;nsections
$3 = 11
# 查看第一个段名
(gdb) print mod-&amp;gt;sect_attrs-&amp;gt;attrs[0]-&amp;gt;name
$4 = 0x61daa3a0 &amp;quot;.note.gnu.build-id&amp;quot;
# 找到 .text 段，并显示基址
(gdb) print mod-&amp;gt;sect_attrs-&amp;gt;attrs[1]-&amp;gt;name
$5 = 0x61daa3c0 &amp;quot;.text&amp;quot;
(gdb) print /x mod-&amp;gt;sect_attrs-&amp;gt;attrs[1]-&amp;gt;address
$6 = 0x62848000
# 加载符号，使用 GDB 的 add-symbol-file 命令加载模块符号到基址
(gdb) add-symbol-file go/go.ko 0x62848000 add symbol table from file &amp;quot;go/go.ko&amp;quot; at .text_addr = 0x62848000 (y or n) y Reading symbols from /home/cpp/fox/linux-2.6.36/go/go.ko...done.

# 设置模块断点
(gdb) br simple_read Breakpoint 2 at 0x62848028: file /home/cpp/fox/linux-2.6.36/go/go.c, line 21.
# 继续运行
(gdb) c Continuing.

# UML 虚拟机中操作模块 localhost ~
# cat /dev/simple

# 主机断点生效 Breakpoint 2, simple_read (pfile=0x61c74180, buf=0x60d000

, size=32768, ppos=0x61e0bec0) at /home/cpp/fox/linux-2.6.36/go/go.c:21 21 { (gdb) # 查看信息并调试 (gdb) n 22 if (copy_to_user(buf, “test data\n”, 10)) (gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然加载符号时还可以查看 .data 段和 .bss 段的基址，加载go.ko时同时可以设置二者的基址，以便可以调试全局变量等等，初看起来这个过程比较复杂，其实就是通过调试内核加载位置来确定模块最终将要加载的基址，而后通过机制加载模块符号。&lt;/p&gt;
&lt;p&gt;这个复杂的过程如果每次都需要手动处理是非常烦人的一件事，好在GDB本身有脚本扩展（甚至可执行Python脚本），来简化这个过程，这里来试着写一个简单的打印模块section名字和基址的脚本。&lt;/p&gt;
&lt;p&gt;GDB脚本运行可以由两种方式，一种是在GDB启动时，在当前目录查找.gdbinit文件解释执行，另一种在GDB运行期间使用 source script-file 命令来执行，脚本的说明可查阅文档，以下是简单的打印段信息的脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define modsec
        set $index = 0
        while $index &amp;lt; mod-&amp;gt;sect_attrs-&amp;gt;nsections
                printf &amp;quot;Name\t%s\tAddress\t0x%x\n&amp;quot;, mod-&amp;gt;sect_attrs-&amp;gt;attrs[$index]-&amp;gt;name, mod-&amp;gt;sect_attrs-&amp;gt;attrs[$index]-&amp;gt;address
                set $index = $index + 1
        end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是加载并执行脚本效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 加载脚本
(gdb) source modsec
(gdb) c
Continuing.

# 在虚拟机中加载 go.ko 模块
# 并单步执行到 mod = load_module(umod, len, uargs);
Breakpoint 1, sys_init_module (umod=0x603030, len=124282,
    uargs=0x603010) at kernel/module.c:2696
2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb) n
2691 {
(gdb) n
2696 if (!capable(CAP_SYS_MODULE) || modules_disabled)
(gdb) n
2700 mod = load_module(umod, len, uargs);
(gdb) n
2701 if (IS_ERR(mod))
# 调用定义命令打印段
(gdb) modsec
Name .note.gnu.build-id Address 0x6286f09c
Name .text Address 0x6286f000
Name .exit.text Address 0x6286f050
Name .init.text Address 0x62872000
Name .rodata.str1.1 Address 0x6286f0c0
Name .eh_frame Address 0x6286f118
Name .data Address 0x6286f1e0
Name .gnu.linkonce.this_module Address 0x6286f2b0
Name .bss Address 0x6286f490
Name .symtab Address 0x62872098
Name .strtab Address 0x628725c0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此便可稍微方便一点的打印所有段名和段基址，如果添加其他脚本扩展，可以更加方便且高效的调试Linux内核。&lt;/p&gt;
&lt;h1 id=&#34;使用kgdb双机调试&#34;&gt;使用KGDB双机调试&lt;/h1&gt;
&lt;p&gt;虽然使用UML或者Qemu可以调试Linux内核，但UML和Qemu毕竟是一个模拟，调试硬件驱动总是用虚拟硬件总不成事，而且Qemu据传闻 对于时钟和中断的处理也有问题，所以对于处理真实硬件的问题，最完美的调试方式就是双机调试，被调试内核在完全真实的环境中运行，排除虚拟机制的不稳定因 素，而且使用内核自带的KGDB机制，更具有可靠性，类似Windows下的WinDbg调试方式。这里使用VirtualBox虚拟机进行调试，但所提 及的方法完全适用于诸如VMWare、Qemu虚拟机或者真实机器，只是相关的串口配置方式有些许不同而已。&lt;/p&gt;
&lt;p&gt;首先需要编译配置KGDB选项的内核，编译方式也比较简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置内核选项
[cpp@dark linux-2.6.34]$ make menucofnig
# Kernel hacking  ---&amp;gt;
# 		[*] Compile the kernel with debug info
# 		[*] KGDB: kernel debugging with remote gdb  ---&amp;gt;

# 编译
[cpp@dark linux-2.6.34]$ make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译完成之后需要在目标机器部署自己的内核，需要修改grub.conf，或者lilo的配置，这决定于Linux使用哪种引导程序，这里修改grub.conf，首先拷贝编译好未压缩内核镜像至目标机器boot分区，命名为linux-2.6.34。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置文件路径 /boot/grub/grub.conf
# 默认启动内核
default 0
# 选择超时时间
timeout 30

# 添加以下内容，以增加一个新的启动项
title Linux 2.6.34 (Debug)
root (hd0,0)
kernel /boot/linux-2.6.34 root=/dev/sdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于lilo，修改配置文件/etc/lilo.conf，之后必须使用lilo -C /etc/lilo.conf使配置生效。&lt;/p&gt;
&lt;p&gt;启 动系统后，首先出现grub引导画面，选择Debug内核启动，不论真机还是虚拟机，时常有系统无法启动的问题，是因为内核配置过小，最基本的启动都无法 支持，如果出现找不到sdb1类似错误，需要检查sdb1是否正确，IDE/ATA硬盘以h打头，为hda等，SATA和SCIS以s打头，为sda等 等，后缀a，b分别为第几块硬盘，sda为第一块，sdb为第二块，其后的数字1、2指明第几个分区，另外需要检查的是硬盘驱动是否正确安装，这个可参阅 Linux安装配置说明，结合google，应该能够解决。&lt;/p&gt;
&lt;p&gt;能够启动系统后，在目标Linux内核启动选项append命令 ro kgdboc=ttyS0,115200 kgdbwait，如此目标机器启动到一定时机停止，出现kgdb: Waiting for connection from remote gdb…的字句，这样对于目标机器的配置已经完成，再来看主机配置，启动gdb配置串口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 加载 vmlinux
cpp@dark:~/linux-2.6.34$ gdb vmlinux
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;i486-slackware-linux&amp;quot;...

# 设置远程端口 波特率
(gdb) set remotebaud 115200
# 连接远程串口
(gdb) target remote /dev/pts/3
Remote debugging using /dev/pts/3
kgdb_register_io_module (new_kgdb_io_ops=)
    at kernel/kgdb.c:1749
1749            wmb(); /* Sync point after breakpoint */

# 至此便可任意调试
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里串口我使用的是 /dev/pts/3 是因为我在linux下使用virtualbox虚拟机的管道串口，再利用socat虚拟串口，有条件的可以直接利用主机串口，这里的设备便成为 /dev/ttyS0，使用socat 虚拟串口的命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vboxS0 为virtualbox的串口管道
cpp@dark:~/kernel/socat-2.0.0-b4$ ./socat -d -d /tmp/vboxS0 pty:1
2010/12/10 23:24:14 socat[3962.3082070656] N opening connection to AF=1 &amp;quot;/tmp/vboxS0&amp;quot;
2010/12/10 23:24:14 socat[3962.3082070656] N successfully connected from local address AF=1 &amp;quot;\x04\b\x94\x18\x@C\xAE\xB4\x@7\xE2\xA7\a&amp;quot;
2010/12/10 23:24:14 socat[3962.3082070656] N successfully connected via
2010/12/10 23:24:14 socat[3962.3082070656] N PTY is /dev/pts/3
2010/12/10 23:24:14 socat[3962.3082070656] N starting data transfer loop with FDs [3,3] and [4,4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此便可使用kgdb进行串口双机调试，这里使用linux主机和虚拟机实现，当然相同的思路可以很容易知道如何进行两个虚拟机或者两个真实机调试。&lt;/p&gt;
&lt;p&gt;kgdb 也支持网络调试，使用tcp协议，但是串口应该是最理想的方式，如果需要调试网络程序，再通过网络传输调试指令，会不会混乱呢？关于kgdb，在 linux内核源码的文档部分 /linux-2.6.34/Documentation/DocBook/kgdb.tmpl ，有一分文档说明，配置时可参阅之。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 内核 slab 分配器</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-slab-allocator/</link>
        <pubDate>Sun, 18 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-slab-allocator/</guid>
        <description>&lt;h1 id=&#34;slab-介绍&#34;&gt;slab 介绍&lt;/h1&gt;
&lt;p&gt;内存分配与释放向来是程序设计中的难点，在C语言中有malloc可以方便使用，但还是有更多的针对具体业务的实现。内存分配需要考虑分配效率和内存使用率的平衡，当用户申请一块内存，程序需要在空闲内存中查找合适的内存块返回，这里可以选择一个最快获取的算法（first-fit），或者最优选择（best-fit）。二者往往无法两全。另外需要考虑一个根本性的问题就是内存碎片，释放内存时往往与申请顺序不同，会在内存中留下大量的空洞，当有大量不连续的小内存即碎片出现时，便会产生空闲内存很多但是无法分配大块内存的情况。对于操作系统，需要长时间运行，内存碎片的问题便显得非常突出了。&lt;/p&gt;
&lt;p&gt;Linux内核一种分配内存的方式是alloc_pages，使用伙伴算法，但这个只适应于按页分配，如果需要几个字节的内存都分配4k，显然会是极大的浪费，所以内核又提供了一种小内存的分配方式，称之为slab，另外还有两种可选的分配方式，slob和slub，slob是为了在嵌入式环境中使用，slub在一些大型设备中币slab有更优秀的性能。但作为程序开发者来说，无需关心内核选用了哪种分配方式，三者具有相同的接口，调用者可以忽略其中的差别。&lt;/p&gt;
&lt;p&gt;因为在内核中需要频繁分配同类型的对象，比如频繁分配socket，task_struct等结构体对象，slab一个核心思想就是一个slab分配器只分配一种对象，这样做的好处便是每个slab只分配等大小的内存，能够很好的兼顾效率和内存碎片的问题，当然slab最终也是通过alloc_pages按页分配的内存。&lt;/p&gt;
&lt;h2 id=&#34;直观认识&#34;&gt;直观认识&lt;/h2&gt;
&lt;p&gt;先来通过命令直观的了解一下slab的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /proc/slabinfo
slabinfo - version: 2.1
# name                 : tunables    : slabdata   
kmalloc_dma-512        8      8    512    8    1 : tunables    0    0    0 : slabdata      1      1      0
UDPLITEv6              0      0    704   11    2 : tunables    0    0    0 : slabdata      0      0      0
UDPv6                 11     11    704   11    2 : tunables    0    0    0 : slabdata      1      1      0
...
kmalloc-8          13156  13312      8  512    1 : tunables    0    0    0 : slabdata     26     26      0
kmalloc-192          352    420    192   21    1 : tunables    0    0    0 : slabdata     20     20      0
kmalloc-96         14293  14322     96   42    1 : tunables    0    0    0 : slabdata    341    341      0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以很直观的看到每种对象的slab分配情况，从名称不难看出每种slab的作用，从名字kmalloc-8等也能猜测出这是调用kmalloc时分配的内存，内存也是按照一定规则递增分配。&lt;/p&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;p&gt;slab分配器的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/keep/2014/0_kernel-slab-design.gif&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;slab allocator&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;每种具体的内存分配器都由kmem_cache表示，多个kmem_cache组成分配器链，kmem_cache又由三部分组成，slabs_full表示已经完全分配出去的slab，slabs_partial表示部分分配，slabs_empty表示未进行分配。具体的实现原理分析可以放到最后，这里可以查看一下如何使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义一个slab实例
struct struct kmem_cache * test_cache;
// 创建一个新缓存
struct kmem_cache *kmem_cache_create(const char *, size_t, size_t,
                        unsigned long,
                        void (*)(void *));
// 销毁缓存
void kmem_cache_destroy(struct kmem_cache *); 
// 分配内存
void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
// 释放内存
void kmem_cache_free(struct kmem_cache *, void *);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用法例子&#34;&gt;用法例子&lt;/h2&gt;
&lt;p&gt;接下来可以写一段代码来体验一下slab的用法，这里在 Linux字符设备框架 的基础上添加代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;linux/init.h&amp;gt; 
#include&amp;lt;linux/module.h&amp;gt; 
 
#include&amp;lt;linux/fs.h&amp;gt; 
#include&amp;lt;linux/types.h&amp;gt; 
#include&amp;lt;linux/cdev.h&amp;gt; 
#include&amp;lt;linux/mm.h&amp;gt; 
#include&amp;lt;linux/sched.h&amp;gt; 
#include&amp;lt;asm/io.h&amp;gt; 
#include&amp;lt;asm/uaccess.h&amp;gt; 
#include&amp;lt;asm/system.h&amp;gt; 
 
#include&amp;lt;linux/device.h&amp;gt; 
 
#define OBJECT_SIZE        27 
#define OBJECT_NUM        10 
dev_t devno; 
struct class * simple_class; 
static struct cdev cdev; 
 
struct kmem_cache * cppbreak_cache; 
 
struct cache_object { 
    void * object; 
    struct list_head list; 
}; 
 
LIST_HEAD(head); 
 
ssize_t simple_write(struct file * filp, 
    const char __user * buf, size_t size, loff_t * ppos) 
{ 
    char command[OBJECT_SIZE] = {}; 
    int num = 0; 
    int i = 0; 
    if (size &amp;gt;= OBJECT_SIZE || size &amp;lt; 3) { 
        return -EFAULT; 
    } 
    if (copy_from_user(command, buf, size)) 
        return -EFAULT; 
    command[size] = &#39;0&#39;; 
 
    printk(&amp;quot;Cache name is %s\n&amp;quot;, kmem_cache_name(cppbreak_cache)); 
    printk(&amp;quot;Cache object size is %d\n&amp;quot;, kmem_cache_size(cppbreak_cache)); 
 
    num = simple_strtol(command + 2, NULL, 10); 
 
    printk(&amp;quot;command is %s, num=%d\n&amp;quot;, command, num); 
    if (command[0] == &#39;i&#39;) { 
        for (i = 0; i &amp;lt; num; i++) { 
            struct cache_object * object = (struct cache_object *)kmem_cache_alloc(cppbreak_cache, GFP_KERNEL); 
            list_add_tail(&amp;amp;object-&amp;gt;list, &amp;amp;head); 
        } 
    } 
    else if (command[0] == &#39;d&#39;) { 
        for (i = 0; i &amp;lt; num &amp;amp;&amp;amp; !list_empty(&amp;amp;head); i++) { 
            struct cache_object * object = 
                (struct cache_object *)list_entry( 
                    head.next, 
                    struct cache_object, 
                    list); 
            list_del(&amp;amp;object-&amp;gt;list); 
            kmem_cache_free(cppbreak_cache, object); 
        } 
    } 
    else { 
        return -EFAULT; 
    } 
    return size; 
} 
 
int simple_open(struct inode * pnode, struct file * pfile) 
{ 
    printk(KERN_INFO &amp;quot;open simple\n&amp;quot;); 
    return 0; 
} 
 
int simple_release(struct inode * pnode, struct file * pfile) 
{ 
    printk(KERN_INFO &amp;quot;close simple\n&amp;quot;); 
    return 0; 
} 
 
static struct file_operations simple_op =  
{ 
    .owner = THIS_MODULE, 
    .write = simple_write, 
    .open = simple_open, 
    .release = simple_release, 
}; 
 
static int __init initialization(void) 
{ 
    int result; 
 
    result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;quot;simple&amp;quot;); 
    if (result &amp;lt; 0) 
        return result; 
 
    cdev_init(&amp;amp;cdev, &amp;amp;simple_op); 
    result = cdev_add(&amp;amp;cdev, devno, 1); 
 
    simple_class = class_create(THIS_MODULE, &amp;quot;simple&amp;quot;); 
    device_create(simple_class, NULL, devno, NULL, &amp;quot;simple&amp;quot;); 
 
    printk(KERN_INFO &amp;quot; init simple\n&amp;quot;); 
 
    cppbreak_cache = kmem_cache_create(&amp;quot;cppbreak&amp;quot;, OBJECT_SIZE, 0, SLAB_HWCACHE_ALIGN, NULL); 
    if (cppbreak_cache == NULL) { 
        printk(KERN_INFO &amp;quot; kmem_cache_create failed\n&amp;quot;); 
        return -10; 
    } 
    printk(KERN_INFO &amp;quot; kmem_cache_create succ\n&amp;quot;); 
    return result; 
} 
 
static void __exit cleanup(void) 
{ 
    if (cppbreak_cache) { 
        kmem_cache_destroy(cppbreak_cache); 
        printk(KERN_INFO &amp;quot; kmem_cache_destroy succ\n&amp;quot;); 
    } 
    device_destroy(simple_class, devno); 
    class_destroy(simple_class); 
 
    cdev_del(&amp;amp;cdev); 
    unregister_chrdev_region(devno, 1); 
    printk(KERN_INFO &amp;quot; cleanup simple\n&amp;quot;); 
} 
 
module_init(initialization); 
module_exit(cleanup); 
 
MODULE_AUTHOR(&amp;quot;cppbreak@gmail.com&amp;quot;); 
MODULE_DESCRIPTION(&amp;quot;slab tester&amp;quot;); 
MODULE_VERSION(&amp;quot;V0.1&amp;quot;); 
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的代码比较简单，modprobe 模块时创建一个文件系统节点和slab分配器，之后便可在&lt;code&gt;echo “i n” &amp;gt; /dev/simple&lt;/code&gt; 来分配n个object，&lt;code&gt;echo “d n” &amp;gt; /dev/simple&lt;/code&gt; 来释放n个object。关于内核链表的应用，可以查看 内核数据结构-链表。&lt;/p&gt;
&lt;p&gt;使用modprobe加载内核之后，便可看到 /proc/slabinfo 增加了 &lt;code&gt;cppbreak_slab&lt;/code&gt; 节点，可以看到&lt;code&gt;object_size&lt;/code&gt;信息，之后便可通过添加节点删除节点来查看响应的分配数值变化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost module]# insmod simple.ko
[root@localhost module]# cat /proc/slabinfo | grep cppbreak
cppbreak               0      0     32  112    1 : tunables  120   60    0 : slabdata      0      0      0
[root@localhost module]# echo &amp;quot;i 10&amp;quot; &amp;gt; /dev/simple 
[root@localhost module]# cat /proc/slabinfo | grep cppbreak
cppbreak              10    112     32  112    1 : tunables  120   60    0 : slabdata      1      1      0
[root@localhost module]# echo &amp;quot;d 10&amp;quot; &amp;gt; /dev/simple 
[root@localhost module]# cat /proc/slabinfo | grep cppbreak
cppbreak               5    112     32  112    1 : tunables  120   60    0 : slabdata      1      1      0
[root@localhost module]#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里便介绍了slab的调用方法，具体的细节和实现过程需要下篇分解了。&lt;/p&gt;
&lt;h1 id=&#34;slab-实现&#34;&gt;slab 实现&lt;/h1&gt;
&lt;p&gt;slab 除了作为内存分配器以外，还有一个重要的功能便是做CPU的高速缓存，slab会把当前cpu释放的对象保存在对应cpu的数组上，这样如果下次还是这个cpu分配相同的对象，直接从对应数组返回，这里利用了cpu的告诉缓存，cpu刚释放的空间仍然存在于它的高速缓存中的概率会很大。&lt;/p&gt;
&lt;p&gt;分析slab的具体实现。首先可以浏览一下关键数据结构 kmem_cache 的实现（注意这里结构体的定义有三个分别是slab，slub，slob的实现，slab的实现位于文件 include/linux/slab_def.h）&lt;/p&gt;
&lt;h2 id=&#34;第一部分kmem_cache-结构体&#34;&gt;第一部分：kmem_cache 结构体&lt;/h2&gt;
&lt;p&gt;根据内核代码注释，kmem_cache分为6个部分，第一部分是 Cache tunables&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
/* 1) Cache tunables. Protected by cache_chain_mutex */
        unsigned int batchcount;
        unsigned int limit;
        unsigned int shared;

        unsigned int buffer_size;
        u32 reciprocal_buffer_size;
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;batchcount 表示在per-CPU列表为空的情况下，从缓存的slab获取对象的数目。limit指定per-CPU列表中保存的对象最大数目，如果超过该值，内核会将batchcount个对象返回到slab。这里的参数便是与cpu高速缓存相关的控制参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buffer_size&lt;/code&gt;表示缓存管理对象的长度。&lt;/p&gt;
&lt;h2 id=&#34;第二部分&#34;&gt;第二部分：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 2) touched by every alloc &amp;amp; free from the backend */
        unsigned int flags;             /* constant flags */
        unsigned int num;               /* # of objs per slab */
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;num 是每个slab中的object数量。&lt;/p&gt;
&lt;h2 id=&#34;第三部分&#34;&gt;第三部分：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 3) cache_grow/shrink */
        /* order of pgs per slab (2^n) */
        unsigned int gfporder;

        /* force GFP flags, e.g. GFP_DMA */
        gfp_t allocflags;

        size_t colour;                  /* cache colouring range */
        unsigned int colour_off;        /* colour offset */
        struct kmem_cache *slabp_cache;
        unsigned int slab_size;
        unsigned int dflags;            /* dynamic flags */

        /* constructor func */
        void (*ctor)(void *obj);
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里于分配相关的参数，主要的参数是颜色范围。&lt;/p&gt;
&lt;h2 id=&#34;第四部分&#34;&gt;第四部分：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 4) cache creation/removal */
        const char *name;
        struct list_head list;
        int refcount;
        int object_size;
        int align;
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分存储了缓存的名称和缓存的list_head节点。&lt;/p&gt;
&lt;h2 id=&#34;第五部分&#34;&gt;第五部分&lt;/h2&gt;
&lt;p&gt;主要是统计之用，开启了&lt;code&gt;CONFIG_DEBUG_SLAB&lt;/code&gt;宏才会生效，与slab分配算法无关。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 5) statistics */
        unsigned long num_active;
        unsigned long num_allocations;
        unsigned long high_mark;
        unsigned long grown;
        unsigned long reaped;
        unsigned long errors;
        unsigned long max_freeable;
        unsigned long node_allocs;
        unsigned long node_frees;
        unsigned long node_overflow;
        atomic_t allochit;
        atomic_t allocmiss;
        atomic_t freehit;
        atomic_t freemiss;

        /*
         * If debugging is enabled, then the allocator can add additional
         * fields and/or padding to every object. size contains the total
         * object size including these internal fields, the following two
         * variables contain the offset to the user object and its size.
         */
        int obj_offset;
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第六部分&#34;&gt;第六部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;struct kmem_cache {
		...
/* 6) per-cpu/per-node data, touched during every alloc/free */
        /*
         * We put array[] at the end of kmem_cache, because we want to size
         * this array to nr_cpu_ids slots instead of NR_CPUS
         * (see kmem_cache_init())
         * We still use [NR_CPUS] and not [1] or [0] because cache_cache
         * is statically defined, so we reserve the max number of cpus.
         */
        struct kmem_list3 **nodelists;
        struct array_cache *array[NR_CPUS];
		...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后这部分是per-CPU相关变量，array很容易理解，既是每个cpu对应的数组。另外一个成员nodelists存储了 &lt;code&gt;slabs_partia&lt;/code&gt;l，&lt;code&gt;slabs_full&lt;/code&gt;，&lt;code&gt;slabs_free&lt;/code&gt;链表，并记录链表空闲节点等信息，这个结构体便是给per-CPU数组提供object的缓存池，注意这里是一个指针的指针，是 &lt;code&gt;kmem_list3&lt;/code&gt; 的二维数组，其中第一个维度是与cpu最接近的内存块索引。&lt;/p&gt;
&lt;h1 id=&#34;创建过程&#34;&gt;创建过程&lt;/h1&gt;
&lt;p&gt;接下来看&lt;code&gt;kmem_cache&lt;/code&gt;节点的创建过程，&lt;code&gt;kmem_cache_create&lt;/code&gt; 分为几个部分：&lt;/p&gt;
&lt;h2 id=&#34;一检查参数的合理性&#34;&gt;一、检查参数的合理性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if (!name || in_interrupt() || (size &amp;lt; BYTES_PER_WORD) ||             size &amp;gt; KMALLOC_MAX_SIZE) {
        printk(KERN_ERR &amp;quot;%s: Early error in slab %s\n&amp;quot;, __func__,
                        name);
        BUG();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看名字是否为空，分配大小是否大于分配的最大值KMALLOC_MAX_SIZE，是否小于CPU字长等，之后进行了去重检测，防止创建相同名称的缓存。&lt;/p&gt;
&lt;h2 id=&#34;二计算对齐&#34;&gt;二、计算对齐&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if (size &amp;amp; (BYTES_PER_WORD - 1)) {
        size += (BYTES_PER_WORD - 1);
        size &amp;amp;= ~(BYTES_PER_WORD - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照处理器字长对其。之后根据flag 的ARCH参数计算对齐。&lt;/p&gt;
&lt;h2 id=&#34;三分配缓存结构&#34;&gt;三、分配缓存结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cachep = kmem_cache_zalloc(&amp;amp;cache_cache, gfp);
if (!cachep)
        goto oops;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cache_cache 是缓存的slab分配器，这里创建出一个新的cache实例，存入cachep，这里就会出现一个问题，便是mem_cache的创建需要调用alloc，但是cache_cache是如何分配出来的呢，这里涉及到slab的初始化问题，之后再讨论。&lt;/p&gt;
&lt;h2 id=&#34;四确定slab头的存储位置&#34;&gt;四、确定slab头的存储位置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if ((size &amp;gt;= (PAGE_SIZE &amp;gt;&amp;gt; 3)) &amp;amp;&amp;amp; !slab_early_init &amp;amp;&amp;amp;
    !(flags &amp;amp; SLAB_NOLEAKTRACE))
        /*
         * Size is large, assume best to place the slab management obj
         * off-slab (should allow better packing of objs).
         */
        flags |= CFLGS_OFF_SLAB;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果object大小大于页帧的八分之一，则将管理数据放到slab之外。&lt;/p&gt;
&lt;h2 id=&#34;五calculate_slab_order&#34;&gt;五、calculate_slab_order&lt;/h2&gt;
&lt;p&gt;现在已经确定缓存对象的size，现在需要估算slab的长度，函数&lt;code&gt;calculate_slab_order&lt;/code&gt;通过对象size，align和flags计算slab应该使用多少页帧，如果页帧过少则存储的对象过少，增加分配管理的开销，如果页帧过多，则空间过于浪费。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (gfporder = 0; gfporder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数循环中gfporder为页帧数量，对指定的页帧，通过函数cache_estimate计算能够存储的数量num以及浪费的空间remainder，计算的公式为： PAGE_SIZE &amp;laquo; gfporder = head + num * size + left_over。
如果对象存储在slab之外，则&lt;code&gt;head（mgmt_size）&lt;/code&gt;为0，如果对象存储于slab之内，则 &lt;code&gt;head = sizeof(struct slab) + num*sizeof(kmem_bufctl_t)&lt;/code&gt;。接着&lt;code&gt;calculate_slab_order&lt;/code&gt;之后便是循环退出的各种条件。&lt;/p&gt;
&lt;h2 id=&#34;六着色&#34;&gt;六、着色&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cachep-&amp;gt;colour_off = cache_line_size();
/* Offset must be a multiple of the alignment. */
if (cachep-&amp;gt;colour_off &amp;lt; align)                 cachep-&amp;gt;colour_off = align;
cachep-&amp;gt;colour = left_over / cachep-&amp;gt;colour_off;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;colour_off&lt;/code&gt; 计算颜色偏移，colour颜色数量，紧接着初始化函数对cache的变量赋值。&lt;/p&gt;
&lt;h2 id=&#34;七setup_cpu_cache&#34;&gt;七、setup_cpu_cache&lt;/h2&gt;
&lt;p&gt;调用enable_cpucache初始化per-CPU变量。&lt;/p&gt;
&lt;h2 id=&#34;八加入全局链表&#34;&gt;八、加入全局链表&lt;/h2&gt;
&lt;p&gt;函数的最后加入全局链表&lt;code&gt;cache_chain&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来看缓存分配过程，&lt;code&gt;kmem_cache_alloc&lt;/code&gt;，函数调用&lt;code&gt;__cache_alloc&lt;/code&gt; -&amp;gt; &lt;code&gt;____cache_alloc&lt;/code&gt; 完成主要功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ac = cpu_cache_get(cachep);
if (likely(ac-&amp;gt;avail)) {
        STATS_INC_ALLOCHIT(cachep);
        ac-&amp;gt;touched = 1;
        objp = ac-&amp;gt;entry[--ac-&amp;gt;avail];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果per-CPU缓存能够使用，则直接从cpu缓存中返回对象。否则通过函数 cache_alloc_refill 从slab中分配。cache_alloc_refill 的作用主要从slab中获取batchcount个对象放入per-CPU缓存。&lt;/p&gt;
&lt;p&gt;这里涉及到另外一个问题，如果当前slab空闲缓存不足，需调用 cache_grow 函数重新分配新的slab节点。
cache_grow 执行时首先计算颜色值，颜色值加一，如果超过最大值，则返回从0开始，这里的颜色值主要是一个偏移。&lt;/p&gt;
&lt;p&gt;slab所需的内存使用是&lt;code&gt;kmem_getpages&lt;/code&gt;从伙伴系统分配的，如果slab头存储在slab之外，则调用 &lt;code&gt;alloc_slabmgmt&lt;/code&gt;函数分配所需要的空间。&lt;/p&gt;
&lt;p&gt;最后对slab对象初始化之后添加到nodelists的free链表中。&lt;/p&gt;
&lt;p&gt;分配完毕如果对象对象释放，使用函数 &lt;code&gt;kmem_cache_free&lt;/code&gt;，释放过程如果per-CPU中尚有剩余位置，讲对象放入对应数组中，如果没有，则释放到对应的nodelists中。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核数据结构</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-data-structure/</link>
        <pubDate>Sat, 17 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-data-structure/</guid>
        <description>&lt;h1 id=&#34;内核链表&#34;&gt;内核链表&lt;/h1&gt;
&lt;p&gt;Linux内核有一些基本的数据结构，这些数据结构是Linux实现的基础，对于链表相信大家都不陌生，但是Linux内核中的链表与平常平常我们所使用的链表略有不同，第一次遇到或许会感到困惑。&lt;/p&gt;
&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;p&gt;先来看一个链表的节点，对于一个节点，分为两部分，一部分是数据，另一部分是串联数据的指针。Linux链表节点的定义如下(以下代码皆为3.5版本)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// include/linux/types.h
struct list_head {
        struct list_head *next, *prev;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的定义有些奇怪，因为仅有前后节点的指针，并没有数据，就像一串链子，只有线没有线上的珠子，肯定是无法使用，那Linux内核如何把这些“珠子”附着到线上的呢？&lt;/p&gt;
&lt;p&gt;来看一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struce simple {
	int data;
	struct list_head list;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;simple结构体的list成员指向下一个或者上一个simple的list，这样便把节点串联起来了，data作为“珠子”附着在list线上，但这样仍然有一个问题，list成员仅仅指向下一个simple的list成员，那从list成员如何得到simple节点的地址呢？&lt;/p&gt;
&lt;p&gt;答案是根据list成员的地址以及list成员在simple的位置便可以计算出simple对象的地址，这样有些繁琐，Linux提供了一个宏，可以简化这个过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// include/linux/list.h
/**
 * list_entry - get the struct for this entry
 * @ptr:        the &amp;amp;struct list_head pointer.
 * @type:       the type of the struct this is embedded in.
 * @member:     the name of the list_struct within the struct.
 */
#define list_entry(ptr, type, member) \
        container_of(ptr, type, member)

// include/linux/kernel.h
#define container_of(ptr, type, member) ({                      \
        const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})

#undef offsetof
#ifdef __compiler_offsetof
#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &amp;amp;((TYPE *)0)-&amp;gt;MEMBER)
#endif
#endif /* __KERNEL__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;list_entry&lt;/code&gt;直接调用了&lt;code&gt;container_of&lt;/code&gt;，&lt;code&gt;container_of&lt;/code&gt;分为两句，&lt;code&gt;((type *)0)-&amp;gt;member&lt;/code&gt;可以获得member在结构体type中的偏移，假设有一个结构体在地址0的位置，那么成员的地址便是成员对结构体的偏移，typeof是gcc的扩展，用于获取变量的类型，&lt;code&gt;offsetof(type,member)&lt;/code&gt; 获取member成员在type中的偏移，然后使用member成员的指针ptr（复制成&lt;code&gt;__mptr&lt;/code&gt;）减去偏移，即是结构体的地址。在我们的例子中，从list成员的地址获取simple结构的地址如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;simple * p = list_entry(ptr, struct simple, list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样便解决了从&lt;code&gt;list_head&lt;/code&gt;上获取附着的数据的问题。接下来需要解决对链表的增删改查的问题：&lt;/p&gt;
&lt;h2 id=&#34;初始化链表&#34;&gt;初始化链表&lt;/h2&gt;
&lt;p&gt;初始化链表有两种方法，LIST_HEAD_INIT和LIST_HEAD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }

#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
        list-&amp;gt;next = list;
        list-&amp;gt;prev = list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个指向自身的节点。&lt;/p&gt;
&lt;h2 id=&#34;插入节点&#34;&gt;插入节点&lt;/h2&gt;
&lt;p&gt;在节点后插入新节点&lt;code&gt;list_add_tail&lt;/code&gt;，和在节点前插入新节点&lt;code&gt;list_add&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
        __list_add(new, head, head-&amp;gt;next);
}

/**     
 * list_add_tail - add a new entry
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
        __list_add(new, head-&amp;gt;prev, head);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;__list_add&lt;/code&gt; 只是普通的链表操作，并无特别之处，可参见Linux源码查看实现。&lt;/p&gt;
&lt;h2 id=&#34;删除节点&#34;&gt;删除节点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;static inline void list_del(struct list_head *entry)
{
        __list_del(entry-&amp;gt;prev, entry-&amp;gt;next);
        entry-&amp;gt;next = LIST_POISON1;
        entry-&amp;gt;prev = LIST_POISON2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__list_del&lt;/code&gt; 把entry从链表中删除，之后把entry链表指针复制成非空指针（如果使用会出现段错误）&lt;/p&gt;
&lt;h2 id=&#34;检查是否空链表&#34;&gt;检查是否空链表&lt;/h2&gt;
&lt;p&gt;判断一个链表是否为空，只需要看头节点是否指向自己便可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline int list_empty(const struct list_head *head)
{
        return head-&amp;gt;next == head;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;遍历链表&#34;&gt;遍历链表&lt;/h2&gt;
&lt;p&gt;遍历是这几种操作中最为复杂的，有四个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define list_for_each(pos, head) \
        for (pos = (head)-&amp;gt;next; pos != (head); pos = pos-&amp;gt;next)

#define list_for_each_prev(pos, head) \
        for (pos = (head)-&amp;gt;prev; pos != (head); pos = pos-&amp;gt;prev)

#define list_for_each_entry(pos, head, member)                          \
        for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member);      \
             &amp;amp;pos-&amp;gt;member != (head);    \
             pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))

#define list_for_each_entry_reverse(pos, head, member)                  \
        for (pos = list_entry((head)-&amp;gt;prev, typeof(*pos), member);      \
             &amp;amp;pos-&amp;gt;member != (head);    \
             pos = list_entry(pos-&amp;gt;member.prev, typeof(*pos), member))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;list_for_each&lt;/code&gt; 和 &lt;code&gt;list_for_each_prev&lt;/code&gt; 较为简单，一个向后遍历，另一个向前遍历，&lt;code&gt;list_for_each_entry&lt;/code&gt;和&lt;code&gt;list_for_each_entry_reverse&lt;/code&gt;功能相似，不过不是对&lt;code&gt;list_head&lt;/code&gt;操作，而是直接对结构体操作，如我们这里的simple结构。根据之前的叙述也不难理解函数实现，只是在&lt;code&gt;list_head&lt;/code&gt;上调用了&lt;code&gt;list_entry&lt;/code&gt;获取了完整结构。&lt;/p&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;千言万语不如一个例子来的直观，我们通过一个简单的例子说明一下如何使用内核链表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/list.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

struct simple {
    int data;
    struct list_head list;
};

int main()
{
    int i = 0;
    struct simple * p;
    struct list_head * pos;
    LIST_HEAD(head);
    for (i = 0; i &amp;lt; 10; i++) {
        p = (struct simple*)malloc(sizeof(struct simple));
        p-&amp;gt;data = i * 10;
        list_add_tail(&amp;amp;p-&amp;gt;list, &amp;amp;head);
    }

    list_for_each_entry(p, &amp;amp;head, list) {
        printf(&amp;quot;for %d\n&amp;quot;, p-&amp;gt;data);
    }

    while (!list_empty(&amp;amp;head)) {
        pos = head.next;
        p = (struct simple*)list_entry(pos,
                struct simple, list);
        list_del(pos);
        printf(&amp;quot;del %d\n&amp;quot;, p-&amp;gt;data);
        free(p);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译参数为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcc -D__KERNEL__ -I/usr/src/linux-headers-3.2.0-27-generic/include/ -I/usr/src/linux-headers-3.2.0-27-generic/arch/ia64/include/ simple.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中头文件中都是内核函数，需要宏&lt;code&gt;__KERNEL__&lt;/code&gt;，否则大部分定义会被忽略。&lt;/p&gt;
&lt;h1 id=&#34;hash表&#34;&gt;Hash表&lt;/h1&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;链表虽然是最常见的数据结构，但实际使用中，由于链表的检索能力较差，更多的是作为队列和栈结构使用，如果需要查询，比如通过pid查找进程，通过描述符查找inode，就需要用到检索更快的数据结构——Hash表。
先来看Hash节点的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct hlist_head {
	struct hlist_node *first;
};
struct hlist_node {
	struct hlist_node *next, **pprev;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;hlist_head&lt;/code&gt; 为头结点，与链表不同的是还需要一个节点的概念 &lt;code&gt;hlist_node&lt;/code&gt;，他们之间的关系如图：&lt;/p&gt;
&lt;p&gt;左侧是定长数组，每个节点是 &lt;code&gt;hlist_head&lt;/code&gt; ，其中first指向 &lt;code&gt;hlist_node&lt;/code&gt; 节点，&lt;code&gt;hlist_node&lt;/code&gt;又组成一列链表，&lt;code&gt;hlist_node&lt;/code&gt;的链表结构跟 &lt;code&gt;list_head&lt;/code&gt;不同之处在于 &lt;code&gt;hlist_node&lt;/code&gt; 的 pprev 指向了 前一个节点的指针地址。&lt;/p&gt;
&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;
&lt;p&gt;Hash表使用起来也非常简单，首先通过hash函数计算目标值，得到一个索引，在&lt;code&gt;hlist_head&lt;/code&gt;数组中找到相应位置，再插入链表。Hash的链表Linux也提供了多种操作方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define INIT_HLIST_HEAD(ptr) ((ptr)-&amp;gt;first = NULL)
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h);
static inline void hlist_add_before(struct hlist_node *n, 
		struct hlist_node *next)
static inline void hlist_add_after(struct hlist_node *n, 
		struct hlist_node *next)
static inline void hlist_move_list(struct hlist_head *old,
		struct hlist_head *new);

#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
#define hlist_for_each(pos, head) \     
        for (pos = (head)-&amp;gt;first; pos ; pos = pos-&amp;gt;next)
#define hlist_for_each_entry(tpos, pos, head, member)                    \
        for (pos = (head)-&amp;gt;first;                                        \
             pos &amp;amp;&amp;amp;                                                      \
                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
             pos = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;INIT_HLIST_HEAD&lt;/code&gt; —— 初始化链表；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_add_head&lt;/code&gt; —— 在链表头插入节点；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_add_before&lt;/code&gt; —— 在一个节点之前插入；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_add_after&lt;/code&gt; —— 在一个节点之后插入；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_entry&lt;/code&gt; —— 同list_entry；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hlist_for_each&lt;/code&gt; —— 相关的一系列函数进行链表的遍历，与普通双向链表操作相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了Hash表中链表的操作，还有一个重要的元素是Hash函数，Hash函数的好坏直接影响Hash表的性能，Hash函数一般来讲跟具体要实现的业务相关，include/linux/jhash.h下实现了几个不同用途的Hash函数，另外，Linux还给出一个简单的Hash函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline u32 hash_32(u32 val, unsigned int bits)
{
        /* On some cpus multiply is faster, on others gcc will do shifts */
        u32 hash = val * GOLDEN_RATIO_PRIME_32;

        /* High bits are more random, so use them. */
        return hash &amp;gt;&amp;gt; (32 - bits);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数把32位整数Hash成bits位的整数，另外还有 &lt;code&gt;hash_64&lt;/code&gt; 等等Hash函数。&lt;/p&gt;
&lt;h2 id=&#34;实例-1&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;最后再来通过一个简单的例子看一下Hash表的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/list.h&amp;gt;
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/hash.h&amp;gt;

struct simple_hash
{
    int data;
    struct hlist_node node;
};

struct hlist_head * phash = NULL;

static int __init initialization(void)
{
    int i,k;
    struct hlist_head * phead;
    struct hlist_node * pnode;
    struct simple_hash * p;

    printk(KERN_INFO &amp;quot; init simple start\n&amp;quot;);

    phash = (struct hlist_head*)kmalloc(sizeof(struct hlist_head) * 0xFF, GFP_KERNEL);
    for (i = 0; i &amp;lt; 0xFF; i++) {
        INIT_HLIST_HEAD(&amp;amp;phash[i]);
    }
    for (i = 0; i &amp;lt; 10; i++) {
        p = (struct simple_hash*)kmalloc(sizeof(struct simple_hash), GFP_KERNEL);
        k = i * 13;

        p-&amp;gt;data = k;
        INIT_HLIST_NODE(&amp;amp;p-&amp;gt;node);

        printk(KERN_INFO &amp;quot;insert %d\n&amp;quot;, k);
        phead = &amp;amp;phash[hash_32(k, 8)];
        hlist_add_head(&amp;amp;p-&amp;gt;node, phead);
    }
    k = 3 * 13;
    phead = &amp;amp;phash[hash_32(k, 8)];
    printk(KERN_INFO &amp;quot;search %d\n&amp;quot;, k);
    hlist_for_each_entry(p, pnode, phead, node) {
        if (p-&amp;gt;data == k) {
            printk(KERN_INFO &amp;quot; find it\n&amp;quot;);
        }
    }

    printk(KERN_INFO &amp;quot;init simple end\n&amp;quot;);
    return 0;
}

static void __exit cleanup(void)
{
    int i;
    struct hlist_head * phead = NULL;
    struct simple_hash * p = NULL;
    printk(KERN_INFO &amp;quot;cleanup simple\n&amp;quot;);

    if (phash == NULL) {
        return;
    }

    for (i = 0; i &amp;lt; 0xFF; i++) {
        phead = &amp;amp;phash[i];
        while (!hlist_empty(phead)) {
            p = hlist_entry(phead-&amp;gt;first, struct simple_hash, node);
            printk(KERN_INFO &amp;quot;delete %d&amp;quot;, p-&amp;gt;data);
            hlist_del(&amp;amp;p-&amp;gt;node);
            kfree(p);
        }
    }
    kfree(phead);
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;cppbreak cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.1&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的代码是一个简单的Linux内核，关于如何写一个简单的Linux内核，可以参阅 Linux字符设备驱动框架&lt;/p&gt;
&lt;h1 id=&#34;红黑树&#34;&gt;红黑树&lt;/h1&gt;
&lt;h2 id=&#34;定义-1&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;Hash表虽然检索复杂度只需要O(1)，但是性能依赖于Hash函数，不合适的Hash函数会导致性能极其低下，而且需要预分配Hash头结点的空间，扩展性和性能稳定性都是问题，所以Linux内核另外还有一套快速插入查询的数据结构——红黑树。&lt;/p&gt;
&lt;p&gt;红黑树是一种平衡二叉树，二叉树查找效率是O(logn)，但对于某些极端情况下，一个分支的节点远高于另一个分支，处于不平衡状态下的二叉树性能很差，极端情况跟链表相同。所以出现很多保持二叉树平衡的方法，其中一种便是红黑树，红黑树在二叉树的基础上又规定了一些规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性质1：节点是红色或黑色。&lt;/li&gt;
&lt;li&gt;性质2：根节点是黑色。&lt;/li&gt;
&lt;li&gt;性质3：每个叶节点是黑色的。&lt;/li&gt;
&lt;li&gt;性质4：每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)&lt;/li&gt;
&lt;li&gt;性质5：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;红黑树的性质保证了从根节点到任何一个叶子节点的长度都不会相差两倍以上，只要在增删的过程中保持红黑树的性质，也便保持了树的平衡性。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;红黑树在内核中的实现位于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;linux/lib/rbtree.c
linux/include/linux/rbtree.h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;头文件 rbtree.h 中有红黑树节点的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct rb_node
{
	unsigned long  rb_parent_color;
#define RB_RED          0
#define RB_BLACK        1
	struct rb_node *rb_right;
	struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));
/* The alignment might seem pointless, but allegedly CRIS needs it */

struct rb_root
{
	struct rb_node *rb_node;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到红黑树同链表一样，都没有数据块的定义，因为C语言中没有模版，这样实现能使数据结构跟具体的业务分离，&lt;code&gt;rb_root&lt;/code&gt; 中仅有一个 rb_node 域，rb_node中有颜色和左右节点的指针，都很容易理解。&lt;/p&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;p&gt;节点的初始化操作，节点默认被置为红色：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline void rb_init_node(struct rb_node *rb)
{
	rb-&amp;gt;rb_parent_color = 0;
	rb-&amp;gt;rb_right = NULL;
	rb-&amp;gt;rb_left = NULL;
	RB_CLEAR_NODE(rb);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;增删操作&#34;&gt;增删操作&lt;/h2&gt;
&lt;p&gt;红黑树的增加删除操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// node为已插入的节点，函数检查树的平衡性并修正
void rb_insert_color(struct rb_node *node, struct rb_root *root);
// 删除节点
void rb_erase(struct rb_node *node, struct rb_root *root);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于二叉树需要比较数据区域的大小，这里仅仅有节点是不够的，所以插入操作需要调用者比较插入，然后调用&lt;code&gt;rb_insert_color&lt;/code&gt;调整树的平衡性，&lt;code&gt;rb_erase&lt;/code&gt;可以直接删除，另外搜索操作也需要用户根据二叉树的性质自己处理，在头文件rbtree.h开头的注释给了一个使用的例子，这里再试着写一个简单的例子：&lt;/p&gt;
&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/rbtree.h&amp;gt;

struct simple
{
    int data;
    struct rb_node node;
};

struct simple * search_simple(struct rb_root * root, int data)
{
    struct simple * p;
    struct rb_node * pnode = root-&amp;gt;rb_node;
    while (pnode)
    {
        p = rb_entry(pnode, struct simple, node);
        if (data &amp;lt; p-&amp;gt;data) {
            pnode = pnode-&amp;gt;rb_left;
        } else if (data &amp;gt; p-&amp;gt;data){
            pnode = pnode-&amp;gt;rb_right;
        } else {
            return p;
        }
    }
    return NULL;
}

struct simple * insert_simple(struct rb_root * root,
        int data, struct simple * new)
{
    struct simple * p = NULL;
    struct rb_node ** pnode = &amp;amp;root-&amp;gt;rb_node;
    struct rb_node * parent = NULL;
    while (*pnode)
    {
        parent = *pnode;
        p = rb_entry(parent, struct simple, node);
        if (data &amp;lt; p-&amp;gt;data) {
            pnode = &amp;amp;(*pnode)-&amp;gt;rb_left;
        } else if (data &amp;gt; p-&amp;gt;data){
            pnode = &amp;amp;(*pnode)-&amp;gt;rb_right;
        } else {
            return p;
        }
    }
    rb_link_node(&amp;amp;new-&amp;gt;node, parent, pnode);
    rb_insert_color(&amp;amp;new-&amp;gt;node, root);
    return p;
}

struct rb_root g_root = RB_ROOT;

static int __init initialization(void)
{
    int i;
    struct simple * p;
    for (i = 0; i &amp;lt; 10; i++) {
        p = (struct simple *)kmalloc(sizeof (struct simple),
                GFP_KERNEL);
        p-&amp;gt;data = i * 10;
        rb_init_node(&amp;amp;p-&amp;gt;node);
        insert_simple(&amp;amp;g_root, i * 10, p);
        printk(KERN_INFO &amp;quot;insert %d\n&amp;quot;, i * 10);
    }
    p = search_simple(&amp;amp;g_root, 30);
    if (p != NULL) {
        printk(KERN_INFO &amp;quot;find it\n&amp;quot;);
    }

    return 0;
}

static void __exit cleanup(void)
{
    struct simple * p;
    struct rb_node * pnode = rb_first(&amp;amp;g_root);
    while (pnode != NULL) {
        p = rb_entry(pnode, struct simple, node);        
        printk(KERN_INFO &amp;quot;delete %d\n&amp;quot;, p-&amp;gt;data);
        rb_erase(pnode, &amp;amp;g_root);
        kfree(p);
        pnode = rb_first(&amp;amp;g_root);
    }
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;cppbreak cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.1&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序编译运行请参考 Linux字符设备驱动框架。&lt;/p&gt;
&lt;h1 id=&#34;radix-tree&#34;&gt;Radix Tree&lt;/h1&gt;
&lt;h2 id=&#34;定义-2&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;Linux内核实现了大量的数据结构，其中树结构除了前面提到的红黑树以外，还有一种很有意思的树-Radix Tree，翻译为基数树。Radix Tree也是一种key-value结构，要说最快速的key-value查找结构，非数组莫属，只需一次定位便可找到目标值，其缺点是需要占用过多的内存空间，如果连续的key中大多数都是空值，空间的利用率会非常低，如一个整数范围的key，value占一个字节也需要4G的存储，当key非常稀疏的情况下，无疑是一种浪费，Radix Tree的解决方式是分级，简单来说，如果按照整数的尾数分为2级，第一级需要10个指针即可，尾数为0的key映射到第一个指针上，第一个指针再指向存储数组，这样如果只有0-4的key，便可不需要给5-9的指针分配空间，可节省一半的空间。当然这只是简单的例子，内核的Radix Tree更为精炼。&lt;/p&gt;
&lt;h2 id=&#34;实现-1&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;Linux内核的根据Radix Tree的高度把key分为若干段，如下图所示，每段长度固定为&lt;code&gt;RADIX_TREE_MAP_SHIFT&lt;/code&gt;，树高度可通过&lt;code&gt;radix_tree_extend&lt;/code&gt;扩展，key的每一段分别指定了每一层的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://drawing.fancymore.com/keep/2014/0_radix-tree.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Radix Tree&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;接下来可以看一些处理细节：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct radix_tree_node {
	unsigned int    height;         /* Height from the bottom */
	unsigned int    count;
	union {
		struct radix_tree_node *parent; /* Used when ascending tree */
		struct rcu_head rcu_head;       /* Used when freeing node */
	};
	void __rcu      *slots[RADIX_TREE_MAP_SIZE];
	unsigned long   tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;radix_tree_node&lt;/code&gt; 是基数树的节点定义，其中最主要的字段是 &lt;code&gt;RADIX_TREE_MAP_SIZE&lt;/code&gt; 大小的数组 slots，其中可以指向下一层节点或者叶子节点 item。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct radix_tree_root {
	unsigned int            height;
	gfp_t                   gfp_mask;
	struct radix_tree_node  __rcu *rnode;
};

#define RADIX_TREE_INIT(mask)   {                                       \
	.height = 0,                                                    \
	.gfp_mask = (mask),                                             \
	.rnode = NULL,                                                  \
}

#define RADIX_TREE(name, mask) \
struct radix_tree_root name = RADIX_TREE_INIT(mask)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;radix_tree_root&lt;/code&gt; 是根节点类型，记录了数高度 height 和第一层节点rnode，&lt;code&gt;RADIX_TREE_INIT&lt;/code&gt;宏对根节点初始化。&lt;/p&gt;
&lt;p&gt;接下来看基数树的核心，如何插入节点和如何查找节点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int radix_tree_insert(struct radix_tree_root *root,
				unsigned long index, void *item)
{
	/** 省略 */
	/* Make sure the tree is high enough.  */
	if (index &amp;gt; radix_tree_maxindex(root-&amp;gt;height)) {
		error = radix_tree_extend(root, index);
		if (error)
			return error;
	}

	slot = indirect_to_ptr(root-&amp;gt;rnode);

	height = root-&amp;gt;height;
	shift = (height-1) * RADIX_TREE_MAP_SHIFT;

	offset = 0;                     /* uninitialised var warning */
	while (height &amp;gt; 0) {
		if (slot == NULL) {
			/* Have to add a child node.  */
			if (!(slot = radix_tree_node_alloc(root)))
				return -ENOMEM;
			slot-&amp;gt;height = height;
			slot-&amp;gt;parent = node;
			if (node) {
				rcu_assign_pointer(node-&amp;gt;slots[offset], slot);
				node-&amp;gt;count++;
			} else
				rcu_assign_pointer(root-&amp;gt;rnode, ptr_to_indirect(slot));
		}

		/* Go a level down */
		offset = (index &amp;gt;&amp;gt; shift) &amp;amp; RADIX_TREE_MAP_MASK;
		node = slot;
		slot = node-&amp;gt;slots[offset];
		shift -= RADIX_TREE_MAP_SHIFT;
		height--;
	}

	/** 省略 */
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;篇幅关系简略了代码，代码首先使用 &lt;code&gt;radix_tree_maxindex&lt;/code&gt; 计算树高度是否能够存储 index，不行就调用 &lt;code&gt;radix_tree_extend&lt;/code&gt; 扩展树高度，紧接着根据key的每个字段定位节点，直到到达树叶子节点，如果树节点未分配空间，则调用 &lt;code&gt;radix_tree_node_alloc&lt;/code&gt; 分配，最后再把 item 挂接到叶子节点上，完成插入操作。&lt;/p&gt;
&lt;p&gt;基数树查找操作为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void *radix_tree_lookup_element(struct radix_tree_root *root,
			unsigned long index, int is_slot);

void *radix_tree_lookup(struct radix_tree_root *root, unsigned long index)
{
	return radix_tree_lookup_element(root, index, 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;radix_tree_lookup_element&lt;/code&gt; 查找过程与插入操作类似，比较容易理解。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux系统调用</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-system-call/</link>
        <pubDate>Fri, 16 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-system-call/</guid>
        <description>&lt;p&gt;操作系统管理软硬件资源，用户进程只能直接或间接的通过系统调用访问系统资源，而用户进程与内核运行于不同的权限空间，需要进行用户态到内核态的转变，这一转变是通过系统中断实现。现以getpid为例：&lt;/p&gt;
&lt;p&gt;在用户态通过API接口编程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main()
{
    return printf(&amp;quot;pid is %d\n&amp;quot;, getpid()) &amp;gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getpid 为应用编程接口(API)函数，提供统一标准接口，实现是通过系统调用获得进程ID。
系统调用函数由唯一的调用号标识，x86构架下在文件 arch/x86/include/asm/unistd.h 指定，实现文件根据32位系统与64为系统的不同分别实现在相同目录的unistd_32.h和unistd_64.h文件，现通过64位系统分析，32位系统原理相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define __NR_getpid                             39
__SYSCALL(__NR_getpid, sys_getpid)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到getpid系统调用号为 39， 当然这在不同的系统上并不一定相同，getpid API函数的封装正是封装了种种不同。&lt;/p&gt;
&lt;p&gt;系统初始化时创建名为 &lt;code&gt;sys_call_table&lt;/code&gt; 的表项，其中存储了系统调用函数，而&lt;code&gt;__NR_*&lt;/code&gt;调用号正是表项索引，&lt;code&gt;sys_call_table&lt;/code&gt;的定义 32构架位于 &lt;code&gt;arch/x86/kernel/syscall_table_32.S&lt;/code&gt;，&lt;code&gt;sys_call_table&lt;/code&gt; 为起始地址依次存储一系列函数地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::
ENTRY(sys_call_table)
	.long sys_restart_syscall	/* 0 - old &amp;quot;setup()&amp;quot; system call, used for restarting */
	.long sys_exit
	.long ptregs_fork
	.long sys_read
	.long sys_write
	.long sys_open		/* 5 */
	.long sys_close
	.long sys_waitpid
	.long sys_creat
	.long sys_link
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;64位构架位于&lt;code&gt;arch/x86/kernel/syscall_64.c&lt;/code&gt;，这里干脆定义成了一个&lt;code&gt;sys_call_ptr_t&lt;/code&gt;类型数组，其初始化由宏&lt;code&gt;__SYSCALL&lt;/code&gt;完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
	/*
	*Smells like a like a compiler bug -- it doesn&#39;t work
	*when the &amp;amp; below is removed.
	*/
	[0 ... __NR_syscall_max] = &amp;amp;sys_ni_syscall,
#include &amp;lt;asm/unistd_64.h&amp;gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统调用时，根据 &lt;code&gt;sys_call_table[__NR_getpid]&lt;/code&gt; 获得 &lt;code&gt;sys_getpid&lt;/code&gt; 地址调用之。如此，我们便可通过修改 &lt;code&gt;sys_call_table&lt;/code&gt; 的初始化和&lt;code&gt;__NR_*&lt;/code&gt;的定义来增加自己的系统调用和修改原来系统调用的执行方式。&lt;/p&gt;
&lt;p&gt;倘若增加我们自己的系统调用，那接下来一问题是我们如何调用？getpid函数由glibc库封装，接下来需要看如何直接调用该内核函数。当然，通过源码可以看到getpid的实现即为 &lt;code&gt;sys_getpid&lt;/code&gt; 函数，但因为调用需要进行特权级的转变，所以直接调用&lt;code&gt;sys_getpid&lt;/code&gt;函数是行不通的。&lt;/p&gt;
&lt;p&gt;在Linux内核 2.6.20 以前，是存在一系列宏方便调用的，不同参数调用&lt;code&gt;_syscall0&lt;/code&gt;,&lt;code&gt;_syscall1&lt;/code&gt;,&lt;code&gt;_syscall2&lt;/code&gt;等等，但是据说为了防止内核漏洞取消了这些宏，当然，从 2.6.19 拷贝出这些宏的实现，还是可以使用的，这里只是简单说明一下原理即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 摘自2.6.20内核源码 include/asm-x86_64/unistd.h */
#define __syscall &amp;quot;syscall&amp;quot;
...
#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile (__syscall \
	: &amp;quot;=a&amp;quot; (__res) \
	: &amp;quot;0&amp;quot; (__NR_##name) : __syscall_clobber ); \
__syscall_return(type,__res); \

/* 摘自2.6.20内核源码 include/asm-i386/unistd.h */
#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile (&amp;quot;int $0x80&amp;quot; \
        : &amp;quot;=a&amp;quot; (__res) \
        : &amp;quot;0&amp;quot; (__NR_##name)); \
__syscall_return(type,__res); \
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，64位系统使用 syscall 指令进行系统调用，32系统使用 int 0×80指令。以64位系统举例，直接调用getpid的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main()
{
	pid_t pid = 0;
	asm (
		&amp;quot;syscall&amp;quot; \
		: &amp;quot;=a&amp;quot;(pid) \
		: &amp;quot;0&amp;quot;(39) \
	);
	printf(&amp;quot;pid is %d\n&amp;quot;, pid);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此一来，我们便可通过通过syscall指令或者int指令调用我们自己定义的系统函数。&lt;/p&gt;
&lt;p&gt;更进一步，再调用syscall指令之后，系统进行用户态向内核态转变，这个过程分为两部分，一部分是硬件支持，即cpu所作操作，另一部分，是软件支持，位于 &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt; 和 &lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt; 文件的&lt;code&gt;system_call&lt;/code&gt;，这里暂不分析。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 设备驱动轮询编程</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-driver-select-implement/</link>
        <pubDate>Thu, 15 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-driver-select-implement/</guid>
        <description>&lt;p&gt;Linux系统下网络模型数select最为常用，当然，select只是检测文件系统数据状态，并不只局限于网络编程，select的功能需要底层驱动提供支持，其中核心应用即为&lt;a class=&#34;link&#34; href=&#34;./linux-kernel-waiting-queue/&#34; &gt;等待队列&lt;/a&gt;，其他模型，如poll和epoll，对驱动来说并无区别，驱动只是返回数据状态而已。&lt;/p&gt;
&lt;p&gt;那在驱动层面是如何支持select的呢？驱动需要实现&lt;code&gt;file_operations&lt;/code&gt;结构中的poll函数指针，其实现也非常简单，只是&lt;code&gt;poll_wait&lt;/code&gt;函数的调用，原型如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int (*poll) (struct file *, struct poll_table_struct *);
void poll_wait(struct file *filp, wait_queue_head_t *queue, poll_table * wait);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是poll_wait函数不会像它名字一样处于wait状态，仅供上层查询之用。其编程基本框架也比较固定，现修改 &lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/linux-character-driver.html&#34; &gt;字符驱动&lt;/a&gt; 中的simple程序，实现poll回调函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int simple_poll (struct file * filp, struct poll_table_struct * wait)
{
	unsigned int mask = 0;
	poll_wait(filp, &amp;amp;simple_queue, wait);

	if (len &amp;gt; 0)
	{
		mask |= POLLIN | POLLRDNORM;
	}

	return mask;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每次read之后都把len赋值为0，调用write把len赋值为数据长，poll中只需判断len，如果len大于0，则返回可读，整理之后，整个程序代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;

#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/cdev.h&amp;gt;
#include &amp;lt;linux/mm.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;
#include &amp;lt;asm/io.h&amp;gt;
#include &amp;lt;asm/uaccess.h&amp;gt;
#include &amp;lt;asm/system.h&amp;gt;

#include &amp;lt;linux/device.h&amp;gt;
#include &amp;lt;linux/poll.h&amp;gt;

dev_t devno;
struct class * simple_class;
static struct cdev cdev;

wait_queue_head_t simple_queue;

char test_data[255];
int len = 0;

unsigned int simple_poll (struct file * filp, struct poll_table_struct * wait)
{
	unsigned int mask = 0;
	poll_wait(filp, &amp;amp;simple_queue, wait);

	if (len &amp;gt; 0)
	{
		mask |= POLLIN | POLLRDNORM;
	}

	return mask;
}

ssize_t simple_read(struct file * pfile,
	char __user * buf, size_t size, loff_t * ppos)
{
	int ret = len;
	len = 0;
	if (copy_to_user(buf, test_data, ret))
		return -EFAULT;
	else
		return ret;
}

ssize_t simple_write(struct file * pfile, const char __user * buf, size_t count, loff_t * ppos)
{
	if (count &amp;gt; 255)
	{
		return -EFAULT;
	}

	if (!copy_from_user(test_data, buf, count))
	{
		len = count;
		wake_up(&amp;amp;simple_queue);
	}
	return len;
}

int simple_open(struct inode * pnode, struct file * pfile)
{
	printk(KERN_INFO &amp;quot;open simple\n&amp;quot;);
	return 0;
}

int simple_release(struct inode * pnode, struct file * pfile)
{
	printk(KERN_INFO &amp;quot;close simple\n&amp;quot;);
	return 0;
}

static struct file_operations simple_op = 
{
	.owner = THIS_MODULE,
	.read = simple_read,
	.open = simple_open,
	.release = simple_release,
	.write = simple_write,
	.poll = simple_poll,
};

static int __init initialization(void)
{
	int result;

	result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;quot;simple&amp;quot;);
	if (result &amp;lt; 0)
		return result;

	cdev_init(&amp;amp;cdev, &amp;amp;simple_op);
	result = cdev_add(&amp;amp;cdev, devno, 1);

	simple_class = class_create(THIS_MODULE, &amp;quot;simple&amp;quot;);
	device_create(simple_class, NULL, devno, NULL, &amp;quot;simple&amp;quot;);

	printk(KERN_INFO &amp;quot; init simple\n&amp;quot;);

	init_waitqueue_head(&amp;amp;simple_queue);

	return result;
}

static void __exit cleanup(void)
{
	device_destroy(simple_class, devno);
	class_destroy(simple_class);

	cdev_del(&amp;amp;cdev);
	unregister_chrdev_region(devno, 1);
	printk(KERN_INFO &amp;quot; cleanup simple\n&amp;quot;);
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;alloc cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.1&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户态使用select测试程序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/select.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
int main()
{
	int fd, ret;
	char data[255];
	fd_set set;

	fd = open(&amp;quot;/dev/simple&amp;quot;, O_RDONLY | O_NONBLOCK);
	while (fd != -1)
	{
		FD_ZERO(&amp;amp;set);
		FD_SET(fd, &amp;amp;set);
		select(fd + 1, &amp;amp;set, 0, 0, 0);
		if (FD_ISSET(fd, &amp;amp;set))
		{
			printf(&amp;quot;simple can read\n&amp;quot;);
			ret = read(fd, data, 255);
			data[ret] = 0;
			printf(&amp;quot;\t%s\n&amp;quot;, data);
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终效果，加载驱动之后，使用uesr程序select，会进入阻塞状态，当再另一个终端下写入数据 echo “simple” &amp;gt; /dev/simple 后程序解除阻塞，输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
[root@cpphost driver]# ./a.out 
simple can read
	simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，简单的几行代码就可让设备驱动支持select模型，复杂而又繁琐的工作都有系统内核处理掉了。&lt;/p&gt;
&lt;p&gt;受好奇心驱使，可能会想系统是如何处理select请求的，select是个系统调用，最后会走到内核的&lt;code&gt;do_select&lt;/code&gt;函数，位于fs/select.c，代码结构大致如下（仅留下框架）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int do_select(int n, fd_set_bits *fds, struct timespec *end_time)
{
	...
	struct poll_wqueues table;
	poll_table *wait;
	...
	poll_initwait(&amp;amp;table);
	...
	for (;;) {
		...
		for (i = 0; i &amp;lt; n; ++rinp, ++routp, ++rexp) {
			...
			for (j = 0; j &amp;lt; __NFDBITS; ++j, ++i, bit &amp;lt;f_op;
					mask = DEFAULT_POLLMASK;
					if (f_op &amp;amp;&amp;amp; f_op-&amp;gt;poll) {
						wait_key_set(wait, in, out, bit);
						/* 这里，调用了f_op的poll函数，即我们的实现 */
						mask = (*f_op-&amp;gt;poll)(file, wait);
					}
					...
					if ((mask &amp;amp; POLLIN_SET) &amp;amp;&amp;amp; (in &amp;amp; bit)) {
						res_in |= bit;
						retval++;
						wait = NULL;
					}
					if ((mask &amp;amp; POLLOUT_SET) &amp;amp;&amp;amp; (out &amp;amp; bit)) {
						res_out |= bit;
						retval++;
						wait = NULL;
					}
					if ((mask &amp;amp; POLLEX_SET) &amp;amp;&amp;amp; (ex &amp;amp; bit)) {
						res_ex |= bit;
						retval++;
						wait = NULL;
					}
				}
			}
			if (res_in)
				*rinp = res_in;
			if (res_out)
				*routp = res_out;
			if (res_ex)
				*rexp = res_ex;
			/* 这里进行调度 */
			cond_resched();
		}
		...
		/* 超时处理 */
		if (!poll_schedule_timeout(&amp;amp;table, TASK_INTERRUPTIBLE,
					   to, slack))
			timed_out = 1;
	}
	/* 释放table */
	poll_freewait(&amp;amp;table);

	return retval;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大致结构也很清晰，进入select时，首先初始化一个等待变量wait，对每一个描述符循环调用对应的poll回调函数，驱动中poll函数又把wait加入自己的等待队列，这样当有数据时，可以及时唤醒select，poll回调返回后，select检查返回的mask，是否有数据可读写，如果都没有，则调用&lt;code&gt;cond_resched();&lt;/code&gt;进入等待，等待超时或者write唤醒等待队列。&lt;/p&gt;
&lt;p&gt;这个过程也验证了select是遍历每个描述符，当描述符增多时导致效率线性下降，所以有了更为先进的 epoll 模型，具体实现可以参考 &lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/linux-kernel-epoll.html&#34; &gt;epoll源码分析&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux 内核等待队列解析</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-waiting-queue/</link>
        <pubDate>Wed, 14 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-waiting-queue/</guid>
        <description>&lt;p&gt;在阅读Tun驱动时看到，有一些类似 &lt;code&gt;add_wait_queue&lt;/code&gt; 的函数，这些函数正是执行等待队列的相关操作，要说等待队列还得从内核进程调度说起，内核调度系统内进程，分配时间片，但是有些进程如从网卡中读数据，在网卡有数据到达之前进程处于阻塞状态，如果此时给相应进程分配时间片做调度，无疑是浪费系统资源，所以系统内每个进程都有自己的状态标志 task-&amp;gt;state，这些状态定义于文件 include/linux/sched.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define TASK_RUNNING            0
#define TASK_INTERRUPTIBLE      1
#define TASK_UNINTERRUPTIBLE    2
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内核只会调用标志是 &lt;code&gt;TASK_RUNNING&lt;/code&gt; 的进程，如果需要等待资源，可以设置自己的进程标志为 &lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt; （可中断）或者 &lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt; （不可中断），然后调用 schedule();放弃CPU，此进程就不会被内核调度了，但随之而来的问题是，如果进程所需资源可以使用，如何唤醒进程呢，这就要依赖于等待队列了，进程在放弃控制权之前，把自己加入一个队列中，当所需条件满足，其他进程便可wakeup该队列，修改进程状态为 &lt;code&gt;TASK_RUNNING&lt;/code&gt;，等待进程便可顺利往下执行了。&lt;/p&gt;
&lt;p&gt;与等待队列相关的操作有如下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 等待队列头声明 */
wait_queue_head_t simple_queue;

/* 初始化等待队列头 */
init_waitqueue_head(&amp;amp;simple_queue);

/* 定义等待队列项 */
DECLARE_WAITQUEUE (name, tsk);

/* 添加删除等待项 */
void fastcall add_wait_queue(wait_queue_head_t * q, wait_queue_t * wait);
void fastcall remove_wait_queue(wait_queue_head_t * q, wait_queue_t * wait);

/* 唤醒等待头中的所有项 */
void wake_up(wait_queue_head_t * queue);
void wake_up_interruptible(wait_queue_head_t * queue);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合这些函数，再往simple驱动里添加一些简单的机制支持等待。在 &lt;code&gt;simple_read&lt;/code&gt; 函数中修改当前进程状态，加入等待队列后，放弃控制权，另加入 &lt;code&gt;simple_write&lt;/code&gt; 函数唤醒队列。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;linux/init.h&amp;gt;
#include&amp;lt;linux/module.h&amp;gt;

#include&amp;lt;linux/fs.h&amp;gt;
#include&amp;lt;linux/types.h&amp;gt;
#include&amp;lt;linux/cdev.h&amp;gt;
#include&amp;lt;linux/mm.h&amp;gt;
#include&amp;lt;linux/sched.h&amp;gt;
#include&amp;lt;asm/io.h&amp;gt;
#include&amp;lt;asm/uaccess.h&amp;gt;
#include&amp;lt;asm/system.h&amp;gt;

#include&amp;lt;linux/device.h&amp;gt;

dev_t devno;
struct class * simple_class;
static struct cdev cdev;

wait_queue_head_t simple_queue;

char test_data[255];
int len;

ssize_t simple_read(struct file * pfile,
    char __user * buf, size_t size, loff_t * ppos)
{
    /* 定义一个等待项，添加到等待队列，并设置进程状态后放弃执行权 */
    DECLARE_WAITQUEUE (simple_item, current);
    add_wait_queue(&amp;amp;simple_queue, &amp;amp;simple_item);
    current-&amp;gt;state = TASK_INTERRUPTIBLE;
    schedule();
    /* 被唤醒以后，从队列中移除 */
    remove_wait_queue(&amp;amp;simple_queue, &amp;amp;simple_item);

    if (copy_to_user(buf, test_data, len))
        return -EFAULT;
    else
        return len;
}

ssize_t simple_write(struct file * pfile, const char __user * buf, size_t count, loff_t * ppos)
{
    if (count &amp;gt; 255)
    {
        return -EFAULT;
    }

    if (!copy_from_user(test_data, buf, count))
    {
        len = count;
        /* 唤醒等待队列中所有进程 */
        wake_up(&amp;amp;simple_queue);
    }
    return len;
}

int simple_open(struct inode * pnode, struct file * pfile)
{
    printk(KERN_INFO &amp;quot;open simple\n&amp;quot;);
    return 0;
}

int simple_release(struct inode * pnode, struct file * pfile)
{
    printk(KERN_INFO &amp;quot;close simple\n&amp;quot;);
    return 0;
}

static struct file_operations simple_op =
{
    .owner = THIS_MODULE,
    .read = simple_read,
    .open = simple_open,
    .release = simple_release,
    .write = simple_write,
};

static int __init initialization(void)
{
    int result;

    result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;quot;simple&amp;quot;);
    if (result &amp;lt; 0)
        return result;

    cdev_init(&amp;amp;cdev, &amp;amp;simple_op);
    result = cdev_add(&amp;amp;cdev, devno, 1);

    simple_class = class_create(THIS_MODULE, &amp;quot;simple&amp;quot;);
    device_create(simple_class, NULL, devno, NULL, &amp;quot;simple&amp;quot;);

    printk(KERN_INFO &amp;quot; init simple\n&amp;quot;);

    init_waitqueue_head(&amp;amp;simple_queue);

    return result;
}

static void __exit cleanup(void)
{
    device_destroy(simple_class, devno);
    class_destroy(simple_class);

    cdev_del(&amp;amp;cdev);
    unregister_chrdev_region(devno, 1);
    printk(KERN_INFO &amp;quot; cleanup simple\n&amp;quot;);
}

module_init(initialization);
module_exit(cleanup);

MODULE_AUTHOR(&amp;quot;alloc cppbreak@gmail.com&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;A simple linux kernel module&amp;quot;);
MODULE_VERSION(&amp;quot;V0.2&amp;quot;);
MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加载模块 insmod simple.ko 后，使用cat读取数据，cat /dev/simple， 会发现进程处于等待状态，不会输出任何信息，新打开一个终端，输入echo “test” &amp;gt; /dev/simple执行写操作，cat便会输出数据，紧接着再次处于等待状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insmod simple.ko
cat /dev/simple        ---&amp;gt;    进程等待
first            ---&amp;gt;    echo &amp;quot;first&amp;quot; &amp;gt; /dev/simple
cool            ---&amp;gt;    echo &amp;quot;cool&amp;quot; &amp;gt; /dev/simple
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>select/poll 源码分析</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-epoll/</link>
        <pubDate>Tue, 13 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-kernel-epoll/</guid>
        <description>&lt;p&gt;select/poll模型一直是Linux长期以来使用较多的服务器模型，自从2.6内核引入epoll模型以后，我们又有了一种更加有效的服务器模型，一直以来都耳闻epoll模型对比select模型的优点，赞誉之声一片，他如何高效，高效到什么程度，还是一知半解，在之前的一篇博客，我简要分析了select模型代码，的确正如前人所言，使用轮询方式处理连接，这里我讲分析epoll模型的框架，体会其高效。&lt;/p&gt;
&lt;p&gt;这里先简略说明一下epoll的使用流程，其使用或许比select模型更为简洁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;epoll_create(size);

while (...)
{
	/* 等待就绪连接 */
	epoll_wait( ... );

	/* 如有新连接，构造epoll_event结构体后 */
	epoll_ctl( ... EPOLL_CTL_ADD ... );
	/* 如有断开连接 */
	epoll_ctl( ... EPOLL_CTL_DEL ... );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从使用角度出发，先来看&lt;code&gt;epoll_create&lt;/code&gt;函数的实现，用户态声明&lt;code&gt;int epoll_create(int size);&lt;/code&gt;对应的系统调用代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::
SYSCALL_DEFINE1(epoll_create, int, size)
{
	if (size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;sys_epoll_create&lt;/code&gt;仅仅检测size是否小于0，之后直接调用&lt;code&gt;sys_epoll_create1&lt;/code&gt;，也就是说size在2.6.34版本中是没有使用的，通过查阅代码，发现&lt;code&gt;sys_epoll_create1&lt;/code&gt;是在2.6.27版本中加入的，但是之前的几个版本也仅仅只是输出日志时使用，没有回溯查看真正废弃改值是在哪个版本，总之真正的实现是位于&lt;code&gt;sys_epoll_create1&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SYSCALL_DEFINE1(epoll_create1, int, flags)
{
	int error;
	struct eventpoll *ep = NULL;

	/* Check the EPOLL_* constant for consistency.  */
	BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);

	if (flags &amp;amp; ~EPOLL_CLOEXEC)
		return -EINVAL;
	/*
	 * Create the internal data structure (&amp;quot;struct eventpoll&amp;quot;).
	 */
	error = ep_alloc(&amp;amp;ep);
	if (error &amp;lt; 0)
		return error;
	/*
	 * Creates all the items needed to setup an eventpoll file. That is,
	 * a file structure and a free file descriptor.
	 */
	error = anon_inode_getfd(&amp;quot;[eventpoll]&amp;quot;, &amp;amp;eventpoll_fops, ep,
				 O_RDWR | (flags &amp;amp; O_CLOEXEC));
	if (error &amp;lt; 0)
		ep_free(ep);

	return error;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码结构比较清晰，调用&lt;code&gt;ep_alloc&lt;/code&gt;分配一个eventpoll结构，调用&lt;code&gt;anon_inode_getfd&lt;/code&gt;创建一个文件节点和文件描述符，并返回文件描述符，这个文件描述符供epoll自己使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
		struct epoll_event __user *, event)
{
	int error;
	struct file *file, *tfile;
	struct eventpoll *ep;
	struct epitem *epi;
	struct epoll_event epds;

	...
	/* 从file结构私有数据取出ep_alloc分配的结构 */
	ep = file-&amp;gt;private_data;

	mutex_lock(&amp;amp;ep-&amp;gt;mtx);

	/*
	 * Try to lookup the file inside our RB tree, Since we grabbed &amp;quot;mtx&amp;quot;
	 * above, we can be sure to be able to use the item looked up by
	 * ep_find() till we release the mutex.
	 */
	epi = ep_find(ep, tfile, fd);

	error = -EINVAL;
	switch (op) {
	case EPOLL_CTL_ADD:
		if (!epi) {
			epds.events |= POLLERR | POLLHUP;
			error = ep_insert(ep, &amp;amp;epds, tfile, fd);
		} else
			error = -EEXIST;
		break;
	case EPOLL_CTL_DEL:
		if (epi)
			error = ep_remove(ep, epi);
		else
			error = -ENOENT;
		break;
	case EPOLL_CTL_MOD:
		if (epi) {
			epds.events |= POLLERR | POLLHUP;
			error = ep_modify(ep, epi, &amp;amp;epds);
		} else
			error = -ENOENT;
		break;
	}
	mutex_unlock(&amp;amp;ep-&amp;gt;mtx);

error_tgt_fput:
	fput(tfile);
error_fput:
	fput(file);
error_return:

	return error;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去除错误检测，剩下的代码也比较清晰，首先取出&lt;code&gt;epoll_create1&lt;/code&gt;分配的eventpoll结构ep，然后使用&lt;code&gt;ep_find&lt;/code&gt;在ep中查找当前操作的文件描述符，接下来有个判断，分不同操作进行，如果是&lt;code&gt;EPOLL_CTL_ADD&lt;/code&gt;，则调&lt;code&gt;ep_insert&lt;/code&gt;插入文件描述符，如果是&lt;code&gt;EPOLL_CTL_DEL&lt;/code&gt;则调用&lt;code&gt;ep_remove&lt;/code&gt;删除文件描述符，修改则用&lt;code&gt;ep_modify&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;姑且先忽略ep操作的函数，直接去看epoll_wait的实现，以明确流程。
&lt;code&gt;epoll_wait&lt;/code&gt;实现与1321行，不过其中所作操作非常简单：从file结构中取出eventpoll结构，直接调用&lt;code&gt;ep_poll&lt;/code&gt;，我们需要着重分析&lt;code&gt;ep_poll&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
		   int maxevents, long timeout)
{
	int res, eavail;
	unsigned long flags;
	long jtimeout;
	wait_queue_t wait;

	...

	res = 0;
	if (list_empty(&amp;amp;ep-&amp;gt;rdllist)) {
		/*
		 * We don&#39;t have any available event to return to the caller.
		 * We need to sleep here, and we will be wake up by
		 * ep_poll_callback() when events will become available.
		 */
		init_waitqueue_entry(&amp;amp;wait, current);
		wait.flags |= WQ_FLAG_EXCLUSIVE;
		__add_wait_queue(&amp;amp;ep-&amp;gt;wq, &amp;amp;wait);

		for (;;) {
			/*
			 * We don&#39;t want to sleep if the ep_poll_callback() sends us
			 * a wakeup in between. That&#39;s why we set the task state
			 * to TASK_INTERRUPTIBLE before doing the checks.
			 */
			set_current_state(TASK_INTERRUPTIBLE);
			if (!list_empty(&amp;amp;ep-&amp;gt;rdllist) || !jtimeout)
				break;
			if (signal_pending(current)) {
				res = -EINTR;
				break;
			}

			spin_unlock_irqrestore(&amp;amp;ep-&amp;gt;lock, flags);
			jtimeout = schedule_timeout(jtimeout);
			spin_lock_irqsave(&amp;amp;ep-&amp;gt;lock, flags);
		}
		__remove_wait_queue(&amp;amp;ep-&amp;gt;wq, &amp;amp;wait);

		set_current_state(TASK_RUNNING);
	}

	...

	if (!res &amp;amp;&amp;amp; eavail &amp;amp;&amp;amp;
	    !(res = ep_send_events(ep, events, maxevents)) &amp;amp;&amp;amp; jtimeout)
		goto retry;

	return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于篇幅限制去除一些不影响大致流程的代码，剩下的居然异常简单，首先用&lt;code&gt;list_empty&lt;/code&gt;判断&lt;code&gt;ep-&amp;gt;rdllist&lt;/code&gt;链表是否为空，rdllist是就绪的文件链表，如果不为空可以直接返回给上层，如果不为空，则等待，等待的方式也比较清晰，把自己加入到ep-&amp;gt;wq等待队列中，然后&lt;code&gt;schedule_timeout(jtimeout);&lt;/code&gt;放弃运行权即可，完成后使用&lt;code&gt;ep_send_events&lt;/code&gt;把结果返回给上层。&lt;/p&gt;
&lt;p&gt;原本以为epoll会同select一样，把核心代码放到wait函数中，想不到此函数草草了事，除了查看链表是否为空和休息，基本什么也没有做，看来epoll之所以比select效率高的原因尽在于此。但现在的问题是，谁去填充队列rdllist，谁去唤醒该进程？看来还得从之前忽略了的ep_insert函数入手。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
		     struct file *tfile, int fd)
{
	int error, revents, pwake = 0;
	unsigned long flags;
	struct epitem *epi;
	struct ep_pqueue epq;

	if (unlikely(atomic_read(&amp;amp;ep-&amp;gt;user-&amp;gt;epoll_watches) &amp;gt;=
		     max_user_watches))
		return -ENOSPC;
	if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))
		return -ENOMEM;

	/* Item initialization follow here ... */
	INIT_LIST_HEAD(&amp;amp;epi-&amp;gt;rdllink);
	INIT_LIST_HEAD(&amp;amp;epi-&amp;gt;fllink);
	INIT_LIST_HEAD(&amp;amp;epi-&amp;gt;pwqlist);
	epi-&amp;gt;ep = ep;
	ep_set_ffd(&amp;amp;epi-&amp;gt;ffd, tfile, fd);
	epi-&amp;gt;event = *event;
	epi-&amp;gt;nwait = 0;
	epi-&amp;gt;next = EP_UNACTIVE_PTR;

	/* Initialize the poll table using the queue callback */
	epq.epi = epi;
	init_poll_funcptr(&amp;amp;epq.pt, ep_ptable_queue_proc);

	/*
	 * Attach the item to the poll hooks and get current event bits.
	 * We can safely use the file* here because its usage count has
	 * been increased by the caller of this function. Note that after
	 * this operation completes, the poll callback can start hitting
	 * the new item.
	 */
	revents = tfile-&amp;gt;f_op-&amp;gt;poll(tfile, &amp;amp;epq.pt);

	/*
	 * We have to check if something went wrong during the poll wait queue
	 * install process. Namely an allocation for a wait queue failed due
	 * high memory pressure.
	 */
	error = -ENOMEM;
	if (epi-&amp;gt;nwait &amp;lt; 0) 		goto error_unregister; 	/* Add the current item to the list of active epoll hook for this file */ 	spin_lock(&amp;amp;tfile-&amp;gt;f_lock);
	list_add_tail(&amp;amp;epi-&amp;gt;fllink, &amp;amp;tfile-&amp;gt;f_ep_links);
	spin_unlock(&amp;amp;tfile-&amp;gt;f_lock);

	/*
	 * Add the current item to the RB tree. All RB tree operations are
	 * protected by &amp;quot;mtx&amp;quot;, and ep_insert() is called with &amp;quot;mtx&amp;quot; held.
	 */
	ep_rbtree_insert(ep, epi);

	/* We have to drop the new item inside our item list to keep track of it */
	spin_lock_irqsave(&amp;amp;ep-&amp;gt;lock, flags);

	/* If the file is already &amp;quot;ready&amp;quot; we drop it inside the ready list */
	if ((revents &amp;amp; event-&amp;gt;events) &amp;amp;&amp;amp; !ep_is_linked(&amp;amp;epi-&amp;gt;rdllink)) {
		list_add_tail(&amp;amp;epi-&amp;gt;rdllink, &amp;amp;ep-&amp;gt;rdllist);

		/* Notify waiting tasks that events are available */
		if (waitqueue_active(&amp;amp;ep-&amp;gt;wq))
			wake_up_locked(&amp;amp;ep-&amp;gt;wq);
		if (waitqueue_active(&amp;amp;ep-&amp;gt;poll_wait))
			pwake++;
	}

	spin_unlock_irqrestore(&amp;amp;ep-&amp;gt;lock, flags);

	atomic_inc(&amp;amp;ep-&amp;gt;user-&amp;gt;epoll_watches);

	/* We have to call this outside the lock */
	if (pwake)
		ep_poll_safewake(&amp;amp;ep-&amp;gt;poll_wait);

	return 0;

error_unregister:
	...	/* 清理代码 */
	return error;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里首先使用 &lt;code&gt;kmem_cache_alloc&lt;/code&gt; 分配了一个 &lt;code&gt;epitem *epi&lt;/code&gt; 结构，&lt;code&gt;epi-&amp;gt;ep = ep;&lt;/code&gt;并把ep指针赋值给它的成员，紧接着，又使用&lt;code&gt;epq.epi = epi;&lt;/code&gt;把epi赋值给&lt;code&gt;ep_pqueue epq;&lt;/code&gt;结构成员。这里嵌套了几层结构，ep-&amp;gt;epi-&amp;gt;epq，关系比较复杂，我们只关心核心的东西，分析流程。&lt;/p&gt;
&lt;p&gt;后面init_poll_funcptr(&amp;amp;epq.pt, ep_ptable_queue_proc);函数定义于include/linux/poll.h文件，代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)
{
	pt-&amp;gt;qproc = qproc;
	pt-&amp;gt;key   = ~0UL; /* all events enabled */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅仅是给epq的pt成员设置回调函数，千万注意这里的回调应用，epoll的实现就是依赖于内核和驱动的层层回调，后面将会说到。&lt;/p&gt;
&lt;p&gt;再来看&lt;code&gt;ep_insert&lt;/code&gt;的代码，之后紧接着调用了目标文件驱动的poll回调，把刚才设置好的epq.pt传入驱动之中：&lt;code&gt;tfile-&amp;gt;f_op-&amp;gt;poll(tfile,&amp;amp;epq.pt)&lt;/code&gt;。如果再这里停止跟进，往下进行，发现该函数之后的代码无非是错误判断或者各种结构之间的纠结。唯一一点有用的代码就是这句：&lt;code&gt;wake_up_locked(&amp;amp;ep-&amp;gt;wq)&lt;/code&gt;。其中&lt;code&gt;ep-&amp;gt;wq&lt;/code&gt;正是&lt;code&gt;epoll_wait&lt;/code&gt;函数等待的队列，不过此情况仅仅是在驱动poll函数直接返回数据的情况下。真正触发点应该还在驱动对epq.pt的操作。&lt;/p&gt;
&lt;p&gt;之前的文章写过驱动中对poll的实现，无非调用 &lt;code&gt;poll_wait&lt;/code&gt; 函数，实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
{
	if (p &amp;amp;&amp;amp; wait_address)
	p-&amp;gt;qproc(filp, wait_address, p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对照&lt;code&gt;init_poll_funcptr&lt;/code&gt;的代码，我们可以很清楚的发现，其实最终驱动是回调了&lt;code&gt;init_poll_funcptr&lt;/code&gt;中设置的qproc函数！返回到&lt;code&gt;ep_insert&lt;/code&gt;中，可以看到设置的qproc函数名为 &lt;code&gt;ep_ptable_queue_proc&lt;/code&gt;，所以还是不得不再分析此函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,
				 poll_table *pt)
{
	struct epitem *epi = ep_item_from_epqueue(pt);
	struct eppoll_entry *pwq;

	if (epi-&amp;gt;nwait &amp;gt;= 0 &amp;amp;&amp;amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {
		init_waitqueue_func_entry(&amp;amp;pwq-&amp;gt;wait, ep_poll_callback);
		pwq-&amp;gt;whead = whead;
		pwq-&amp;gt;base = epi;
		add_wait_queue(whead, &amp;amp;pwq-&amp;gt;wait);
		list_add_tail(&amp;amp;pwq-&amp;gt;llink, &amp;amp;epi-&amp;gt;pwqlist);
		epi-&amp;gt;nwait++;
	} else {
		/* We have to signal that an error occurred */
		epi-&amp;gt;nwait = -1;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;乍一看函数代码并不多，不过又创建出一个结构&lt;code&gt;eppoll_entry&lt;/code&gt;，并调用&lt;code&gt;init_waitqueue_func_entry&lt;/code&gt;初始化等待的回调函数。再使用&lt;code&gt;pwq-&amp;gt;base = epi&lt;/code&gt;保存了epi地址，接下来执行正常的&lt;code&gt;add_wait_queue&lt;/code&gt;操作，加入等待队列。期待的结果就是设备数据就绪时，驱动&lt;code&gt;wake_up&lt;/code&gt;等待队列，可以回调加入的函数&lt;code&gt;ep_poll_callback&lt;/code&gt;，要想进一步研究，可以查看相关代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 函数init_waitqueue_func_entry仅仅初始化func回调函数 */
static inline void init_waitqueue_func_entry(wait_queue_t *q,
				wait_queue_func_t func)
{
	q-&amp;gt;flags = 0;
	q-&amp;gt;private = NULL;
	q-&amp;gt;func = func;
}

#define wake_up(x)                      __wake_up(x, TASK_NORMAL, 1, NULL)

void __wake_up(wait_queue_head_t *q, unsigned int mode,
			int nr_exclusive, void *key)
{
	unsigned long flags;

	spin_lock_irqsave(&amp;amp;q-&amp;gt;lock, flags);
	__wake_up_common(q, mode, nr_exclusive, 0, key);
	spin_unlock_irqrestore(&amp;amp;q-&amp;gt;lock, flags);
}

static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,
			int nr_exclusive, int wake_flags, void *key)
{
	wait_queue_t *curr, *next;

	list_for_each_entry_safe(curr, next, &amp;amp;q-&amp;gt;task_list, task_list) {
		unsigned flags = curr-&amp;gt;flags;

		/* 最终到达这里调用刚才设置的回调函数 */
		if (curr-&amp;gt;func(curr, mode, wake_flags, key) &amp;amp;&amp;amp;
				(flags &amp;amp; WQ_FLAG_EXCLUSIVE) &amp;amp;&amp;amp; !--nr_exclusive)
			break;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以知道的是，&lt;code&gt;epoll_wait&lt;/code&gt;处于等待并且设备准备完成，会调用&lt;code&gt;ep_poll_callback&lt;/code&gt;函数，一切的矛头都指向&lt;code&gt;ep_poll_callback&lt;/code&gt;，大致可以猜测，增加就绪队列rdllist元素、唤醒&lt;code&gt;epoll_wait&lt;/code&gt;函数都应在此函数中实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)
{
	int pwake = 0;
	unsigned long flags;
	struct epitem *epi = ep_item_from_wait(wait);
	struct eventpoll *ep = epi-&amp;gt;ep;

	spin_lock_irqsave(&amp;amp;ep-&amp;gt;lock, flags);

	...

	/* If this file is already in the ready list we exit soon */
	if (!ep_is_linked(&amp;amp;epi-&amp;gt;rdllink))
		list_add_tail(&amp;amp;epi-&amp;gt;rdllink, &amp;amp;ep-&amp;gt;rdllist);

	/*
	 * Wake up ( if active ) both the eventpoll wait list and the -&amp;gt;poll()
	 * wait list.
	 */
	if (waitqueue_active(&amp;amp;ep-&amp;gt;wq))
		wake_up_locked(&amp;amp;ep-&amp;gt;wq);
	if (waitqueue_active(&amp;amp;ep-&amp;gt;poll_wait))
		pwake++;

out_unlock:
	spin_unlock_irqrestore(&amp;amp;ep-&amp;gt;lock, flags);

	/* We have to call this outside the lock */
	if (pwake)
		ep_poll_safewake(&amp;amp;ep-&amp;gt;poll_wait);

	return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;粗略看下代码感觉此函数不负众望，首先&lt;code&gt;struct epitem *epi = ep_item_from_wait(wait)&lt;/code&gt;从wait中获取epi结构，并取得ep，&lt;code&gt;list_add_tail(&amp;amp;epi-&amp;gt;rdllink, &amp;amp;ep-&amp;gt;rdllist);&lt;/code&gt;把加入到ep的就绪队列rdllist中，而后&lt;code&gt;wake_up_locked(&amp;amp;ep-&amp;gt;wq)&lt;/code&gt;唤醒&lt;code&gt;epoll_wait&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里还有些细节，如果记得清楚，刚才是把wait变量赋值到结构epi的成员，这里确从wait中取出结构体的地址，这是Linux内核常用手段，依赖于宏container_of，此宏定义于include/linux/kernel.h，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define container_of(ptr, type, member) ({                      \
        const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对c语言来说，结构体并没有太多的秘密，无非是内存的组合，typeof( ((type *)0)-&amp;gt;member ) 在编译期构造一个member成员类型，指针指向ptr，之后减去member在类型type中的偏移即为type结构地址。&lt;/p&gt;
&lt;p&gt;分析到这里，我们可以看到，epoll模型并没有对每一个文件描述符遍历，仅仅当描述符对应设备就绪时，回调epoll，加入就绪队列唤醒epoll_wait，当文件描述符增多时，效率不会同select一样线性下降，由于select会轮询所有设备，可能大多数设备是没有数据的，在文件描述符较少情况下倒是显不出什么，当有成千上万描述符并且大量描述符处于空闲状态时，对效率的损耗是相当惊人的。所以epoll为我们提供了一种更加有效便捷的方式去管理如此多的描述符。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>tun/tap 驱动源码分析</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-tap-tun-driver/</link>
        <pubDate>Mon, 12 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-tap-tun-driver/</guid>
        <description>&lt;p&gt;tun/tap驱动程序是Linux平台虚拟网卡驱动程序，驱动加载后会建立网络接口tun0，与其他网卡驱动不同的是，tun驱动并不会把到达的数据包发送出去，而是会暂时存储于队列之中，用户态进程可以通过read，write读写网络数据包，实质上此驱动是一种把网络数据包直接定向至用户态进程的一种方式。用户态进程充当网络的角色，通过read接受网卡数据包，write发送数据包给网卡。&lt;/p&gt;
&lt;p&gt;此驱动运行时可设置tun模式和tap模式，tun模式能取到IP数据包，无法获得ARP数据，而tap模式取到的是以太包，可以得到链路层以上的一切数据包。&lt;/p&gt;
&lt;p&gt;由于项目需要使用tun驱动，而又不想不求甚解，从而阅读了驱动代码，想对此做一些记录，可以使自己理解的更为透彻，虽然代码并不多，但是涉及内核态编程，倘若追根溯源，恐怕需读完Linux协议栈代码了。&lt;/p&gt;
&lt;p&gt;我阅读的代码取自Linux 2.6.34内核源码，路径 drivers\net\tun.c&lt;/p&gt;
&lt;p&gt;驱动入口点，Linux驱动入口点不同Windows平台，入口函数都是DriverEntry，Linux平台需要通过&lt;code&gt;module_init&lt;/code&gt;宏指定入口点（当然最终宏也会统一把函数转化成&lt;code&gt;init_module&lt;/code&gt;作为入口点），当执行modprobe加载内核模块时由内核调用，&lt;code&gt;module_exit&lt;/code&gt;宏指定清理函数，当执行rmmod时由内核调用。另外，通过 &lt;code&gt;MODULE_*&lt;/code&gt; 一系列宏记录作者，驱动描述，以及协议信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module_init(tun_init);
module_exit(tun_cleanup);
MODULE_DESCRIPTION(DRV_DESCRIPTION);
MODULE_AUTHOR(DRV_COPYRIGHT);
MODULE_LICENSE(&amp;quot;GPL&amp;quot;);
MODULE_ALIAS_MISCDEV(TUN_MINOR);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指明了驱动程序的基本信息，&lt;code&gt;MODULE_DESCRIPTION&lt;/code&gt;声明驱动描述，&lt;code&gt;MODULE_AUTHOR&lt;/code&gt;声明作者，在程序开始已有定义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define DRV_DESCRIPTION	&amp;quot;Universal TUN/TAP device driver&amp;quot;
#define DRV_COPYRIGHT	&amp;quot;(C) 1999-2004 Max Krasnyansky &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TUN_MINOR 位于文件 include/linux/miscdevice.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define TUN_MINOR 200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来看初始化和清理函数的实现，初始化函数所作工作非常简单，主要功能是建立一个设备节点供用户态进程控制
&lt;code&gt;ret = misc_register(&amp;amp;tun_miscdev);&lt;/code&gt;
函数&lt;code&gt;misc_register&lt;/code&gt;注册一个字符设备，所注册信息位于tun_miscdev结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static struct miscdevice tun_miscdev = {
	.minor = TUN_MINOR,
	.name = &amp;quot;tun&amp;quot;,
	.nodename = &amp;quot;net/tun&amp;quot;,
	.fops = &amp;amp;tun_fops,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用过后会在/dev下以 nodename 为名创建节点，即/dev/net/tun，用户进程可通过open函数打开并操作驱动，操作驱动函数由 tun_fops 指定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const struct file_operations tun_fops = {
	.owner	= THIS_MODULE,
	.llseek = no_llseek,
	.read  = do_sync_read,
	.aio_read  = tun_chr_aio_read,
	.write = do_sync_write,
	.aio_write = tun_chr_aio_write,
	.poll	= tun_chr_poll,
	.unlocked_ioctl	= tun_chr_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl = tun_chr_compat_ioctl,
#endif
	.open	= tun_chr_open,
	.release = tun_chr_close,
	.fasync = tun_chr_fasync
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里操作都是字符设备操作，用户open设备节点/dev/net/tun时内核调用&lt;code&gt;tun_chr_open&lt;/code&gt;回调，这里函数都与用户态操作相对应，用户对设备调用read，write时最终会回调至此，这也是字符设备驱动编程规范。用户态核心操作都在这几个函数当中了。&lt;/p&gt;
&lt;p&gt;现逐条分析每个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.llseek = no_llseek&lt;/code&gt; : &lt;code&gt;no_llseek&lt;/code&gt;为内核函数，实现也十分简单，直接返回-ESPIPE，就是说用户态对设备文件调用lseek就会出Illegal seek错。
字符设备，块设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.read = do_sync_read&lt;/code&gt; :
&lt;code&gt;do_sync_read&lt;/code&gt; 也是内核函数，直接调用aio_read异步读写函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.aio_read = tun_chr_aio_read&lt;/code&gt; :
&lt;code&gt;tun_chr_aio_read&lt;/code&gt; -&amp;gt; &lt;code&gt;tun_do_read&lt;/code&gt; -&amp;gt; &lt;code&gt;skb_dequeue&lt;/code&gt; 以非阻塞方式从接收队列 &lt;code&gt;tun&lt;/code&gt;-&amp;gt;&lt;code&gt;socket.sk&lt;/code&gt;-&amp;gt;&lt;code&gt;sk_receive_queue&lt;/code&gt; 取出一个网络包返给用户态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.write = do_sync_write&lt;/code&gt; :
同&lt;code&gt;aio_read&lt;/code&gt;，调用&lt;code&gt;aio_write&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.aio_write = tun_chr_aio_write&lt;/code&gt; :
&lt;code&gt;tun_chr_aio_write&lt;/code&gt; -&amp;gt; &lt;code&gt;tun_get_user&lt;/code&gt; -&amp;gt; &lt;code&gt;netif_rx_ni&lt;/code&gt; ，netif_rx_ni函数为内核函数，最终调用netif_rx返包给TCP/IP协议栈，Linux系统网络数据包都是以sk_buff结构存在，这里函数大部分都是构造此结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.poll = tun_chr_poll :
tun_chr_poll 调用 poll_wait 实现poll功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.unlocked_ioctl = tun_chr_ioctl :
tun_chr_ioctl -&amp;gt; __tun_chr_ioctl 就是垃圾桶函数ioctl的实现了，所有对驱动程序的操控基本都实现于此函数。函数处理各种不同命令，使用switch-case处理不同命令号，设置硬件地址获取信息等等，关键部分在命令TUNSETIFF，处理在switch之前，这个命令设置基本信息并启动驱动程序的网卡部分。TUNSETIFF 命令最终实现于 tun_set_iff 函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.open = tun_chr_open :
tun_chr_open 当用户调用，此函数仅仅分配自定义结构tun_file，存至文件节点私有数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.release = tun_chr_close :
tun_chr_close 与 open 操作相反，释放结构体，以及结构体之中的子结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.fasync = tun_chr_fasync&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是tun驱动中字符驱动部分，其中省略了细节，如等待队列等内容，跟内核机制有关，我想再另一篇文章中单独总结更好。&lt;/p&gt;
&lt;p&gt;网卡驱动部分&lt;/p&gt;
&lt;p&gt;初始化工作在函数 &lt;code&gt;tun_set_iff&lt;/code&gt; 中
&lt;code&gt;alloc_netdev&lt;/code&gt; 分配网络设备 -&amp;gt; &lt;code&gt;tun_net_init&lt;/code&gt; 初始化网络设备 -&amp;gt; &lt;code&gt;register_netdevice&lt;/code&gt; 注册网络设备
其中自定义函数 &lt;code&gt;tun_net_init&lt;/code&gt; 关键部分如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (tun-&amp;gt;flags &amp;amp; TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev-&amp;gt;netdev_ops = &amp;amp;tun_netdev_ops;

		/* ... */
	case TUN_TAP_DEV:
		dev-&amp;gt;netdev_ops = &amp;amp;tap_netdev_ops;
		/* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序查看设置模式，若是tun模式，设置回调函数为 &lt;code&gt;tun_netdev_ops&lt;/code&gt;， 若是tap模式，设置回调函数为 &lt;code&gt;tap_netdev_ops&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;先来分析 &lt;code&gt;tun_netdev_ops&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const struct net_device_ops tun_netdev_ops = {
	.ndo_uninit		= tun_net_uninit,
	.ndo_open		= tun_net_open,
	.ndo_stop		= tun_net_close,
	.ndo_start_xmit		= tun_net_xmit,
	.ndo_change_mtu		= tun_net_change_mtu,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同字符设备驱动的范式，网络驱动也是设置一系列回调函数，当有数据传输时调用相应回调。&lt;/p&gt;
&lt;p&gt;.ndo_open = tun_net_open
open 函数调用 netif_start_queue(dev); 通知上层开始接受数据包&lt;/p&gt;
&lt;p&gt;.ndo_stop = tun_net_close
close 函数调用 netif_stop_queue(dev); 通知上层停止接受数据包&lt;/p&gt;
&lt;p&gt;.ndo_start_xmit = tun_net_xmit
当有数据包到达时调用 tun_net_xmit 函数，通知网卡发送数据包，函数处理数据包时调用 skb_queue_tail 把数据包压入接收队列 tun-&amp;gt;socket.sk-&amp;gt;sk_receive_queue&lt;/p&gt;
&lt;p&gt;.ndo_change_mtu = tun_net_change_mtu
改变网卡mtu，控制数据帧大小。&lt;/p&gt;
&lt;p&gt;分析 tap 模式下操作回调 &lt;code&gt;tap_netdev_ops&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const struct net_device_ops tap_netdev_ops = {
	.ndo_uninit		= tun_net_uninit,
	.ndo_open		= tun_net_open,
	.ndo_stop		= tun_net_close,
	.ndo_start_xmit		= tun_net_xmit,
	.ndo_change_mtu		= tun_net_change_mtu,
	.ndo_set_multicast_list	= tun_net_mclist,
	.ndo_set_mac_address	= eth_mac_addr,
	.ndo_validate_addr	= eth_validate_addr,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中大部分函数都同 tun 模式相同，因为这些函数都无需关心数据包是否含有以太头。而&lt;code&gt;tun_net_mclist&lt;/code&gt;仅实现为空函数，&lt;code&gt;eth_mac_addr&lt;/code&gt;和&lt;code&gt;eth_validate_addr&lt;/code&gt;操作函数直接回调系统默认函数，此模式下并无新回调函数出现。&lt;/p&gt;
&lt;p&gt;虽然Linux系统是用纯C语言写的，但是其中到处充斥着面向对象的思想，分析驱动程序首先理清结构，以及结构对应的方法，对字符设备驱动对象，file存储数据，&lt;code&gt;file_operations&lt;/code&gt;回调是其方法；网络设备对象也是如此。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux字符设备驱动开发</title>
        <link>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-character-driver/</link>
        <pubDate>Sun, 11 May 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/linux%E5%86%85%E6%A0%B8/linux-character-driver/</guid>
        <description>&lt;h1 id=&#34;什么是字符驱动&#34;&gt;什么是字符驱动？&lt;/h1&gt;
&lt;p&gt;所谓驱动程序，本质上讲是硬件接口，因为操作系统不可能实现每种硬件的接口，所以只对厂商提供接口，只要厂商实现这些接口，就可被操作系统调用，Linux系统驱动程序分为字符设备驱动和块设备驱动，所谓字符设备驱动就是例如键盘驱动，只能顺次读取数据，块设备驱动入硬盘等，可以随机分块读取。而有些程序虽然符合驱动程序规范，但却不真正驱动硬件，而是对操作系统功能的扩充，也称作内核模块。所以驱动程序和内核模块本质上讲属于同一种类别。&lt;/p&gt;
&lt;h1 id=&#34;如何实现&#34;&gt;如何实现？&lt;/h1&gt;
&lt;p&gt;操作系统对字符设备驱动提供 file_operations 结构，该结构成员大部分都是回调函数（以下代码摘自Linux 2.6.34内核源码）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_operations&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;owner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llseek&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aio_read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kiocb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iovec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aio_write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kiocb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iovec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readdir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;filldir_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;poll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;poll_table_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ioctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlocked_ioctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compat_ioctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vm_area_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;fl_owner_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fsync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dentry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datasync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aio_fsync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kiocb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datasync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fasync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sendpage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_unmapped_area&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;check_flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splice_write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splice_read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setlease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作为驱动程序，只需要实现部分回调函数，注册该结构体，用户态进程便可通过系统调用open，read等调用相应回调函数指针。&lt;/p&gt;
&lt;p&gt;首先，系统提供若干宏声明驱动程序的属性，如，入口，作者，描述信息等等。&lt;/p&gt;
&lt;p&gt;初始化程序原型为 &lt;code&gt;static int __init initialization(void);&lt;/code&gt;若初始化成功则返回0，否则返回错误码。
清理函数原型为&lt;code&gt;static void __exit cleanup(void);&lt;/code&gt;其中&lt;code&gt;__init __exit&lt;/code&gt;是指定代码段属性的宏，当然也可不指定此属性。&lt;/p&gt;
&lt;p&gt;另外宏MODULE_AUTHOR指明作者等等&lt;/p&gt;
&lt;p&gt;实现该函数后便可通过宏指明入口点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最简单的驱动程序就是仅仅实现这两个函数，文件simple.c如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;linux/init.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__init&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; init simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__exit&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; cleanup simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;module_exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_AUTHOR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;alloc cppbreak@gmail.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_DESCRIPTION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;A simple linux kernel module&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_VERSION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;V0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Dual BSD/GPL&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;驱动的编译需要写Makefile文件，内容如下
&lt;code&gt;obj-m := simple.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译时需指定Linux内核源码所处位置：
&lt;code&gt;make -C /usr/src/linux M=$PWD modules&lt;/code&gt;
其中/usr/src/linux为当前内核源码目录，&lt;code&gt;$PWD&lt;/code&gt;为驱动程序所处目录，&lt;code&gt;PWD&lt;/code&gt;为当前目录。&lt;/p&gt;
&lt;p&gt;执行成功后，会生成&lt;code&gt;simple.ko&lt;/code&gt;文件，此文件即为驱动程序。&lt;/p&gt;
&lt;p&gt;加载驱动程序可执行 insmod simple.ko 卸载驱动执行 rmmod simple
命令 lsmod 可以查看目前系统加载的驱动程序，modinfo simple.ko 查看程序的基本信息，输出即为程序声明信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	filename:       simple.ko
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	license:        Dual BSD/GPL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	version:        V0.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	description:    A simple linux kernel module
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	author:         alloc cppbreak@gmail.com
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	srcversion:     95E3CE3AB899900656E9CAD
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	depends:        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	vermagic:       2.6.33.3-85.fc13.x86_64 SMP mod_unload
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在程序中调用了两次printk，为内核输出函数，这里的输出不会显示到控制台，只会输出到内核，可以通过读取&lt;code&gt;/proc/kmsg&lt;/code&gt;文件查看信息，或者调用dmesg命令查看，此为内核跟踪错误的重要手段。KERN_INFO宏只是一个数字字符串，含义为日志级别，可以通过&lt;code&gt;echo num &amp;gt; /proc/sys/kernel/printk&lt;/code&gt; 来控制输出信息的级别。&lt;/p&gt;
&lt;p&gt;当然，只有此两个函数只能正常加载卸载驱动程序，并没有任何意义，下面通过注册回调函数来实现字符设备的功能，只举一个简单的例子，实现&lt;code&gt;open&lt;/code&gt;,&lt;code&gt;read&lt;/code&gt;,&lt;code&gt;close&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;根据file_operations结构成员的原型，这里我们需要实现如下回调：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;open和close函数为了简单起见不做任何处理，只是简单的输出kernel信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pnode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;open simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pnode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;close simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于read函数，因为需要把内核态的数据返回到用户态，而二者是具有堆栈隔离的，需要借助几个函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;copy_from_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;copy_to_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;copy_from_user 是把用户态数据from拷贝至内核态内存to中，coyp_to_user与之相反，返回结果为不能被复制的字节数，如果成功，则返回0，对于内核编程，错误处理非常重要，因为一微不足道的错误就可能导致系统崩溃，所以对于函数调用，要异常小心，需要区分每一个传入参数，以及判断每一个函数返回值，read函数可以实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;loff_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ppos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;copy_to_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;test data&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EFAULT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到这里回调函数都已实现，但用户态进程如何才能访问驱动呢？这还得从初始化内核时说起，要访问一个设备，需要进行三个基本操作：
第一，对于一个设备驱动，需要分配一个设备号来唯一标识；
第二，需要注册回调函数至文件系统，以便上层回调；
第三，需要创建一个设备节点，挂接至/dev/下，这样用户层就可类似打开文件驱动方式打开设备驱动了。&lt;/p&gt;
&lt;p&gt;由以上三点，重写设备初始化函数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__init&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;cm&#34;&gt;/* 分配设备号 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;alloc_chrdev_region&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;devno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;simple&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;cm&#34;&gt;/* 注册回调函数 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;cdev_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cdev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;simple_op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cdev_add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cdev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;devno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;cm&#34;&gt;/* 创建设备节点 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;simple_class&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;class_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;THIS_MODULE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;simple&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;device_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;simple_class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;devno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;simple&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; init simple&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然，在exit函数中，需要对分配的资源逐一释放，整理之后代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/init.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/module.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/fs.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/types.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/cdev.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/mm.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/sched.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;asm/io.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;asm/uaccess.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;asm/system.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	#include&amp;lt;linux/device.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dev_t devno;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	struct class * simple_class;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static struct cdev cdev;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ssize_t simple_read(struct file * pfile,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		char __user * buf, size_t size, loff_t * ppos)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		if (copy_to_user(buf, &amp;#34;test data\n&amp;#34;, 10))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			return -EFAULT;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			return 10;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int simple_open(struct inode * pnode, struct file * pfile)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34;open simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int simple_release(struct inode * pnode, struct file * pfile)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34;close simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static struct file_operations simple_op = 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.owner = THIS_MODULE,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.read = simple_read,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.open = simple_open,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		.release = simple_release,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static int __init initialization(void)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int result;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		result = alloc_chrdev_region(&amp;amp;devno, 0, 1, &amp;#34;simple&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		if (result &amp;lt; 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			return result;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cdev_init(&amp;amp;cdev, &amp;amp;simple_op);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		result = cdev_add(&amp;amp;cdev, devno, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		simple_class = class_create(THIS_MODULE, &amp;#34;simple&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		device_create(simple_class, NULL, devno, NULL, &amp;#34;simple&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34; init simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return result;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static void __exit cleanup(void)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		device_destroy(simple_class, devno);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		class_destroy(simple_class);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cdev_del(&amp;amp;cdev);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		unregister_chrdev_region(devno, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		printk(KERN_INFO &amp;#34; cleanup simple\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	module_init(initialization);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	module_exit(cleanup);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_AUTHOR(&amp;#34;alloc cppbreak@gmail.com&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_DESCRIPTION(&amp;#34;A simple linux kernel module&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_VERSION(&amp;#34;V0.1&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	MODULE_LICENSE(&amp;#34;Dual BSD/GPL&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译加载驱动后，&lt;code&gt;ls /dev/&lt;/code&gt; 可查看到simple节点，调用 &lt;code&gt;cat /dev/simple&lt;/code&gt; 命令，发现会不停输出 &lt;code&gt;test data&lt;/code&gt;，原因是cat命令会输出文件所有内容，但此时的驱动只要调用read就会返回数据，不会到达文件结尾，会无休止输出，毕竟这是一个很简单的驱动，去除了影响理解框架的逻辑信息。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言练习-AT&amp;T汇编win32窗口</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-bios/</link>
        <pubDate>Mon, 28 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-bios/</guid>
        <description>&lt;h1 id=&#34;att-bios模式&#34;&gt;AT&amp;amp;T BIOS模式&lt;/h1&gt;
&lt;p&gt;BIOS(Basic Input/Output System) 是基本输入输出系统，它是硬件之上的一层。为计算机提供了最基本的控制硬件方式，BIOS存储了基本的硬件信息，例如磁盘大小等，并负责引导系统。&lt;/p&gt;
&lt;p&gt;系统加电启动时，BIOS首先获得控制权，由它首先进行硬件检测，这个过程称为加点自检(POST)，通常POST检测cpu、内存、磁盘、主板等等，一旦发现问题，便会提示信息或者鸣笛警告。&lt;/p&gt;
&lt;p&gt;BIOS另外一个职责便是引导系统，BIOS加电自检完毕之后，读取CMOS中的设备引导信息，从引导设备中读取0柱面0磁头1扇区的512字节，若 512字节以55 AA（2字节）结束，则认为是引导扇区（Boot Sector），BIOS便会装载此段到地址0x7C00，执行此程序，以后的引导工作边交由引导扇区处理，BIOS便退居幕后，为系统提供基本的服务。 在汇编中通过int指令产生中断，可请求BIOS服务，这篇先来介绍BIOS中断请求，不过需注意的是BIOS中断请求必须在16位实模式，或者虚拟 8086模式下才可运行，进入保护模式后，中断的处理方式发生变化。&lt;/p&gt;
&lt;p&gt;BIOS中断请求通过指令int Num，Num是中断号，不同的中断号负责不同的功能，比如0×10控制视频，0×16键盘中断等等。BIOS中断非常之多，不可能全部记忆，好在调用方式相同，另有相关手册参考，我觅得一份，可以在 这里 下载，或者浏览 网页版本，或者在Railf Brown 的主页 下载。&lt;/p&gt;
&lt;p&gt;这里以0×10号中断为例说明控制显示视频，先来看手册中0×10号中断部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INT 10 - VIDEO; CPU-generated (80286+)
INT 10 ---- - CPU-generated (80286+) - COPROCESSOR ERROR
INT 10h---- - LIRVGA19 - CHAR HEIGHT HOOK
INT 10 00-- - VIDEO - SET VIDEO MODE
INT 10 0070 - VIDEO - Everex Micro Enhancer EGA/Viewpoint VGA - EXTENDED MODE SET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到 INT 10 00 是设置显示模式，查看其输入参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 00h
	AL = desired video mode (see #00010)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到AH为功能号00h，AL为需要设置的模式，再通过手册查找模式号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Table 00010

Values for video mode:

     text/ text pixel	pixel	colors disply scrn  system
     grph resol	 box  resolution       pages  addr
 00h = T  40x25	 8x8   320x200	16gray	  8   B800 CGA,PCjr,Tandy
     = T  40x25	 8x14  320x350	16gray	  8   B800 EGA
     = T  40x25	 8x16  320x400	 16	  8   B800 MCGA
     = T  40x25	 9x16  360x400	 16	  8   B800 VGA
 01h = T  40x25	 8x8   320x200	 16	  8   B800 CGA,PCjr,Tandy
     = T  40x25	 8x14  320x350	 16	  8   B800 EGA
     = T  40x25	 8x16  320x400	 16	  8   B800 MCGA

     = T  40x25	 9x16  360x400	 16	  8   B800 VGA
 02h = T  80x25	 8x8   640x200	16gray	  4   B800 CGA,PCjr,Tandy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到 00h 为 40×25 字符，到这里大致清楚了功能号00（设置显示模式的使用），AH存放功能号00，AL存放字符显示模式，便可调用int 10h来调用BIOS设置显示模式。&lt;/p&gt;
&lt;p&gt;设置显示模式后来查看显示字符串的调用，0×10号中断的0×13功能号，还是来看手册中的描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 13h
	AL = write mode
	   bit 0: update cursor after writing
	   bit 1: string contains alternating characters and attributes
	   bits 2-7: reserved (0)
	BH = page number
	BL = attribute if string contains only characters
	CX = number of characters in string
	DH,DL = row,column at which to start writing
	ES:BP -&amp;gt; string to write
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里说一下BL，字体的属性，使用BIOS手册索引查找Attribute bits，得到屏幕颜色信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Screen colors.

 Normal colors       Bright colors          Attribute bits
 0 00 Black          8 08 Dark grey         7 normal    Foreground blink
 1 01 Blue           9 09 Light blue        7 alternate Background bright
 2 02 Green         10 0A Light green       6-4         Background color
 3 03 Cyan          11 0B Light cyan        3 normal    Foreground bright
 4 04 Red           12 0C Light red         3 alternate Alternate char. set

 5 05 Magenta       13 0D Light magenta     2-0         Foreground color
 6 06 Brown         14 0E Yellow
 7 07 White (grey)  15 0F Bright (white)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BL的0-2位表示前景色，3位表示高亮，4-6位表示背景色，7位表示前景闪烁。如果使用蓝色背景，红色前景，BL值应为 00011100 即 0x1c。&lt;/p&gt;
&lt;p&gt;接下来我们写一个BIOS调用输出字符串的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.code16
.text
	movw %cs, %ax
	movw %ax, %ds
	movw %ax, %es
	movw %ax, %ss

	movb $0, %ah
	movb $0, %al
	int $0x10

	movb $0x13, %ah
	movb $0, %al
	movb $0, %bh
	movb $0x1c, %bl
	movw $13, %cx
	movb $2, %dh
	movb $1, %dl
	movw $outstring, %bp
	int $0x10
	jmp .
outstring:
	.asciz &amp;quot;BIOS 10H 13H\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序开始使用.code16来指定16位代码段，第一个int $0×10设置字符显示模式为40×25，接着调用0×13号中断输出字符串，这里的参数设置可以参考手册，程序最后调用jmp . 跳转到当前位置，即形成一个死循环。最终结果便是显示蓝底红字的”BIOS 10H 13H”字串，同时单个cpu跑满。&lt;/p&gt;
&lt;p&gt;因为这里使用了 16位汇编，所以编译时也需要做相应改变，代码编译成16位实模式代码。因为BIOS调用只能处于实模式，所以在windows和linux上都无法使 用，好在windows兼容dos方式的虚拟8086模式，可以运行16位实模式程序，类似一个DOS的虚拟机，现在我们把代码编译成.com二进制文 件，由于.com是需要加载到0×100地址，所以我们仿照AT&amp;amp;T创建窗口的程序，写一个简单的ld链接脚本，指定加载地址为0×100：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SECTIONS
{
. = 0x0100;
.text : {*(.text)}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
as bios.s -o bios.o
ld bios.o -Tbios.lds
objcopy.exe -R .pdr -R .comment -R .note -S -O binary a.exe bios.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先用as编译汇编代码到目标文件，接着使用ld进行连接，指定脚本名bios.lds，连接之后称为a.exe，是windows下 的PE可执行格式，还需要使用objcopy命令去掉无用段信息成为二进制格式bios.com，如此，执行bios.com便可看到效果。如果用二进制 工具打开bios.com可以看到，文件中的二进制几乎与我们写的程序是一一对应的，完全可以在生成目标文件之后，直接使用 objcopy.exe -O binary bios.o bios.com 命令把目标文件拷成二进制文件，程序仍然可以执行，但是因为没有指定 0×0100起始地址，最终movw $outstring, %bp这里无法定位字符串，致使输出乱码，objcopy命令本身也可指定起始地址，只不过一直没有试验成功，不知应如何设置，这里暂且使用前者，虽然比 较繁琐，但毕竟能用。&lt;/p&gt;
&lt;p&gt;在本篇开始已经提到，BIOS加电自检以后会读取启动磁盘，如果发现第一扇区512字节以，55 AA结尾，则认为是引导区，会把这512字节载入到0x7c00地址处执行，根据这个说明，我们很容易做一个简单的引导区例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.code16
.text
	movw %cs, %ax
	movw %ax, %ds
	movw %ax, %es
	movw %ax, %ss

	movb $0, %ah
	movb $0, %al
	int $0x10

	movb $0x13, %ah
	movb $0, %al
	movb $0, %bh
	movb $0x1c, %bl
	movw $13, %cx
	movb $2, %dh
	movb $1, %dl
	movw $outstring, %bp
	int $0x10
	jmp .
outstring:
	.asciz &amp;quot;BIOS 10H 13H\n&amp;quot;

.org 510, 0
	.short 0xAA55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实这段代码跟虚拟8086显示字符的代码基本相同，只是末尾加入了.org宏，指示汇编器直接到510字节开始汇编，中间空出的字符 补0，最后以0xAA55结尾，因为内存中是大端方式存储数据。接下来需要修改的地方是连接脚本的0×0100，因为这里的程序需要加载至0x7c00， 所以修改这个地址，最后objcopy命令 bios.com 换成 bios.img，后缀只是为了让虚拟机识别。虚拟机会把img识别当软盘载入，之后的事情可以预料到了，BIOS会认为我们的这512字节文件是引导 区，并执行。&lt;/p&gt;
&lt;p&gt;使用二进制工具打开bios.img，检验一下，文件刚好512字节，并且以55 AA结尾。说明我们编译过程是没有问题的，接着使用virtual box或者VMware等虚拟机，配置软盘为bios.img，并且设置软盘为第一启动介质。接着开机，便可看到蓝底红字的BIOS 10H 13H！而且我们这里的代码完全独立于操作系统，是在裸机上执行的。&lt;/p&gt;
&lt;p&gt;这里的引导区可作为操作系统的前导，用于引导操作系统，Linux内核中也有一份类似代码，不过由于Linux使用了lilo或者grub这些专业的启动管理程序，内核引导代码便早已废弃。&lt;/p&gt;
&lt;h1 id=&#34;bios视频映射内存&#34;&gt;BIOS视频映射内存&lt;/h1&gt;
&lt;p&gt;之前说过BIOS的视频控制，仅仅说明的是字符显示，其实显卡可以设置两种模式，一种是图形模式，一种是字符模式，在BIOS中断10h ah=0时可以设置模式，在BIOS手册 video mode列表中，第二列有T和G字符，指明此种模式的类别，比如13h便是图形模式，屏幕大小为320×200，另外注意一个属性addr，这里是 A000，也就是说视频是映射至内存A000处，此地址是以后操作映射内存的基础：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Values for video mode:

     text/ text pixel	pixel	colors disply scrn  system
     grph resol	 box  resolution       pages  addr
 13h = G  40x25	 8x8   320x200	256/256K  .   A000 VGA,MCGA,ATI VIP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我便以此为例进行说明，再设置了显示模式以后，便要看如何绘图，绘图的操作当然也是通过BIOS调用，其中int 10h的0ch功能便是在屏幕上绘制一个像素点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Category: V - video

Inp.:
	AH = 0Ch
	BH = page number
	AL = pixel color
	    if bit 7 set, value is XOR&#39;ed onto screen except in 256-color modes
	CX = column
	DX = row
Return: nothing
Desc:	set a single pixel on the display in graphics modes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，有了绘制像素的功能，便可画线，之后一切的操作以此为基础实现。如果有兴趣可以试试此功能，在这里我并不使用这个调用，因为每次 调用BIOS都需要做很多操作，绘制一个图形需要非常多的像素，其速度可想而知。所以这里使用另外一种方式，就是内存映射，视频卡映射至内存，这样绘制屏 幕的像素可以像操作二维数组一般。&lt;/p&gt;
&lt;p&gt;在开始之前，先来看两条指令，in，out（输入输出指令），MASM语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;in al/ax/eax, port
out port, al/ax/eax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来看port，此操作数是硬件映射到cpu的端口，比如视频调色板port为3c8h，扬声器port为61h，当然这些端口值也可通过BIOS手册查找。&lt;/p&gt;
&lt;p&gt;先 来看颜色选择，13h的颜色并不用一个整数表示，而是使用调色板的概念，所谓调色板，可以理解为一个大小256的数组，数组每个元素都是一种颜色，每个颜 色由RGB三个字节组成，可提供256^3种颜色，但由于调色板的限制，每次只能显示256种颜色，调色板的索引0为背景色。视频调色板位于端口 3c8h。&lt;/p&gt;
&lt;p&gt;再看颜色，把颜色设置给对应的调色板，先选择调色板索引，之后再通过颜色选择端口 （3c9h）设置RGB值。&lt;/p&gt;
&lt;p&gt;另外视频的内存映射偏移为 0A000h，320 * 200大小的屏幕每个像素占1个字节，表示调色板的索引值，通过直接往这个地址范围写入调色板索引，便可决定对应像素的颜色，以达到绘制图形的效果。接下来我们通过例子来操作内存映射：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.model tiny
.code
org 7c00h

Video_Pallete_Port equ 3c8h
Color_Select_Port equ 3c9h
Video_Base equ 0A000h

Video_Width equ 320

main proc
	mov ax, Video_Base
	mov es, ax
	call SetVideoMode
	call SetBackgroudColor
	call DrawSquare
die:
	jmp die
main endp

SetVideoMode proc
	mov al, 13h
	mov ah, 0
	int 10h
	ret
SetVideoMode endp

; al : the video mode
SetBackgroudColor proc
	mov dx, Video_Pallete_Port
	mov al, 0
	out dx, al

	mov dx, Color_Select_Port
	mov al, 255
	out dx, al
	mov al, 0
	out dx, al
	out dx, al
	ret
SetBackgroudColor endp

DrawSquare proc
	mov dx, Video_Pallete_Port
	mov al, 1
	out dx, al

	mov dx, Color_Select_Port
	mov al, 0
	out dx, al
	out dx, al
	mov al, 255
	out dx, al

	;; Set The Squre Row Start
	mov bx, 30
	;; Set The Squre Row Num
	mov cx, 100
row:
	mov ax, Video_Width
	mul bx
	;; 10 Set Squre Col Start
	add ax, 10
	mov di, ax

	push cx
	;; Set The Squre Col Num
	mov cx, 100
col:
	mov byte ptr es:[di], 1
	inc di
	loop col
	pop cx
	inc bx
	loop row

	ret
DrawSquare endp

fill db (510 - (fill - main)) dup (0)
db 55h
db 0AAh

end main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里代码比较长，首先来看最开始org 7c00h， 指明该程序需要加载至7c00处，即引导程序加载位置。main函数里设置es段寄存器的地址为Video_Base，以便在此段中直接操纵内存，接下来调用了三个函数；&lt;/p&gt;
&lt;p&gt;函数SetVideoMode比较简单，调用int 10h设置显示模式为13h；&lt;/p&gt;
&lt;p&gt;函数SetBackgroudColor包含了调色板的操作，因为调色板索引0为背景，第一个out选择0调色板，接下来调用了三次out dx, al，dx为颜色选择端口，al为色彩值，以R、G、B的方式分别传出3个颜色字节进行设置，设置之后调色板0便为红色。&lt;/p&gt;
&lt;p&gt;函 数DrawSquare看似复杂，其实大部分都与BIOS调用无关，仅仅是计算坐标点，两个循环绘制了一个矩形，关键点有两个，第一个就是颜色设置，这次 设置的是调色板索引1，这里与SetBackgroudColor基本相同，再一个便是设置颜色，关键语句为 mov byte ptr es:[di], 1，如果记得，在main函数中把es设置为Video的机制，di是基址上的偏移，对应屏幕上的像素，这里屏幕像素是320*200，就是当dl为 320时是第二行第一列的像素，这里与二维数组的意义相同，第二个操作数1为刚才设置的调色板索引，综合来看，这句话的含义便是把内存位置（对应显存）设 置为调色板索引1的颜色。&lt;/p&gt;
&lt;p&gt;编译连接程序为 video.img，设置为虚拟机的软盘，并设置成第一启动介质，打开虚拟机便可看到红色背景上100*100的蓝色矩形。&lt;/p&gt;
&lt;h1 id=&#34;bios键盘中断&#34;&gt;BIOS键盘中断&lt;/h1&gt;
&lt;p&gt;这里来看一下BIOS中断的键盘控制部分，当用户按下键盘，键盘的扫描码从输入端口进入键盘缓冲，在系统中可以调用BIOS int 16h 来获取缓冲区中的扫描码和ASCII码。&lt;/p&gt;
&lt;p&gt;关于键盘操作的BIOS中断有很多种，接下来介绍一些常用的调用：&lt;/p&gt;
&lt;p&gt;设置击键重复率 03h ，当一直按着某个键，在按键开始重复之前有250~1000ms的延时。击键重复速率取值可以是1Fh（最慢）到0（最快）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 03h
	AL = subfunction
	    00h set default delay and rate (PCjr and some PS/2)
	    01h increase delay before repeat (PCjr)
	    02h decrease repeat rate by factor of 2 (PCjr)
	    03h increase delay and decrease repeat rate (PCjr)
	    04h turn off typematic repeat (PCjr and some PS/2)
	    05h set repeat rate and delay (AT,PS)
		BH = delay value (00h = 250ms to 03h = 1000ms)
		BL = repeat rate (00h=30/sec to 0Ch=10/sec [def] to 1Fh=2/sec)

    06h get current typematic rate and delay (newer PS/2s)
		Return: BL = repeat rate (above)
			BH = delay (above)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，当ah = 03h, al = 05h时设置速率，bh为重复率。&lt;/p&gt;
&lt;p&gt;等待按键，这是一个非常有用的功能，当键盘缓冲有按键时，删除按键并返回按键，没有时等待用户按键，以阻塞的方式运行，而且其参数非常简单，只需设置ah，返回ah为扫描码，al为ASCII码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 10h
Return: AH = BIOS scan code
	AL = ASCII character
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，还有可能有时不想等待，指向查看是否按键，没有按键便返回处理其他事情，这时功能11h便非常有用了，这个功能以非阻塞的方式返回按键，如果没有按键则ZF被设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AH = 11h
Return: ZF set if no keystroke available
	ZF clear if keystroke available
	    AH = BIOS scan code
	    AL = ASCII character
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BIOS的16h功能全部用来处理键盘，另外还有检测按键状态等等，可查阅手册获知细节。&lt;/p&gt;
&lt;p&gt;这里改善上篇写的绘图程序，最终不以死循环结束程序，而是等待按键，根据按键做一些操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.model tiny
.code
org 7c00h

Video_Pallete_Port equ 3c8h
Color_Select_Port equ 3c9h
Video_Base equ 0A000h

Video_Width equ 320

main proc
	mov ax, Video_Base
	mov es, ax
	call SetVideoMode
	call SetBackgroudColor

die:
	mov ah, 10h
	int 16h
	cmp al, &#39;s&#39;
	jz shutdown
	cmp al, &#39;d&#39;
	jnz die
	call DrawSquare
	jmp die
shutdown:
	mov ax, 5301h
	xor bx, bx
	int 15h

	mov ax, 530eh
	mov cx, 0102h
	int 15h

	mov ax, 5307h
	mov bx, 1h
	mov cx, 03h
	int 15h

main endp

SetVideoMode proc
	mov al, 13h
	mov ah, 0
	int 10h
	ret
SetVideoMode endp

SetBackgroudColor proc
	mov dx, Video_Pallete_Port
	mov al, 0
	out dx, al

	mov dx, Color_Select_Port
	mov al, 255
	out dx, al
	mov al, 0
	out dx, al
	out dx, al
	ret
SetBackgroudColor endp

DrawSquare proc
	mov dx, Video_Pallete_Port
	mov al, 1
	out dx, al

	mov dx, Color_Select_Port
	mov al, 0
	out dx, al
	out dx, al
	mov al, 255
	out dx, al

	mov bx, 30
	mov cx, 100
row:
	mov ax, Video_Width
	mul bx
	add ax, 10
	mov di, ax

	push cx
	mov cx, 100
col:
	mov byte ptr es:[di], 1
	inc di
	loop col
	pop cx
	inc bx
	loop row

	ret
DrawSquare endp

fill db (510 - (fill - main)) dup (0)
db 55h
db 0AAh

end main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里修改的东西并不多，在程序启动时不进行绘图，而是调用int 16h来获取按键，检测按键为d时进行绘图，并且按键为s时调用了三组int 15h中断，15h调用掌管系统状态，当ax为5307h时可以关闭设备电源等，这三组int 15h功能是关闭计算机，其中细节可以通过手册获取。其实中断调用除了图形映射内存这种有一定背景的功能外，其他功能相对独立，使用时可能不知道改使用哪 个中断，一旦得知所使用的中断号，通过手册很容易掌握中断。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Inp.:
	AX = 5307h
	BX = device ID (see #00474)
	CX = system state ID (see #00475)
Return: CF clear if successful
	CF set on error
	    AH = error code (01h,03h,09h,0Ah,0Bh,60h) (see #00473)

Table 00474
Values for APM device IDs:
 0000h	system BIOS
 0001h	all devices for which the system BIOS manages power
 01xxh	display (01FFh for all attached display devices)

Table 00475
Values for system state ID:
 0000h	ready (not supported for device ID 0001h)
 0001h	stand-by
 0002h	suspend
 0003h	off (not supported for device ID 0001h in APM v1.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后可在虚拟机上查看效果，由于增加了键盘等待，程序不会空耗cpu资源，而且可以关机，也不用使用暴力的方式断电关机。&lt;/p&gt;
&lt;h1 id=&#34;汇编优化执行文件大小&#34;&gt;汇编优化执行文件大小&lt;/h1&gt;
&lt;p&gt;闲来无事写了一个点灯小游戏，记得当年在文曲星上玩过，现在使用BIOS中断在引导区实现，其实整个游戏实现起来并不复杂，无非是一些BIOS调 用，图形显示等等，但是最让人郁闷的事情是引导程序仅仅有512字节，当然有方法突破这个限制，但这仅仅是个小程序，没有必要再去载入文件到内存。不过这 个以后倒可以试试。&lt;/p&gt;
&lt;p&gt;这里的代码不少，我会附到文后，不过我想也没有人去研究如此杂乱的代码。不过程序还有不少问题，BIOS刷新屏幕的部分，我重绘背景，这样导致刷新时会闪 屏，也不算很大的bug，我也没有花精力去解决这个问题，还有一个问题是填充的问题，最后填充时总是说长度不能为负，不过实际计算长度远不足512，不知 道什么机制导致这种错误，不过最后我编译好程序刚刚好512字节，也不存在填充的问题了，只是扩展不易。&lt;/p&gt;
&lt;p&gt;其实编译结果为512字节并非巧合，开始写完程序时文件有680多字节，经过调整代码，压缩，最终才缩小至512字节，能让系统正常引导。这里说下压缩可执行文件大小的经验：&lt;/p&gt;
&lt;h2 id=&#34;一立即数优化&#34;&gt;一、立即数优化&lt;/h2&gt;
&lt;p&gt;程 序中经常有 mov ax, 0 类似的指令，目的是把一个寄存器清零，别看这里的0是很小的数字，他占用的大小与 0ffffh 无异，都是根据Intel立即数的大小而定的，其他的比如ax和mov仅仅是intel的一个索引，所需字节很少，所以如非必要，尽力避免立即数的使用， 寄存器清零可使用 xor ax, ax 指令实现。相同的原理 cmp ax, 0 可用 test ax, ax 实现。
还是如果给寄存器加2，直接写成 add bp, 2 甚至比两个inc bp还要大。&lt;/p&gt;
&lt;h2 id=&#34;二地址优化&#34;&gt;二、地址优化&lt;/h2&gt;
&lt;p&gt;时 常会出现使用 address 寻址变量的情况，如果一个变量寻址多次，mov ax, word ptr[address]就会出现多次，address在16位平台大小16位，这样累计也是很客观的大小，这种情况可以使用mov si, offset address 指令，刚才提到，si寄存器仅仅是一个索引，所以mov ax, word ptr[si] 会比刚才要小，如果相同代码很多，则可节省不少空间。&lt;/p&gt;
&lt;p&gt;另外，还有函数的调用，有些代码放到函数中可减少重复代码，但如果函数很小call address占用的空间便会很大；
如果要保存一个寄存器待执行完毕后恢复，使用push cx, pop cx要比先存储与其他寄存器事后再恢复要小很多。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言练习-AT&amp;T汇编win32窗口</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-gas-win32/</link>
        <pubDate>Sun, 27 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-assembler-gas-win32/</guid>
        <description>&lt;p&gt;这里写一个win32窗口程序，如果对c语言如何使用api创建窗口还不熟悉，请先学习win32 api的使用，网上有很多用masm编写win32程序的例子，使用masm编写win32程序也比较方便，这里便不再重复。&lt;/p&gt;
&lt;p&gt;masm 毕竟对win32的api自己做了一层封装，不能使我们更加透彻的理解win32 api，所以我这里的例子使用AT&amp;amp;T语法编写，编译环境为mingw，当然，这里依赖于windows平台，语法虽说是跨平台的，但使用了系统 调用，便无法在linux下使用了。&lt;/p&gt;
&lt;p&gt;似乎很少有使用AT&amp;amp;T语法写窗口的例子，可能因为这样写比较繁琐，且没有意义，所以本例可能只是练习AT&amp;amp;T语法，顺便学习win32 api最原生的程序是什么样子，如果反汇编一个程序，看到的样子应该与这个相差无几，也为逆向或者破解做一些基础工作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
class_name:
	.asciz &amp;quot;go&amp;quot;
window_name:
	.asciz &amp;quot;First AT&amp;amp;T Windows&amp;quot;

.section .text

.globl _WindowProc
_WindowProc:
	pushl %ebp
	movl %esp, %ebp
	subl $16, %esp

	/*
		8 (%ebp) hwnd
		12(%ebp) message
		16(%ebp) wParam
		20(%ebp) lParam
	*/
	/* WM_DESTROY */
	cmp $0x0002, 12(%ebp)
	jnz L1
	pushl $0
	call _PostQuitMessage@4
L1:

	pushl 20(%ebp)
	pushl 16(%ebp)
	pushl 12(%ebp)
	pushl 8(%ebp)
	call _DefWindowProcA@16
	addl $16, %esp

	movl %ebp, %esp
	popl %ebp
	ret $16

.globl _main
_main:
	pushl %ebp
	movl %esp, %ebp
	subl $128, %esp
	/*
		-4(%ebp)  className
		-8(%ebp)  menuName
		-12(%ebp) hbrbackground
		-16(%ebp) hCursor
		-20(%ebp) hIcon
		-24(%ebp) hInstance
		-28(%ebp) wnd extra
		-32(%ebp) class extra
		-36(%ebp) callback
		-40(%ebp) style
	*/
	movl $0x03, -40(%ebp)
	movl $_WindowProc, -36(%ebp)
	movl $0, -32(%ebp)
	movl $0, -28(%ebp)
	movl 8(%ebp), %eax
	movl %eax, -24(%ebp)
	movl $0, -20(%ebp)
	movl $0, -16(%ebp)

	pushl $4
	call _GetStockObject@4
	movl %eax, -12(%ebp)
	movl $0, -8(%ebp)
	movl $class_name, -4(%ebp)

	leal -40(%ebp), %eax
	pushl %eax
	call _RegisterClassA@4

	/*
		-44(%ebp) hwnd
	*/
	pushl $0
	pushl -24(%ebp)
	pushl $0
	pushl $0
	pushl $0x80000000
	pushl $0x80000000
	pushl $0x80000000
	pushl $0x80000000
	pushl $0xCF0000
	pushl $window_name
	pushl $class_name
	pushl $0
	call _CreateWindowExA@48
	movl %eax, -44(%ebp)

	pushl $1
	pushl -44(%ebp)
	call _ShowWindow@8

	pushl -44(%ebp)
	call _UpdateWindow@4

	/*
		28 byte MSG
		-48(%ebp) -&amp;gt; -76(%ebp)
	*/

L_Message:
	pushl $0
	pushl $0
	pushl $0
	leal -76(%ebp), %eax
	pushl %eax
	call _GetMessageA@16
	test %eax, %eax
	jz L_End

	leal -76(%ebp), %eax
	pushl %eax
	call _TranslateMessage@4

	leal -76(%ebp), %eax
	pushl %eax
	call _DispatchMessageA@4
	jmp L_Message

L_End:
	movl %ebp, %esp
	popl %ebp
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里基本结构是win32 api标准的窗口创建程序，只是AT&amp;amp;T语法没有相应的结构体，只能通过操作一块内存的方式处理，在AT&amp;amp;T看来，windows下的所 有结构体都仅仅是一块内存，具体多少偏移代表什么意义，还需根据win32的结构体对应。这里的符号有些奇怪，之前提到过STDCALL的符号处理方式， 后缀要加“@参数字节数”。&lt;/p&gt;
&lt;p&gt;编译过程使用 gcc win.s -lgdi32 因为其中使用了gdi函数，所以需引入gdi32库。&lt;/p&gt;
&lt;p&gt;如 果注意一下编译后的可执行文件大小，足足有27k之多，对于masm汇编可能就有几k，真是天壤之别，难道mingw如此臃肿么？其实这里正是mingw 灵活的地方，之所以编译后有如此之大，是因为mingw添加了很多信息，对于windows的pe格式，不管你怎么编译，最终可用代码都是一样的，而ld 连接器可以自定义脚本，甚至手工设置段信息，这里来试一下，先写一个win.lds的ld脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SEARCH_DIR(&amp;quot;D:\Program Files\MSYS\mingw\lib&amp;quot;)
SEARCH_DIR(&amp;quot;D:\Program Files\MSYS\mingw\include&amp;quot;)
ENTRY(_main)

SECTIONS
{
. = 0X40000;
.text : {*(.text)}
.data : {*(.data)}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;脚本开始定义一下搜索路径，方便找到引用的头文件和库，ENTRY定义了程序的入口函数符号，SECTIONS定义各个段，从0×40000开始，依次是代码段和数据段。&lt;/p&gt;
&lt;p&gt;之后再进行分步编译：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;as win.s -o
ld win.lds a.out -lgdi32 -luser32
strip a.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终生成可执行文件a.exe，可以看到仅仅有2k了。如果之前大家用od调试过mingw的程序，可以看到大部分的代码都不是我们所写，调试也不方便，但通过这种方式生成，用ollydbg反汇编后，剩下的大部分都是我们所写的有效代码，而且基本与我们的代码一一对应。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言练习-实模式下的汇编</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-16-asm-real-mode.md/</link>
        <pubDate>Sat, 26 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/practice-16-asm-real-mode.md/</guid>
        <description>&lt;p&gt;在MS-DOS下，没有保护模式与32位寄存器，程序可以直接调用BIOS中断，虽然DOS系统已经离我们远去，但是Intel CPU进入保护模式之前需在实模式下进行设置和跳转，所以实模式编程仍然具有一定的意义，在本篇中不介绍纯DOS环境下的MASM，仅仅利用 Windows的虚拟8086模式编程，虚拟8086是Intel为了兼容实模式程序推出的，此模式可以让用户程序在32位系统上进行16位操作，模拟了 8086处理器。&lt;/p&gt;
&lt;p&gt;在16位实模式下，由于寻址空间的限制，必须把内存划分为多个段，如果单纯的使用一个offset，由于16位的操作数，最多能寻址 64k 的地址空间，但8086 cpu的数据总线有20位，也就是能够寻址1M的地址，所以intel处理器想出了 seg:offset 的方式，去寻址，首先由seg段寄存器定位一个地址，再此地址上进行偏移，具体计算 seg * 16 + offset ，如此便可达到20位的寻址。所以在实模式下编程，还需要注意段寄存器，在寻址之前要看使用的段。&lt;/p&gt;
&lt;p&gt;还有一个问题是编译最后的格式，之前在windows保护模式下，编译最后都是windows可执行文件PE格式，这显然是不能在实模式下运行的，所以还需要把我们的程序编译成能够在实模式下运行的文件。&lt;/p&gt;
&lt;p&gt;在MS-DOS下支持一种COM二进制执行文件，COM格式是纯二进制代码，系统加载时把此文件加载至100h内存处。现来写一个简单的COM程序框架：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.model tiny
.code
org 100h

main proc
	mov ah, 2
	mov dl, &#39;A&#39;
	int 21h
die:
	jmp die
	ret
main endp
end main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码开始首先使用.model设置当前内存模式是tiny，而非之前的flat模式，然后再代码开始的地方使用org伪指令指定程序将要载入内存的位置，这里设置段基址时有用，如果设置错误将会找不到定义的数据字符。&lt;/p&gt;
&lt;p&gt;接下来使用了int 21h，int 21h是DOS调用，DOS调用相比BIOS调用就方便的多了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先把功能号存储于AH寄存器 
把参数传入指定寄存器
int 21h 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里使用功能号2，输出一个字符，DOS调用的其他功能网上有大量教程，而且DOS调用至今或许也没太大价值，这里便不再叙述。&lt;/p&gt;
&lt;p&gt;最后再来看如何编译我们的程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ml /c 16bit.asm
link16 /TINY 16bit.obj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的连接程序使用了link16处理16位程序，之后双击16bit.com，便可看到控制台窗口输出字符A，程序进入死循环。&lt;/p&gt;
&lt;p&gt;当然，可以利用刚才所述内从结合上篇BIOS视频控制来制作系统的引导程序，仅仅需要再程序之后填充至512字节并且以 55AA结尾便可，这里列举一下填充部分代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fill db (510 - (fill - main)) dup (0)
db 55h
db 0AAh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里进行了一次计算，fill为当前位置，减去程序开始地址，即到当前所用去的字节数，再被510减，得到需要填充的字节数，用0补足，最后在定义 55AA 标志字即可，当然DOS调用是无法使用的，需要替换成BIOS调用。&lt;/p&gt;
&lt;p&gt;关于AT&amp;amp;T实模式编程，可参考后面的BIOS模式下的汇编编程&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十四)-SSE指令集</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.-assembler-sse-instruct/</link>
        <pubDate>Fri, 25 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.-assembler-sse-instruct/</guid>
        <description>&lt;p&gt;本篇介绍sse指令接，sse是流化SIMD扩展（Streaming SIMD Extension, SSE)，提供全新的一组寄存器，处理128位打包数据。&lt;/p&gt;
&lt;p&gt;sse提供了xmm寄存器，xmm一组8个128位的寄存器，分别名为xmm0-xmm7，sse构架提供对打包单精度浮点数的SIMD支持。&lt;/p&gt;
&lt;p&gt;sse提供了两个版本的指令，其一以后缀ps结尾，这组指令对打包单精度浮点值执行类似mmx操作运算，而第二种后缀ss，这些指令对一个量标单精度浮点 值进行运算操作，这些指令不对打包值中的所有浮点值操作，而只对打包值中的低位双字节执行操作，源操作数中剩余的3个值直接传送给结果。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movaps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把4个对准的单精度值传送到xmm寄存器或者内存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movups&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把4个不对准的单精度值传送到xmm寄存器或者内存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movss&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把1个单精度值传送到内存或者寄存器的低位双字&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movlps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个单精度值传送到内存或者寄存器的低四字&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movhps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个单精度值传送到内存或者寄存器的高四字&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movlhps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个单精度值从低四字传送到高四字&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movhlps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个单精度值从高四字传送到低四字&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中对准操作movaps要求数据在内存中对准16字节的边界，以提交效率，否则应使用movups传送数据。&lt;/p&gt;
&lt;p&gt;运算指令：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;addps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将两个打包值相加&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;subps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将两个打包值相减&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;mulps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将两个打包值相乘&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;divps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将两个打包值相除&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;rcpps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包值的倒数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;sqrtps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包值的平方根&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;rsqrtps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包值的平方根倒数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;maxps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算两个打包值中的最大值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;minps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算两个打包值中的最小值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;andps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算两个打包值的按位逻辑与&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;andnps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算两个打包值的按位逻辑非&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;orps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算两个打包值的按位逻辑或&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;xorps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算两个打包值的按位逻辑异或&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上指令都是用两个操作数：源操作数可以是128位内存或者xmm寄存器，目标操作数必须是xmm寄存器。&lt;/p&gt;
&lt;p&gt;这里举一个简单的例子，使用gdb查看最后结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
	value1: .float 12.12, 34.89, 56.23, 78.45
	value2: .float 31.12, 57.124, 234.23, 67.246
.section .text
.globl _main
_main:
	enter $0, $0

	movups value1, %xmm0
	movups value2, %xmm1
	addps %xmm0, %xmm1

	movups value2, %xmm1
	maxps %xmm0, %xmm1
	leave
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译时加-g参数加入调试信息，调用addps后查看xmm1寄存器的结果，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) print $xmm1
$1 = {v4_float = {43.2400017, 92.0139999, 290.459991, 145.695999},
  v2_double = {26419069594869.762, 1245245520236216.2}, v16_int8 = {-61, -11,
    44, 66, 43, 7, -72, 66, -31, 58, -111, 67, 45, -78, 17, 67}, v8_int16 = {
    -2621, 16940, 1835, 17080, 15073, 17297, -19923, 17169}, v4_int32 = {
    1110242755, 1119356715, 1133591265, 1125233197}, v2_int64 = {
    4807600484593235395, 4832839782622116577},
  uint128 = 0x4311b22d43913ae142b8072b422cf5c3}
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，调用加法指令之后，四组和都存储在xmm1寄存器中，gdb查看时由于不知道如何解析xmm1寄存器的内容，因为可能是单精度，也可能是双精度或者不同宽度的整数，所以只能按不同的解析方式全部显示，查看v4_float即四个单精度浮点数的显示。&lt;/p&gt;
&lt;p&gt;下面介绍一下sse构架下的比较指令，sse的比较指令单独比较128位打包单精度浮点的每个元素，结果是一个掩码，满足比较条件的结果全为1值，不满足结果的全为0值（量标只对最低的双字执行）。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;cmpps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较打包值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;cmpss&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较标量值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;comiss&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较标量值并且设置eflags寄存器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ucomiss&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较标量值（包括非法值）并设置eflags寄存器&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;看到这里，仅仅有一个比较指令，并没有说明大小，何为满足条件全1，不满足全0呢，这样说一下指令的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmpps imp, source, destination
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中多出来的imp是一个无符号整数，这个整数表示的含义就是条件，这个条件值如下表所示：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;整数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;等于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;小于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;小于或等于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;无序&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;4&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;不等于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;5&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;不小于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;6&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;不小于或等于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;7&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;有序&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果需要比较两个数是否相等，传imp为0即可作为条件，满足条件结果全1，这是sse的比较方式。这里说明一下条件中的无序，因为是浮点比较，寄存器或内存中的有些值并不符合规定的浮点存储格式，相互比较是没有意义的，称为无序。&lt;/p&gt;
&lt;p&gt;除了对浮点数的支持，sse指令集也有指令对mmx提供的功能进行扩展，他们对mmx寄存器中的数据执行操作：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pavgb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包无符号字节整数的平均值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pavgw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包无符号字整数的平均值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pextrw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把一个字从mmx寄存器复制到通用寄存器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pinsrw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把一个字从通用寄存器复制到mmx寄存器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmaxub&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包无符号字节整数的最大值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmaxsw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包有符号字整数的最大值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pminub&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包无符号字节整数的最小值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pminsw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算打包有符号字整数的最小值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmulhuw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将打包无符号字整数相乘并且存储高位结果&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psadbw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算无符号字节整数的绝对差的总和&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SSE2 指令集又对 SSE 指令集做了很多扩充，主要对操作双精度浮点数和128位打包整数值执行数学操作，下面介绍SSE2的使用，先来看数据传送指令：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movapd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个对准的双精度值传送到xmm寄存器或者内存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movupd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个不对准的双精度值传送到xmm寄存器或者内存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movdqa&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个对准的四字节整数传送到xmm寄存器或者内存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movdqu&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把2个不对准的四字节整数传送到xmm寄存器或者内存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movsd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把1个双精度值传送到内存或者寄存器的低四字&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movhpd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把1个双精度值传送到内存或者寄存器的高四字&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movlpd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把1个双精度值传送到内存或者寄存器的低四字&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SSE2指令集提供处理打包双精度浮点数，打包字整数，打包双字整数和打包四字整数值的数学指令，这里列举SSE2的加法指令来说明这一系列指令格式：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;addpd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将打包双精度浮点值相加&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;addsd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将量标双精度浮点值相加&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddsb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将打包带符号字节整数相加&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddsw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将打包带符号字整数相加&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将打包带符号双字整数相加&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddq&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将打包带符号四字整数相加&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里虽然只列举add系列指令，这些选项也存在于乘法和除法操作中(mulpd, mulsd, divpd, divsd等）。
另外同sse指令集，sse2指令集也提供专门的数学操作，sqrt, max, min。&lt;/p&gt;
&lt;p&gt;最后我们来看SSE3指令集，SSE3构架并没有提供任何新的数据类型，仅仅添加了几条指令，用于更快的执行标准函数，下面是新指令的列表：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fisttp&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把第一个fpu寄存器的值转换为整数（舍入）并且从fpu堆栈弹出&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;lddqu&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;快速从内存加载128位不对准的数据值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movshdup&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;传送128位值，复制第2个和第4个32位数据元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movsldup&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;传送128位值，复制第1个和第3个32位数据元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;movddup&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;传送64位值，赋值值，使之成为128位值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;addsubps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对于打包单精度浮点数，对第2个和第4个32位执行加法，第1和第3个32位执行减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;addsubpd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对于打包单精度浮点数，对第2对64位值执行加法，第1对位执行减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;haddps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对操作数的相邻的元素执行单精度浮点加法操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;haddpd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对操作数的相邻的元素执行双精度浮点加法操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;hsubps&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对操作数的相邻的元素执行单精度浮点减法操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;hsubpd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对操作数的相邻的元素执行双精度浮点减法操作&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SSE指令繁多，这里举得例子却很少，以后我会在此文继续附加一些说明例子，方便理解。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十三)-MMX指令集</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.-assembler-mmx-instruct/</link>
        <pubDate>Thu, 24 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.-assembler-mmx-instruct/</guid>
        <description>&lt;p&gt;这篇来介绍intel cpu的高级特性，SIMD-单指令多数据，从名字来看，就是执行一条指令可以计算多个数据。先从最简单的mmx指令集来看，在寄存器那篇已经提 到，mmx有 mm0-mm7 共8个64位寄存器，但是寄存器并非独立寄存器，而是复用了上篇说到的fpu数据堆栈寄存器，也就是说使用mmx指令集会破坏fpu的计算，如果同时使用 着两种特性，一定要注意这点，避免出现莫名的错误。&lt;/p&gt;
&lt;p&gt;首先mmx指令集需要cpu的支持，但不是所有cpu都支持，不然也不会称之为高级特性 了，所以在使用之前需要检测，检测指令为cpuid，获得cpu的特性，cpuid虽然只有一条指令，但是其隐含的内容太多，这里仅仅介绍检测SIMD指 令集所需要的部分，其他一些信息可参阅Intel 手册获得。&lt;/p&gt;
&lt;p&gt;当eax为1时，cpuid指令返回cpu签名信息，放入ecx和edx寄存器中，相应位为1表示支持。检测SIMD指令集的结果如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;寄存器&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;位&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EDX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;23&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;支持MMX&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EDX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;25&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;支持SSE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EDX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;26&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;支持SSE2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ECX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;支持SSE3&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;具体检测代码如下(AT&amp;amp;T 语法)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
	mmxstring: .asciz &amp;quot;支持mmx指令集\n&amp;quot;
	ssestring: .asciz &amp;quot;支持sse指令集\n&amp;quot;
	sse2string: .asciz &amp;quot;支持sse2指令集\n&amp;quot;
	sse3string: .asciz &amp;quot;支持sse3指令集\n&amp;quot;

.section .text
.globl _main
_main:
	movl $1, %eax
	cpuid

mmxop:
	test $0x800000, %edx
	jz sseop
	pushl $mmxstring
	call _printf

sseop:
	test $0x2000000, %edx
	jz sse2op
	pushl $ssestring
	call _printf

sse2op:
	test $0x4000000, %edx
	jz sse3op
	pushl $sse2string
	call _printf

sse3op:
	test $0x01, %ecx
	jz end
	pushl $sse3string
	call _printf
end:
	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面正式开始mmx指令集的介绍，使用mmx需要三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从整数值创建打包整数，载入mmx寄存器&lt;/li&gt;
&lt;li&gt;使用mmx指令集计算&lt;/li&gt;
&lt;li&gt;从mmx获得结果，存入内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个和最后一个步骤比较简单，仅仅是数据移动而已，这里提到打包，因为这里要单指令多数据，所以需要把多数据合成一个操作数进行计算，存入64位的mmx寄存器中，打包的过程就是把 8个字节/4个字/2个双字 合成一个64位数据。&lt;/p&gt;
&lt;p&gt;从加减法说起，对于普通数据，如果数据溢出可以置标记位，但是对于多数据的运算，由于同时计算多个加法，就不能单纯的设置标志，对mmx计算有几种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;环绕运算		截断其值，丢弃进位
带符号饱和	最大/最小 带符号值
无符号饱和	最大/最小 无符号值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中饱和运算的预设值根据结果的位数决定，有符号8位最大为127，如果超过127，结果按127计算，其他情况与此类似，这里方便与一些图形处理，比如色彩黑色为0，为无符号最小值，小于其值也按黑色处理。&lt;/p&gt;
&lt;p&gt;好 了，到此可以看一下具体的指令，这里的指令有相同的格式，instruction source, destination;其中source可以是mmx寄存器或者64位内存，destination为mmx寄存器。这是AT&amp;amp;T语法，对于 MASM语法源目的操作数相反。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环绕打包字节整数加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环绕打包字整数加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环绕打包双字整数加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddsb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;带符号饱和打包字节整数加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddsw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;带符号饱和打包字整数加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddusb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;无符号饱和打包字节整数加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;paddusw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;无符号饱和打包字整数加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psubb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环绕打包字节整数减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psubw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环绕打包字整数减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psubd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环绕打包双字整数减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psubsb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;带符号饱和打包字节整数减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psubsw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;带符号饱和打包字整数减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psubusb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;无符号饱和打包字节整数减法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psubusw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;无符号饱和打包字整数减法&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面以AT&amp;amp;T加法为例进行说明，这里以饱和方式计算4个无符号字之和：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# add four word
# output : result is 18932, 7631, 65535, 510
.section .data
	value1: .short 12300, 2384, 60000, 456
	value2: .short 6632, 5247, 40000, 54

	outstring: .asciz &amp;quot;result is %u, %u, %u, %u\n&amp;quot;
.section .text
.globl _main
_main:
	movq value1, %mm0
	movq value2, %mm1
	paddusw %mm1, %mm0
	movq %mm0, value1

	movl $value1, %ebx
	xorl %eax, %eax
	movw 6(%ebx), %ax
	pushl %eax
	movw 4(%ebx), %ax
	pushl %eax
	movw 2(%ebx), %ax
	pushl %eax
	movw (%ebx), %ax
	pushl %eax

	pushl $outstring
	call _printf

	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;movq 指令把内存中的数据传送至mmx寄存器，如果数据之前在内存中不是连续的，则需要集中存放，即进行打包，之后使用paddusw进行加法计算，输出时 word需转化成dword放入堆栈，可以看到以饱和方式第三个结果为65535，即16位无符号数的最大值。从这里例子可以看出，通过一条指令计算了四 个word整数相加，很大程度上提高了计算的效率，但是同时需要注意，整数的打包以及传送过程也需要耗时，如果打包操作很多，结果不是提高效率而是降低效 率了。&lt;/p&gt;
&lt;p&gt;mmx指令集的加法根据需要有饱和方式和环绕方式计算，但对于乘法而言，由于结果的宽度可能是操作数的两倍，所以两种方式看上去都不合适，所以intel提供了两个指令，一个得到计算结果的低字节，另一个得到计算结果的高字节。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmulluw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对无符号16位整数相乘取结果低16位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmulhuw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对无符号16位整数相乘取结果高16位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmullw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对有符号16位整数相乘取结果低16位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmulhw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对有符号16位整数相乘取结果高16位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pmaddwd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对4个带符号整数相乘，高位两个结果相加存入高32位，低位相同&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;mmx指令集还提供对四字值进行布尔逻辑操作和移位指令：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pand&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对源和目标操作数按位与操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pandn&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对目标操作数进行按位逻辑非操作，然后对源和目标操作数按位与操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;por&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对源和目标操作数按位或操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pxor&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对源和目标操作数按位异或操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psll&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对目标操作数执行逻辑左移操作，使用0填充空位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;psra&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对目标操作数执行逻辑右移操作，使用0填充空位&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其AT&amp;amp;T指令格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pand source, destination
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中source是mmx寄存器或者64位内存，destination必须是mmx寄存器。移位指令可以使用字，双字或者四字操作数，还有移位的位置数量。MASM格式的源目的操作数相反。&lt;/p&gt;
&lt;p&gt;mmx构架提供了用于比较两个值的指令：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pcmpeqb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较打包字节整数值的相等性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pcmpeqw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较打包字整数值的相等性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pcmpeqd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较打包双字整数值的相等性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pcmpgtb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;判断打包字节整数值是否大于另一个&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pcmpgtw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;判断打包字整数值是否大于另一个&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;pcmpgtd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;判断打包双字整数值是否大于另一个&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为mmx同时比较多个数据，所以不能设置标志，替换的做法是把判断结果放到目标打包整数值中，如果打包整数值满足对比提交，就把结果设置为全1，否则设置为全0。&lt;/p&gt;
&lt;p&gt;由于mmx指令集并非所有cpu都可以支持，所以对c语言这种编译通用性的程序而言，是不会贸然使用mmx指令集的，这也对我们手工汇编优化程序提供了很大的空间，但是需要注意打包整数的效率损耗。&lt;/p&gt;
&lt;p&gt;另外，intel除了mmx指令集，另有SIMD指令如sse指令集，将会再下篇详细说明。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十二)-浮点指令</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.-assembler-float-instruct/</link>
        <pubDate>Wed, 23 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.-assembler-float-instruct/</guid>
        <description>&lt;h1 id=&#34;浮点数如何存储&#34;&gt;浮点数如何存储&lt;/h1&gt;
&lt;p&gt;浮点数的运算完全不同于整数，从寄存器到指令，都有一套独特的处理流程，浮点单元也称作x87 FPU。&lt;/p&gt;
&lt;p&gt;现在看浮点数的表示方式，我们所知道的，计算机使用二进制存储数据，所表示的数字都具有确定性，那是如何表示浮点这种具有近似效果的数据呢，答案是通过科学计数，科学计数由符号，尾数和指数表示，这三部分都是一个整数值，具体来看一下IEEE二进制浮点标准：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;格式&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;单精度&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;32位：符号占1位，指数占8位，尾数中的小数部分占23位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;双精度&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;64位：符号占1位，指数占11位，尾数中的小数部分占52位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;扩展精度&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;80位：符号占1位，指数占16位，尾数中的小数部分占63位&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以单精度为例，在内存中的储存格式如下（左边为高位）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	| 1位符号 | 8位指数 | 23位尾数 |
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中符号位1表示负数，0表示正数，这与整数形式的符号位意义相同；
科学计数法表示形式如 m * (b ^ e)，m为尾数，b为基数，e是指数，再二进制中，基数毫无疑问是2，对单精度，指数为中间8位二进制表示的数字，其中的尾数是形如1.1101 小数点后面的整数值。&lt;/p&gt;
&lt;p&gt;关于指数，由于需要表示正负两种数据，IEEE标准规定单精度指数以127为分割线，实际存储的数据是指数加127所得结果，127为高位为零，后7位为1所得，其他双精度也以此方式计算。&lt;/p&gt;
&lt;p&gt;为了解释内存中浮点数的存储方式，举一个浮点数的例子说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float test = 123.456;

int main()
{
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例子再简单不过了，仅仅定义了一个全局的float类型，我们通过&lt;code&gt;gcc -S test.c&lt;/code&gt;来生成汇编，看看&lt;code&gt;123.456&lt;/code&gt;是如何存储的，打开反汇编后的文件，看到符号&lt;code&gt;_test&lt;/code&gt;后定义的数字是 &lt;code&gt;1123477881&lt;/code&gt; （这里gcc定义成了long类型，不过没有关系，因为都是四字节数字，具体的类型还得看如何使用）。可以使用计算器把十进制数字转化为二进制：&lt;code&gt;0 10000101 11101101110100101111001&lt;/code&gt;，这里根据单精度的划分方式把32位划分成三部分，符号位为0，为正数，指数为 133，减去127得6，尾数加上1.，形式为&lt;code&gt;1.11101101110100101111001&lt;/code&gt;，扩大2 ^ 23次方为&lt;code&gt;111101101110100101111001&lt;/code&gt;，十进制&lt;code&gt;16181625&lt;/code&gt;，后除以&lt;code&gt;2 ^ (23 – 6) = 131072&lt;/code&gt;，结果为&lt;code&gt;123.45600128173828125&lt;/code&gt;，与我们所定义的浮点数正好相符。&lt;/p&gt;
&lt;h1 id=&#34;浮点寄存器&#34;&gt;浮点寄存器&lt;/h1&gt;
&lt;p&gt;这里介绍了浮点数的二进制表示，前面说过浮点单元计算使用独立的寄存器，在寄存器那篇也稍有提及，这里详细说明一下浮点单元的寄存器设施。&lt;/p&gt;
&lt;p&gt;FPU有 8 个独立寻址的80位寄存器，名称分别为r0, r1, …, r7，他们以堆栈形式组织在一起，统称为寄存器栈，编写浮点指令时栈顶也写为st(0)，最后一个寄存器写作st(7)。&lt;/p&gt;
&lt;p&gt;FPU另有3个16位的寄存器，分别为控制寄存器、状态寄存器、标记寄存器，现一一详细说明此三个寄存器的作用：&lt;/p&gt;
&lt;p&gt;状态寄存器，为用户记录浮点计算过程中的状态，其中各位的含义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 —— 非法操作异常
1 —— 非规格化操作数异常
2 —— 除数为0异常
3 —— 溢出标志异常
4 —— 下溢标志异常
5 —— 精度异常标志
6 —— 堆栈错误
7 —— 错误汇总状态
8 —— 条件代码位0（c0）
9 —— 条件代码位1（c1）
10 —— 条件代码位2 （c2）
11-13 —— 堆栈顶指针
14 —— 条件代码位3（c3）
15 —— 繁忙标志
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中读取状态寄存器内容可使用 fstsw %ax&lt;/p&gt;
&lt;p&gt;控制寄存器的位含义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 —— 非法操作异常掩码 
1 —— 非法格式化异常掩码 
2 —— 除数为0异常掩码 
3 —— 溢出异常掩码 
4 —— 下溢异常掩码 
5 —— 精度异常亚曼 
6-7 —— 保留 
8-9 —— 精度控制（00单精度，01未使用，10双精度，11扩展精度） 
10-11 —— 舍入控制（00舍入到最近，01向下舍入，10向上舍入，11向0舍入） 
12 —— 无穷大控制 
13–15 —— 保留
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中读取控制寄存器和设置控制寄存器的指令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 加载到内存
fstcw control
# 加载到控制器
fldcw control
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的标志寄存器最为简单，分别0-15位分别标志r0-r7共8个寄存器，每个寄存器占2位，这两位的含义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;11 —— 合法扩展精度 
01 —— 零 
10 —— 特殊浮点 
11 —— 无内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外对浮点寄存器的一些控制指令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 初始化fpu，控制、状态设为默认值，但不改变fpu的数据
finit

# 恢复保存环境
fldenv buffer
fstenv buffer

#清空浮点异常
fnclex

#fpu状态保存
fssave
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fstenv 保存控制寄存器、状态寄存器、标记寄存器、FPU指令指针偏移量、FPU数据指针，FPU最后执行的操作码到内存中。&lt;/p&gt;
&lt;h1 id=&#34;浮点数指令&#34;&gt;浮点数指令&lt;/h1&gt;
&lt;p&gt;接下来将要详细说明其计算过程，要计算数据首先得看如何从内存中加载数据到寄存器，同时把结果从寄存器取出到内存，除了加载内存中的浮点数据指令，另外还有一些常量的加载，现列举如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;finit&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;初始化控制和状态寄存器，不改变fpu数据寄存器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fstcw control&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将控制寄存器内容放到内存control处&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fstsw status&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将状态寄存器内容放到内存status处&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;flds value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;加载内存中的单精浮点到fpu寄存器堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldl value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;加载内存中的双精浮点到fpu寄存器堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldt value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;加载内存中的扩展精度点到fpu寄存器堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fld %st(i)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将%st(i)寄存器数据压入fpu寄存器堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fsts value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;单精度数据保存到value，不出栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fstl value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;双精度数据保存到value，不出栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fstt value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;扩展精度数据保存到value，不出栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fstps value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;单精度数据保存到value，出栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fstpl value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;双精度数据保存到value，出栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fstpt value&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;扩展精度数据保存到value，出栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fxch %st(i)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;交换%st(0)和%st(i)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fld1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把 +1.0 压入 FPU 堆栈中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldl2t&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把 10 的对数(底数2)压入 FPU 堆栈中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldl2e&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把 e 的对数(底数2)压入 FPU 堆栈中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldpi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把 pi 的值压入 FPU 堆栈中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldlg2&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把 2 的对数(底数10)压入 FPU 堆栈中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldln2&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把 2 的对数(底数e) 压入堆栈中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fldz&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把 +0.0 压入压入堆栈中&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上指令虽多，但是还是很有规律，前缀f表示fpu操作，ld加载，st保存设置，p后缀弹出堆栈，s、l、t后缀表示单精度，双精度，扩展精度，c后缀表 示控制寄存器，s后缀表示状态寄存器。当然这仅仅是对AT&amp;amp;T语法而言，对MASM语法没有s，l，t之分，需要使用type ptr来指明精度，即内存大小。&lt;/p&gt;
&lt;p&gt;学会灵活的加载弹出数据堆栈后，接下来就要看一些基本的计算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fadd 	浮点加法
fdiv 	浮点除法
fdivr 	反向浮点除法
fmul 	浮点乘法
fsub 	浮点减法
fsubr 	反向浮点减法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于以上的每种指令，有几种指令格式，以fadd为例，列举如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 内从中的32位或者64位值和%st(0)相加
fadd source

# 把%st(x)和%st(0)相加，结果存入%st(0)
fadd %st(x), %st(0)

# 把%st(0)和%st(x)相加，结果存入%st(x)
fadd %st(0), %st(x)

# 把%st(0)和%st(x)相加，结果存入%st(x)，弹出%st(0)
faddp %st(0), %st(x)

# 把%st(0)和%st(1)相加，结果存入%st(1)，弹出%st(0)
faddp

# 把16位或32位整数与%st(0)相加，结果存入%st(0)
fiadd source
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这仅仅是对AT&amp;amp;T语法而言，对MASM源操作数与目的操作数相反！另外，对AT&amp;amp;T，与内存相关指令可加s、l指定内存精度。其中反向加法和反向除法是计算过程中目的与源反向计算。&lt;/p&gt;
&lt;h1 id=&#34;浮点计算例子&#34;&gt;浮点计算例子&lt;/h1&gt;
&lt;p&gt;接下来举一个AT&amp;amp;T语法的例子，来计算表达式的值 ( 12.34 * 13 ) + 334.75 ) / 17.8 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ( 12.34 * 13 ) + 334.75 ) / 17.8
.section .data
	values: .float 12.34, 13, 334.75, 17.8
	result: .double 0.0

	outstring: .asciz &amp;quot;result is %f\n&amp;quot;
.section .text
.globl _main
_main:
	leal values, %ebx
	flds 12(%ebx)
	flds 8(%ebx)
	flds 4(%ebx)
	flds (%ebx)

	fmulp
	faddp
	fdivp %st(0), %st(1)

	fstl result

	leal result, %ebx
	pushl 4(%ebx)
	pushl (%ebx)
	pushl $outstring
	call _printf
end:
	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前四个flds加载所有的数据到寄存器堆栈，可以单步运行并是用gdb的print $st0打印堆栈寄存器的值，可以看到为什么是堆栈寄存器。需要说明的是由于printf的%f是double类型的输出，所以最后要把一个8字节浮点放 到栈中传递，最终结果为27.818541，可以看到与计算器计算的结果近似相等。&lt;/p&gt;
&lt;h1 id=&#34;浮点高级运算&#34;&gt;浮点高级运算&lt;/h1&gt;
&lt;p&gt;除了基本的浮点计算，x87还提供了一些诸如余弦运算等高级计算功能：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;f2xm1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算2的乘方（次数为st0中的值，减去1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fabs&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的绝对值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fchs&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;改变st0中的值的符号&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcos&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值的余弦&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fpatan&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值的部分反正切&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fprem&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值除以st1的值的部分余数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fprem1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值除以st1的值的IEEE部分余弦&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fptan&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值的部分正切&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;frndint&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;把st0中的值舍入到最近的整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fscale&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0乘以2的st1次方&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fsin&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值的正弦&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fsincos&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值的正弦和余弦&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fsqrt&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st0中的值的平方根&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fyl2x&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st1*log st0 以2为底&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fyl2xp1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计算st1*log (st0 + 1) 以2为底&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面来看一下浮点条件分支，浮点数的比较不像整数，可以容易的使用cmp指令比较，判断eflags的值，关于浮点数比较，fpu提供独立的比较机制和指令，现对这组比较指令进行说明：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcom&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和st1寄存器的值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcom %st(x)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和stx寄存器的值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcom source&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和32/64位内存值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcomp&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和st1寄存器的值，并弹出堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcomp %st(x)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和stx寄存器的值，并弹出堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcomp source&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和32/64位内存值，并弹出堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcompp&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和st1寄存器的值，并两次弹出堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ftst&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和0.0&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浮点数比较的结果放入状态寄存器的c0，c2，c3条件代码位中，其值如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;结果&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;c3&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;c2&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;c0&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;st0 &amp;gt; source&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;st0 &amp;lt; source&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;st0 = source&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如此倘若直接判断c0，c2，c3的值比较繁琐，所以可以使用一些技巧，首先使用fstsw指令获得fpu状态寄存器的值并存入ax，再使用sahf指令把 ah寄存器中的值加载到eflags寄存器中，sahf指令把ah寄存器的第0、2、4、6、7分别传送至进位、奇偶、对准、零、符号位，不影响其他标 志，ah寄存器中这些位刚好包含fpu状态寄存器的条件代码值，所以通过fstsw和sahf指令组合，可以传送如下值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;把c0位传送到eflags的进位标志 
把c2位传送到eflags的奇偶校验标志 
把c3位传送到eflags的零标志
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传送完毕后，可以用条件跳转使用不同的结果值，另外需要说明的是浮点数相等判断，因为浮点数本身存储结构决定了它仅仅是一个近似值，所以不能直接判断是否相 等，这样可能与自己预期的结果不同，应该判断两个浮点数之差是否在一个很小的误差范围内，来决定这两个浮点数是否相等。&lt;/p&gt;
&lt;p&gt;根据上面的技巧，使用fstsw和fpu指令组合，可以方便的使用浮点判断结果，这对我们是一种便利，而intel的工程师又为我们设计了一个组合指令，fcomi指令执行浮点比较结果并把结果存放到eflags寄存器的进位，奇偶，和零标志。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcomi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和stx寄存器的值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcomip&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较st0和stx寄存器，并弹出堆栈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fucomi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较之前检查无序值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fucomip&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较之前检查无序值，之后弹出堆栈&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;判断结束后eflags的标志设置如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;结果&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;ZF&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;PF&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;CF&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;st0 &amp;gt; st(x)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;st0 &amp;lt; st(x)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;st0 = st(x)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;cmov移动指令&#34;&gt;CMOV移动指令&lt;/h1&gt;
&lt;p&gt;最后介绍的是类似cmov的指令，根据判断结果决定是否需要移动数据，其AT&amp;amp;T格式为 fcmovxx source, destination，其中source是st(x)寄存器，destination是st(0)寄存器。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmovb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)小于st(x)，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmove&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)等于st(x)，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmovbe&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)小于或等于st(x)，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmovu&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)无序，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmovnb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)不小于st(x)，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmovne&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)不等于st(x)，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmovnbe&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)不小于或等于st(x)，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;fcmovnu&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果st(0)非无序，则进行传送&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上可以看出，无论从寄存器的操作，还是计算过程，都比整数运算要繁琐的多，而且看似很简单的一个表达式，转化成浮点汇编需要做很多工作，由于其复杂性，同 一个表达式可以有多种运算过程，当然其中的效率相差很大，这依赖于对浮点汇编的理解程度，好在有高级语言处理相关工作，编写浮点指令的情况比较少见。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十一)-预编译宏</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.-assembler-precompile-macro/</link>
        <pubDate>Tue, 22 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.-assembler-precompile-macro/</guid>
        <description>&lt;p&gt;在c语言中，宏作为一种预编译手段，可以在编译之前进行替换，汇编中的宏只是语法与c有所差别，在语言中所起到的作用非常相近。&lt;/p&gt;
&lt;p&gt;先来看MASM中宏的语法规范：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;macroname macro parameter1, parameter2, ...
	statement-list
endm

; 调用
macroname parameter1, parameter2, ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看上去跟结构体的声明差不多，只是endm时不需要宏名，这里的参数是在调用点传递，预处理器只做替换，与c的宏有相同的含义，不过这里调用点的参数个数可以不与宏定义的参数个数相同，如果调用点个数多余定义，汇编器会产生一个警告，如果少于，则未传递的参数为空。&lt;/p&gt;
&lt;p&gt;接下来举一个简单的例子进行说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.386
.model flat,stdcall
option casemap:none

include		windows.inc
include		kernel32.inc
includelib	kernel32.lib
includelib	msvcrt.lib

.data
outstring	db &amp;quot;result is %d&amp;quot;, 0ah, 0dh, 0
result dd 0

.code
printf proto c s:dword, i:dword

addTwo macro a, b, result
	mov eax, a
	add eax, b
	mov result, eax
endm

start:
	addTwo 12, 14, result
	invoke printf, addr outstring, result
	addTwo result, 14, result
	invoke printf, addr outstring, result
    invoke ExitProcess, NULL
end start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过反汇编此程序，可以看到宏被扩展了两份，与函数调用不同。&lt;/p&gt;
&lt;p&gt;masm中宏的使用还有其他一些特性，对于参数，有时必须要调用者指定，可以在参数后加:req，由此后缀的参数必须传递。比如上例中的a，可以写做 a:req。
另外如果需要宏在汇编时输出信息，可使用echo伪指令，比如在addTwo宏内任意一行添加echo test data，则在编译时会输出两句test data.&lt;/p&gt;
&lt;p&gt;接下来介绍MASM的条件汇编伪指令，类似于c语言的#if-#else-#endif条件编译宏。&lt;/p&gt;
&lt;p&gt;先来看条件汇编伪指令的一般格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition
	statements
[else
	statements]
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，其用法与c基本相同，唯一需要说明一下的是condition的使用，因为次伪指令是在编译期间决定是否需要编译，所以条件表达式必须为常量，能够在编译期间识别，另外可使用一些关系运算符进行比较：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LT 	小于
GT 	大于
EQ 	等于
NE 	不等于
LE 	小于等于
GE 	大于等于
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if宏还有几种变型，现列举如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;伪指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifb &amp;lt; param &amp;gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果参数为空则允许汇编，参数名必须用&amp;lt;&amp;gt;括起&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifnb &amp;lt; param &amp;gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果参数不为空则允许汇编，参数名必须用&amp;lt;&amp;gt;括起&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifidn &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果两个参数相同则允许汇编，区分大小写&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifidni &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果两个参数相同则允许汇编，不分区大小写&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifdif &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果两个参数不同则允许汇编，区分大小写&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifdifi &amp;lt; param1 &amp;gt;,&amp;lt; param2 &amp;gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果两个参数不同则允许汇编，不分区大小写&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifdef name&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果名字定义则允许汇编&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ifndef name&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果名字没有定义则允许汇编&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MASM的重复定义块：
MASM中有些用于生成重复定义块的循环伪指令，while, repeat, for 和 forc，这些伪指令可在汇编期间生成代码，一般定义格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while constExpression
	statements
endm

repeat constExpression
	statements
endm

; 第一次循环时，参数取值为arg1
; 第二次循环时，参数取值为arg2
; 如此反复值最后一个取值
for parameter, 
	statements
endm

; 与for类似，第一次循环parameter取string的第一个字母
; 依次取遍所有字符，注意&amp;lt;&amp;gt;这两个字符前需加!标识
forc parameter, 
	statements
endm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的语法还是比较清楚，先略去实例的说明。&lt;/p&gt;
&lt;p&gt;以上是MASM语法中的宏，在AT&amp;amp;T语法中，也有类似机制，现对几个常用的宏进行说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.macro
与MASM的macro类似，只是前面需要加点，语法规则如下：

.macro macro_name param[=value], ...
	statements
.endm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里param可以赋默认值，宏中使用参数时需要使用\，\param引用参数param。举一个与MASM宏相同的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section .data
	result: .int 0
	outstring: .asciz &amp;quot;result is %d\n&amp;quot;

.section .text

.macro addTwo a, b, result
	mov \a, %eax
	add \b, %eax
	mov %eax, \result
.endm

.globl _main
_main:
	addTwo $12, $13, result
	pushl result
	pushl $outstring
	call _printf

	addTwo $123, $456, result
	pushl result
	pushl $outstring
	call _printf

	pushl $0
	call _exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外还有.if宏，其用法与MASM和c相同，这里仅仅做一个简单的列举：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;宏&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;.ifdef symbol&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;symbol 定义则编译&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;.ifeq expression&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果表达式为0则编译&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;.ifndef symbol&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果符号未定义则编译&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;.endif&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;结尾&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;.else&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;同MASM&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当然，选择编译宏的种类十分丰富，这里只是列举常用宏，全部信息可由as使用手册获得。&lt;/p&gt;
&lt;p&gt;最后还需要说明一下AT&amp;amp;T的.fill宏，这个宏在编译期间填充字符，可以用来控制可执行文件的大小，语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.fill repeat, size, value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里暂且不举例，如果有机会说明一下系统引导程序编程，再说明这个指令吧。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(十)-内联汇编</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.-assembler-c-inline/</link>
        <pubDate>Mon, 21 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.-assembler-c-inline/</guid>
        <description>&lt;p&gt;这篇介绍一下c内联汇编的使用，准确的说，内联汇编不算是汇编的语法，而是c/c++的语法，虽然c/c++是有标准参考的，但是不同编译器使用的 汇编不同，导致内联汇编是编译器相关的。这里介绍vc和gcc下c的内联汇编使用，vc使用masm语法，gcc自然是AT&amp;amp;T语法。&lt;/p&gt;
&lt;h1 id=&#34;语法规则&#34;&gt;语法规则&lt;/h1&gt;
&lt;p&gt;一般来讲，MASM的语法规则较多，也比较复杂，不过内联汇编却相当的方便，相反，AT&amp;amp;T的内联汇编语法规非常复杂，这里先介绍简单的MASM内联。&lt;/p&gt;
&lt;p&gt;vc环境下内联汇编语法规则如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__asm statement
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__asm {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	statement-1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	statement-2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	statement-n
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的指令即MASM程序，但是有一些限制如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能使用数据定义伪指令&lt;/li&gt;
&lt;li&gt;不能定义结构等复杂数据类型&lt;/li&gt;
&lt;li&gt;不能使用宏，或宏操作符&lt;/li&gt;
&lt;li&gt;不能引用段名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然这里只是简单的介绍一下，其中的细节只能在实践中体会了，接下来举一个简单的例子来说明内联汇编的使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/** 计算两个参数的积 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;testAssembler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kr&#34;&gt;__asm&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mul&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;testAssembler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kr&#34;&gt;__asm&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;result is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里 testAssembler 函数中使用内联汇编计算了参数的积，调用点并未接受其返回值，因为函数返回值是由eax寄存器返回，则再次使用内联汇编可以取到返回值。&lt;/p&gt;
&lt;p&gt;可以看到MASM内联汇编是十分简单的，接下来看gcc的内联语法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;asm (
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	语句模板
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	: 输出部分
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	: 输入部分
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	: 破坏描述
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;先来说语句模板，这里的语句即为AT&amp;amp;T的基本语法，与MASM不同的是这里不能直接使用局部变量，倒是可以引用全局变量，指 令之间使用&lt;code&gt;;&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\n\t&lt;/code&gt; 分割，后面的部分是可选的，如果只介绍到这里，可如vc一样的方式去使用内联，不过这便损失了gcc更为强大的功能。&lt;/p&gt;
&lt;p&gt;在指令部分除了使用 AT&amp;amp;T标准语法之外，还可以有最多10个占位符：&lt;code&gt;%0&lt;/code&gt;, &lt;code&gt;%1&lt;/code&gt;, &lt;code&gt;…&lt;/code&gt; , &lt;code&gt;%9&lt;/code&gt;，他们出现的次序与操作数相对应，另外，可在%和数字之间插入字符w, h, b分别表示访问操作数中的低字，低字中的高字节和低字中的低字节。这里可能说的比较糊涂，不过没关系，介绍之后的部分自然会明白。&lt;/p&gt;
&lt;p&gt;输出部分指示此内嵌汇编输出结果保存到什么变量中，这些变量通过占位符作为汇编语句中的操作数。当输出列表多于一个变量时，变量之间用逗号隔开，这些变量之间的修饰字符串中必须包含’=&amp;rsquo;，来表示它是一个输出操作数，修饰字符稍微会做详细说明。&lt;/p&gt;
&lt;p&gt;输入部分看名字就知道是做输入之用，语法格式也与输出部分相同，唯一缺少的就是那个修饰的符号&lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;修饰符&#34;&gt;修饰符&lt;/h1&gt;
&lt;p&gt;到这里详细说一下修饰字符，修饰字符很多，这里仅仅介绍常用修饰符。&lt;/p&gt;
&lt;h2 id=&#34;寄存器绑定这类修饰符修饰的变量跟某中寄存器绑定随后的操作中可直接操作相应的寄存器&#34;&gt;寄存器绑定：这类修饰符修饰的变量跟某中寄存器绑定，随后的操作中，可直接操作相应的寄存器。&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;修饰符&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;绑定寄存器&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;a&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;%eax&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;b&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;%ebx&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;c&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;%ecx&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;d&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;%edx&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;S&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;%esi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;D&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;%edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;q&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;eax, ebx, ecx, edx 任意一个&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;r&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;eax, ebx, ecx, edx, esi, edi 任意一个&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;A&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;被修饰是64位变量，要与%eax,%edx联合绑定&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;m&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;不绑定&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另外，如果该寄存器已经被绑定，编译器会在合适的地方push到堆栈，使用之后再回复此寄存器。&lt;/p&gt;
&lt;h2 id=&#34;输出变量修饰&#34;&gt;输出变量修饰&lt;/h2&gt;
&lt;p&gt;除了以上修饰符，还有一些只用于修饰输出变量，简单介绍如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;符号&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;‘&amp;amp;’&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;输出变量不能和输入变量共用同一个寄存器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;‘=’&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;输出变量只写&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;‘+’&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;先将输出变量预先读入到对应寄存器&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;gcc 内联汇编规范最后一个部分是破坏描述，不论做什么操作，基本都需要寄存器的参与，对于只有c代码的程序，编译器保护寄存器不会被不同模块写乱，但是对于内 联汇编，我们可能修改某些寄存器而破坏了gcc原本保护的寄存器，所以内联汇编时我们需要告诉编译器哪些寄存器使我们所需要改变的，这里破坏描述符由逗号 隔开的字符串组成，每个字符串描述一种情况，一般是寄存器名，另外还有”memory”-内存破坏描述符，内存描述符为了将寄存器保存的变量内容及时写回 到内存中去，避免在寄存器中存有多份不同拷贝，与c++关键字volatile类似。&lt;/p&gt;
&lt;p&gt;到这里简要介绍了gcc内联汇编的部分语法，接下来举例说明此用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;asm&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;volatile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;	&lt;span class=&#34;s2&#34;&gt;&amp;#34;movl %1, %0&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n\t&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;					&lt;span class=&#34;s2&#34;&gt;&amp;#34;addl %2, %0&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n\t&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;+a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;result is &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，在语句模板部分出现了占位符，其中 0,1,2 根据变量出现的次数依次为sum, var1, var2，所以，movl %1, %0 表示把var1存入sum，addl %2, %0表示把var2与sum相加结果存入sum，后面描述部分都比较简单，因为addl语句的关系，需要对%0先读其值后计算，所以需要使用描述 符”+”。&lt;/p&gt;
&lt;p&gt;当然，内联汇编只是汇编跟c结合的一种方式，还有一种就是直接把汇编编译成目标文件，再跟c直接链接到一起，这里并没有什么新的东西，仅仅写一个AT&amp;amp;T汇编的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#file Assembler.s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.globl _mulTwo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;_mulTwo:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %esp, %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl 8(%ebp), %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mull 12(%ebp)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %ebp, %esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	popl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ret
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里汇编仅仅实现一个函数，并通过.globl导出符号，这里加下划线的原因是因为Windows的符号规则，之前已有说明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* file testAssembler.c*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/** 由于c必须声明，这里仅仅对汇编函数做一个c声明 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mulTwo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mulTwo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;测试的c代码只需要定义一个汇编的函数声明即可使用。编译命令可以分别编译成目标文件再链接，也可直接使用 gcc testAssembler.c Assembler.s 编译之，对于反过来回调，汇编代码调用c代码，因为之前在汇编结尾已多次使用exit函数，这里便不再举例，同时，MASM语法的原理也相同，仅换了一套 编译命令而已。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(九)-函数</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.-assembler-function/</link>
        <pubDate>Sun, 20 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.-assembler-function/</guid>
        <description>&lt;p&gt;编程语言为了不至于使代码过于庞大，便于管理，都提供了函数的功能，提供输入和输出接口，完成独立的功能，细分代码。汇编语言同样也有函数的概念， 但是这里函数有其本身的复杂性，像高级语言，直接提供声明格式，输入输出便可，而汇编需要透彻的理解堆栈，如果需要与c函数进行交互，还需理解c的堆栈处 理过程，所以此篇最复杂的不是定义一个函数，而是理解堆栈的处理过程。&lt;/p&gt;
&lt;p&gt;首先从基本的函数语法形式说起，先来说MASM语法，因为他的语法比较复杂，相对AT&amp;amp;T就很简单了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name proc [uses reg1 reg2 ...] [,参数:类型]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里函数定义比较简单，唯一有点迷惑的是uses伪指令，因为函数需要做很多操作，这样不免修改某些寄存器，uses伪指令指定该函数 要修改的寄存器，由编译器对其做保护，当然，此项是可选的，不规定一定要把修改的寄存器保护起来。编译器保护寄存器的方式就是在函数开始把reg通过 push指令保存到堆栈，退出时再通过pop反向的取出寄存器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	test_uses proc uses eax ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 编译器再此添加
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; push eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; push ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 编译器再此添加
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; pop ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; pop eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	test_uses endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数声明倒不复杂，先来看参数的传递，传递参数最简单的情况就是通过寄存器，调用点把数据放至寄存器中，到函数中便可直接使用，但寄存 器毕竟数量有限，更为通用的方式就是通过堆栈传输，再调用点先把参数依次传入堆栈（push 指令），函数中便可从堆栈中读取参数，对c函数来讲，参数的入栈顺序是倒序的，也就是最后一个参数先入栈，依次向前。&lt;/p&gt;
&lt;p&gt;调用点调用函数需要指 令：call address，call指令先把接下来要执行的指令（EIP）放入堆栈，紧接着修改EIP的值为address，这样就到address的位置开始执 行，即函数入口。因为函数结束时需要跳转到刚才存入堆栈的EIP地址执行，所以必须有一个指令与call对应，修改EIP的值，那就是ret指令，ret 指令从堆栈中取出返回地址，然后修改EIP为该地址，便可回到调用函数的地址开始往下执行。&lt;/p&gt;
&lt;p&gt;所以，再调用点现在可以写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	push param
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	call function
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，MASM提供了一个方便的指令invoke，语法规则为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	invoke procName, Arg1, Arg2 ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可把函数调用过程简化为 invoke function param，invoke可以让调用汇编像调用c函数一样简单，不过如果需要invoke调用则需先声明，当然如果函数在使用之前定义，则可不进行声明， 这与C语言的语法颇为相似，MASM提供了另一个伪指令proto来声明函数，无需函数体，仅仅规定函数格式，proto语法与proc大致相同，修改 proc到proto也很简单，只需要proc改为proto，去掉uses伪指令，去掉函数体。&lt;/p&gt;
&lt;p&gt;函数的返回值可以以任意方式返回，不过c函数一般是通过eax寄存器返回，如果调用c函数，可直接使用eax得到返回值。&lt;/p&gt;
&lt;p&gt;到这里似乎有了很多的堆栈操作，比如保护寄存器，返回地址，参数，还有局部变量，这里问题是不会发生堆栈的错乱么？这还要通过堆栈的变化来看。&lt;/p&gt;
&lt;p&gt;首先堆栈是从大到小增长的，也就是后push进去的元素在小地址。需要传递参数时，先用push指令把参数入栈，然后用call进行跳转，call指令再把 返回地址入栈，接下来的空间作为局部变量的地址，也就是说以返回地址为分割，小地址方向为局部变量，大地址方向存储参数。但是如果函数中再次调用其他函数 会修改堆栈，这样影响了局部变量的空间，所以再进入函数时，需要把esp减去一定字节数以腾出空间作为局部变量，但是esp本身是随着push指令而变化 的，不能使用esp来寻址参数或者局部变量，一般做法是在函数开始处保存ebp的值，再把esp赋值给ebp作为固定的基址寻址参数，esp减去一定空间 作为局部变量。再函数退出时只需把ebp赋值给esp即可清理一切局部堆栈信息。所以基本的函数框架如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name proc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		push ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ebp, esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		sub esp, 16
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov esp, ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pop ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此，在读取第一个参数时使用语法 [ebp + 8], 第二个参数便是 [ebp + 12]，依次类推，第一个局部变量便是 [ebp - 4], 第二个是 [ebp - 8] 等等。当然这只是规律但不是规定，如果使用uses伪指令再函数开始处增加push指令而改变堆栈，如此的规律便不再适用。&lt;/p&gt;
&lt;p&gt;为了方便理解，这里用一图示来展现函数堆栈的分布，当然这一图示是静态的，难以表示整个函数调用过程中动态增衰的过程，还需更多的思考：&lt;/p&gt;
&lt;p&gt;由图可以清楚的看到堆栈状态，这样我们甚至可以直接修改返回地址为另外一个函数，来改变整个调用的流程！甚至这个过程可以用c语言指针操作来完成，有兴趣的可以一试。&lt;/p&gt;
&lt;p&gt;MASM为了方便参数的读取（不必计算偏移）而制定了参数列表，为了方便局部变量的读取而指令了local指令，语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uses&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reg1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reg2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此，在程序中便可直接使用var来直接引用byte局部变量。&lt;/p&gt;
&lt;p&gt;另外由于函数的开始和结尾都是定式，intel又提供了两个指令来简化操作，enter指令，有两个操作数，第一个位局部变量大小，第二个暂时填写0即可，leave指令无操作数，上面函数框架也可写作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name proc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		enter 16, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 等价于以下三条指令
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; push ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; mov ebp, esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; sub esp, 16
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		leave
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; 等价于一下两条指令
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; mov esp, ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		; pop ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上都是MASM语法形式，当然，大多数的原理性东西也对AT&amp;amp;T语法适用，MASM提供了很多宏去方便程序员适用，从函数调用的invoke伪指令，到参数列表，到局部变量，都做了全副武装。这在AT&amp;amp;T中就没那么幸运了。&lt;/p&gt;
&lt;p&gt;对AT&amp;amp;T汇编来说，函数仅仅是一个符号，跟其他label并没什么不同。定义的语法规则如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.type func_name, @function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	func_name:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里仅仅是对linux适用，如果在mingw下写，发现这样甚至连编译都过不了，其实只要有一个符号即可，.type完全可以不写， 如果要导出函数，可用.globl func_name。另外，AT&amp;amp;T的函数需要自己计算参数的偏移，没有参数列表没有局部声明，也没有invoke调用。这么简陋的设施或许也没 什么可以说明的。&lt;/p&gt;
&lt;p&gt;如果仔细研究堆栈变化，在调用函数的时候先要把参数入栈，然后把返回地址入栈，之后跳到函数入口点执行。这样就产生一个问题，谁应该把压入的参数弹出（即清理堆栈）。&lt;/p&gt;
&lt;p&gt;对于__cdecl函数（c函数）是调用者进行清理，gcc的处理方式是在局部变量的最后多开辟一点空间，然后每次调用函数之前，先把参数赋值给esp的正偏移，这样等函数返回之后就没有必要清理堆栈了。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;__stdcall&lt;/code&gt;函数（Win32 API），清理堆栈的工作需要交给被调用者，也就是说，所有&lt;code&gt;__stdcall&lt;/code&gt;的函数在返回之前使用 ret (n-bype) 清理了参数，如果返回之后再次清理堆栈就会造成堆栈的混乱。&lt;/p&gt;
&lt;p&gt;这里由函数本身清理堆栈时，还用到一个ret指令的变形，可以增加一个操作数来指定堆栈清理的字节数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; MASM
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ret bytes;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; AT&amp;amp;T
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	retn bytes;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，举一个例子简单的说明一下函数的用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		out: .asciz &amp;#34;result is %d\n&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	# 这里定义一个两数相加的例子
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	# 为了说明，先存结果到局部变量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _Function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_Function:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %esp, %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		subl $16, %esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl 8(%ebp), %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		addl 12(%ebp), %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		#存入局部变量位置偏移为 -4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %ebx, -4(%ebp)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl -4(%ebp), %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %ebp, %esp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		popl %ebp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		ret
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_main:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $5
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $9
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _Function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		#结果位于eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		#调用printf输出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $out
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _printf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _exit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里需要注意的是，_Function这个函数符合c编程的规范，也就是说c语言也可直接调用此函数，这种方式再下篇会有提及。对于 MASM，也适用这种写法，不过为了介绍简化过程的伪指令，现把此程序改为由伪指令简化过的形式，注意（enter虽然简化过程，但是intel的指令， 不算伪指令）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;386&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stdcall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;casemap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;none&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;windows&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;kernel32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;includelib&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;includelib&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msvcrt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;outstring&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;result is &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dword&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ebx&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outstring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;n&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ExitProcess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里需要做几点说明，由于.model设定了stdcall，所以proc指定的都会是stdcall函数，即堆栈清理由函数自己执 行，所以Function最终使用ret 8来返回。另外，由于指定了函数Function的参数，编译器会自动生成框架，所以无需使用enter和leave，对于printf，没有使用头文 件，而是自己进行了生命，当然，这里并没有使用可变长参数，仅仅写了两个参数，proto后加了函数的类型为c类型。另外，连接期间无需连接成 windows类型，可用命令&lt;code&gt;link /subsystem:console fun.obj&lt;/code&gt; 来连接成控制台程序。&lt;/p&gt;
&lt;p&gt;本篇主要介绍了函数堆栈变化，这个过程虽然并不复杂，但是要是讲解清晰还是非常困难。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(八)-字符串</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.-assembler-string-instruct/</link>
        <pubDate>Sat, 19 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.-assembler-string-instruct/</guid>
        <description>&lt;p&gt;字符串处理可能是编程语言中最耗时以及最繁琐的操作，比较一个整数只需要比较32位，但是比较字符串却需要循环比较字符串的每一个字符，相关的复制 追加操作则需要很多的内存拷贝操作，可能各种语言都对应有一系列的字串处理库，对汇编来说，当然没有类似的库可用，但是Intel提供了一系列字串处理相 关的指令，可以相对方便的处理字符串。&lt;/p&gt;
&lt;p&gt;先来看几个简单的拷贝操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	;AT&amp;amp;T 语法格式
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movsb 传递一个字节
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movsw 传递两个字节
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movsl 传递四个字节
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为这组操作没有操作数，所以MASM语法相同，但是movsl不同，l在AT&amp;amp;T语言中表示long，是4字节，但是在MASM中，4字节是dword，所以最后一个指令被写做 movsd&lt;/p&gt;
&lt;p&gt;虽说这里movsb没有操作数，但是没有操作数如何拷贝字符？其实这有关字串处理的操作，有两个操作数，源字符串和目标字符串，这里的操作数是隐含操作数，记得寄存器那篇说过，esi为源操作数，edi为目标操作数，所体现的就是这里了。&lt;/p&gt;
&lt;p&gt;另外一个问题是，如果仅仅移动一个字符，mov指令完全可以胜任，那还要movsb干什么呢？的确如此，movsb本身来讲并不见得方便，但是结合一个指令前缀rep，就不同了。&lt;/p&gt;
&lt;p&gt;rep是一个指令前缀，就是再其他指令之前表示一种特性，rep为repeat，重复之意，就是他可以不停的执行，直到ecx为0，与之相关的还有两个指令，一起总结如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;rep&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ecx &amp;gt; 0时重复&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;repz/repe&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;零标志置位 并且 ecx &amp;gt; 0时重复&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;repnz/repne&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;零标志为清零 并且 ecx &amp;gt; 0时重复&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果还记得loop和loopz指令，应该熟悉汇编中的这种后缀规律。&lt;/p&gt;
&lt;p&gt;如果movsb能够重复执行，那另外一个问题就出来了，重复复制一个字节有什么意思呢？其实movsb指令不单复制，同时还修改esi和edi的值。至于如何修改，是加还是减，需要看DF标志，方向标识。当DF清零，则esi和edi递增；反之递减。&lt;/p&gt;
&lt;p&gt;为了方便操作DF标志，Intel还专门提供了两个清零和置位的指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cld 	DF 清零 	esi 和 edi 递增
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std 	DF 置位 	esi 和 edi 递减
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与这两个指令相类似的还有cli, sti来控制中断标志，clc, stc控制CF标志，其中的规律一看便知。&lt;/p&gt;
&lt;p&gt;回头来看字串的复制步骤，先填充源目的寄存器，再用cld/std设置方向，之后设置ecx控制循环次数，再rep movsb即可。
现举一个memcpy函数的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	char src[100] = &amp;#34;test data&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	char dest[100];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		memcpy(dest, src, 100);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对应的MASM语法格式的汇编如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	src	db &amp;#34;test data&amp;#34;, 91 dup(0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dest db 100 dup(0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cld
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov esi, offset src
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov edi, offset dest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, 100
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		rep movsb
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里代码很少，操作也非常明了，对于AT&amp;amp;T语法，这里就不单写一个了，不过，从原理上讲，不管是AT&amp;amp;T还是 MASM语法，最终都得编译成intel cpu可以识别的机器码，所以我们把这段MASM写成的程序用AT&amp;amp;T语法的反汇编器反汇编即可得到AT&amp;amp;T的写法，Ollydbg 2.0 可以反汇编程序到多种汇编语法，不过我感觉翻译AT&amp;amp;T翻译的不大好看，还是使用gcc套件里的工具吧，这个工具是objdump，参数-D 为反汇编参数，直接使用命令行 objdump -D strcpy.exe 即可输出AT&amp;amp;T语法的汇编，这里简单摘要一些：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401000:       fc                      cld
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401001:       be 00 30 40 00          mov    $0x403000,%esi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401006:       bf 64 30 40 00          mov    $0x403064,%edi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	40100b:       b9 64 00 00 00          mov    $0x64,%ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401010:       f3 a4                   rep movsb %ds:(%esi),%es:(%edi)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401012:       6a 00                   push   $0x0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	401014:       e8 01 00 00 00          call   0x40101a
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中大致流程还是看的很清楚的。&lt;/p&gt;
&lt;p&gt;介绍了这么多，仅仅只介绍了一个字符拷贝命令movsb，其他的一些诸如比较、加载的指令，但是其他指令与movsb类似，没有什么难点，这里仅仅做一些列举：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;操作&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;源操作数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;目的操作数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;lodsb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;加载字节&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;esi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;al&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;lodsw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;加载双字节&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;esi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ax&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;lodsl(MASM lodsd)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;加载四字节&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;esi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;eax&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;stosb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;保存字节到目的&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;al&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;stosw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;保存双字节到目的&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ax&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;stosl(MASM stosd)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;保存四字节到目的&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;eax&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;cmpsb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较字节&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;esi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;cmpsw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较双字节&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;esi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;cmpsl(MASM cmpsd)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较四字节&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;esi&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;scasb&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较内存和AL&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;al&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;scasw&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较内存和AX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ax&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;scasl(MASM scasd)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比较内存和EAX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;eax&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;edi&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里举一个简单的strlen例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;test data&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对应的MASM汇编如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	string	db &amp;#34;test data&amp;#34;, 91 dup(0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	len dd 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cld
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov edi, offset string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov al, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, 100
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		repne scasb
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		sub ecx, 100
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		neg ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		dec ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov len, ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里把al设置为0，使用scasb指令，即在edi指向的字符中查找0，找到以后ecx所减少的数字就是移动的次数，注意其中是包含0的，最后经过运算便可得到字串长度。&lt;/p&gt;
&lt;p&gt;使用此类指令操作字符串，比用c语言好的地方是不需要循环，这个再之前提到，由于预载入指令的问题，如果进行跳转（循环）将会是一件很损耗效率的事情，使用此类指令可以避免这个问题。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(七)-寻址方式</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.-assembler-addressing-method/</link>
        <pubDate>Fri, 18 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.-assembler-addressing-method/</guid>
        <description>&lt;p&gt;寻址一直以来都是汇编中的关键内容，但是在平坦内存模式下，汇编寻址的难度降低很多，不过Intel CPU必须经历段式内存模式后才可到达页式存储，所以如果系统底层编程，也可能会涉及到实模式下的程序设计，需要掌握段式寻址。&lt;/p&gt;
&lt;p&gt;对于实模式，处理器可以寻址20位的地址空间，但是寄存器只有16位，为了能达到20位的寻址，需要使用 段：偏移 这样的方式寻址，格式为 &lt;code&gt;segreg:offset&lt;/code&gt;，计算出的直接偏移地址为 &lt;code&gt;segreg * 16 + offset&lt;/code&gt;，相当于段基址左移4位后加上偏移，这样刚好有20位的地址，可以达到2M内存寻址。
在平坦内存模式下，寻址类似于c的指针，一个基址加上偏移。&lt;/p&gt;
&lt;p&gt;对AT&amp;amp;T来说，寻址方式比较怪异，但又非常简洁，语法格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	segreg:base_address(offset_address, index, size)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	;例子
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %eax, label1(, $2, $4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %ebx, (label2, $2,)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl %ecx, (%esp)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其效果为 &lt;code&gt;segreg:base_address + offset_address + index * size&lt;/code&gt;
segreg为分段模式下段寄存器，&lt;code&gt;base_address&lt;/code&gt;为基址，&lt;code&gt;offset_address&lt;/code&gt; 为偏移，&lt;code&gt;index * size&lt;/code&gt;决定了第几个元素，其中size为元素长度，只能为1,2,4,8等等，这些元素都是可选的，index默认为0，size默认为1。&lt;/p&gt;
&lt;p&gt;对于MASM，表达相同含义的语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	segreg:[base_address + index * scale + offset_address]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	;例子
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov label1[2 * 4], eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov [label2 + 2], ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov [esp], ecx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对MASM，有些指令并不知道寻址以后是该取1字节还是多字节，也就是说需要制定寻址以后数据的长度，这个长度可由ptr操作符声明，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movzx eax, word ptr [base + 2];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样指定在base + 2地址处读取word宽度字节。而在AT&amp;amp;T中，由于指令可跟w,l等后缀，无需再次指令，这里可以看到AT&amp;amp;T简洁之处。&lt;/p&gt;
&lt;p&gt;另外，对AT&amp;amp;T，如果需要取全局符号的地址，可以使用$var（见框架），对于MASM，还需另外一个操作符：offset，相同的功能可写为offset var。当然也可使用lea指令，lea指令为取地址指令，语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;lea&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里跟offset的区别在于，offset在编译期间可以指定全局变量的位置，无需运行时计算，但是offset无法取得局部变量的 地址，因为局部变量位于堆栈，是在运行时才可得知其地址，而lea指令与之相反，是在运行时计算变量（可为全局和局部变量）的地址，二者的另一个区别在于 lea为cpu指令，AT&amp;amp;T同样有与之对应的指令（同其他指令一样，操作数相反，且指令可跟长度后缀），而offset仅仅为编译器指令，编译 成机器码之后只有一个地址，没有offset的影子。&lt;/p&gt;
&lt;p&gt;下面举一个简单的例子，仍然是翻译c代码到汇编：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	void swap(int * a, int * b)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int tmp = *a;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		*a = *b;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		*b = tmp;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int a[10] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 0};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		for (int i = 0; i &amp;lt; 10; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			for (int j = i; j &amp;lt; 10; ++j)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;				if (a[i] &amp;gt; a[j])
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;					swap(a + i, a + j);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里c代码是一个效率比较低的排序，我们改写成AT&amp;amp;T汇编 sort.s ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		array: .int 1, 3, 5, 7, 9, 2, 4, 6, 8, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_main:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		xorl %eax, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %eax, %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl array(, %ebx, 4), %ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmpl %ecx, array(, %eax, 4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jbe label1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		xchg %ecx, array(, %eax, 4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movl %ecx, array(, %ebx, 4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		incl %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmpl $10, %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		incl %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmpl $10, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _exit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的代码并不复杂，loop1, 和loop2为两个循环，之间的操作与c的含义相同，这里不做解释，其中的诸多细节需要细细体会，这里再给出MASM的一个版本，完全是从AT&amp;amp;T版本直译过来的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	array	dd 1, 3, 5, 7, 9, 2, 4, 6, 8, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    xor eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ebx, eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, array[ebx * 4]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp array[eax * 4], ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jbe label1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		xchg ecx, array[eax * 4]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov array[ebx * 4], ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		inc ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp ebx, 10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		inc eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp eax, 10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jb loop1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label2:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里可以充分看出AT&amp;amp;T和MASM的语言的不同之处。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(六)-数学运算</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.-assembler-math-instruct/</link>
        <pubDate>Thu, 17 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.-assembler-math-instruct/</guid>
        <description>&lt;p&gt;在上面几篇已经提到了一些数学运算功能，这篇再详细介绍之，数学运算无非是一些加减乘除，移位等等，就是这些简单的操作造就了丰富多彩的程序世界，可以说程序的根本就是计算。&lt;/p&gt;
&lt;h1 id=&#34;指令介绍&#34;&gt;指令介绍&lt;/h1&gt;
&lt;h2 id=&#34;加减法&#34;&gt;加减法&lt;/h2&gt;
&lt;p&gt;首先说加减法，其实加减法本身没什么好说，但是还是跟mov指令一样，AT&amp;amp;T和MASM语法的操作数相反，造成了混乱。对AT&amp;amp;T来说：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	addx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	subx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中x为操作数长度，与mov相同，这里的含义相当于 destination += source; 和 destination -= source&lt;/p&gt;
&lt;p&gt;对MASM来说，语法格式为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	add destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sub destination, source
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;add 和 sub 指令都会影响进位，零标志，符号标志，溢出标识辅助进位和奇偶标志，方便使用条件控制。&lt;/p&gt;
&lt;p&gt;inc和dec指令分别对寄存器或内存进行加一和减一操作，对于AT&amp;amp;T的指令，需要增加操作数长度指令b,l,w,q等，格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	inc operand
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dec operand
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;相反数&#34;&gt;相反数&lt;/h2&gt;
&lt;p&gt;neg 指令求寄存器和内存的相反数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	neg reg
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	neg mem
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进位加减法，adc和sbb，这两个指令的格式与add和sub完全相同，所不同的是adc把源操作数，目的操作数和进位标识相加。sbb同样也减去进位标识，这两个指令的存在主要是为了进行大整数运算。&lt;/p&gt;
&lt;h2 id=&#34;乘法&#34;&gt;乘法&lt;/h2&gt;
&lt;p&gt;乘法mul，imul:
其中mul为无符号乘法，乘法的格式也比较简单，而imul为有符号乘法， 却有三种语法格式。语法如下：&lt;/p&gt;
&lt;p&gt;以下是AT&amp;amp;T语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul imm, source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下是MASM语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	imul destination, source, imm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到mul只有源操作数，那目的操作数呢？其实这里是隐含操作数。mul的操作数如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;被乘数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;乘数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;积&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;AL&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;r/m8&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;AX&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;AX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;r/m16&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;DX:AX&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EAX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;r/m32&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EDX:EAX&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;最所以积比被乘数宽度大一倍，是因为两个32位的乘数乘起来可能是64位的！&lt;/p&gt;
&lt;p&gt;除法div，idiv
除法与乘法相反，mul的操作数表反过来便是div的操作数表，如下表所示：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;被除数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;除数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;商&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;余数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;AX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;r/m8&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;AL&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;AH&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;DX:AX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;r/m16&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;AX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;DX&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EDX:EAX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;r/m32&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EAX&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;EDX&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里跟乘法不同的是64位的操作数除以32位的操作数以后结果还可能大于32位，如此一来便会溢出，所以计算除法要千万小心，确保你的操作数不会出现溢出问题。
语法格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; 因为只有一个操作数，所以AT&amp;amp;T语法格式和MASM相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	div divisor
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	div divisor
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;移位运算&#34;&gt;移位运算&lt;/h2&gt;
&lt;p&gt;先说一下算术移位和逻辑移位，二者对于左移来说没有什么区别，都是在空位上补0，但对于右移，对于无符号的应该补零，对于有符号的应该补符号位，所以就有了算术和逻辑，算术右移补符号位，一般用于有符号数，逻辑右移不论符号位是什么，一律补0。&lt;/p&gt;
&lt;p&gt;循环移位，比如左移，先把所有位向左移一位，把最高位补到最低位的空缺，顺便把CF标志设置为最高位的值。
带进位的循环移位，跟循环移位相比，循环移位CF本身不参与移位，仅仅是记录最高位的值，而带进位的循环移位CF标志也参与移位，即CF放入对地位，高位填充至CF标志。&lt;/p&gt;
&lt;p&gt;还有一种移位为双精度移位，拿左移为例，改指令把目的操作数左移指定的位数，左移空出来的位用源操作数的高位来填充，源操作数不变，相当于循环移位但是是对不同的操作数来讲的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shl 	逻辑左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shr 	逻辑右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sal 	算术左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sar 	算术右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rol 	循环左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ror 	循环右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rcl 	带进位循环左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rcr 	带进位循环右移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shld 	双精度左移
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shrd 	双精度右移
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下是各种语法规则(imm8为8位立即数）&lt;/p&gt;
&lt;p&gt;以下是AT&amp;amp;T语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; shl shr sal sar rol ror rcl rcr 指令格式相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shlx destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shlx imm8, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shlx %cl, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下是MASM语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; shl shr sal sar rol ror rcl rcr 指令格式相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shl destination, imm8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shl destination, cl
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; shld shrd 格式相同
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	shld destination, source, cl/imm8
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;与或非运算&#34;&gt;与或非运算&lt;/h2&gt;
&lt;p&gt;对AT&amp;amp;T语法格式 x位操作数宽度&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	andx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	orx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	xorx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	notx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;MASM 语法格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	and destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	or destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	xor destination, source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	not reg/mem
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;test指令&#34;&gt;test指令&lt;/h2&gt;
&lt;p&gt;test 指令与 and 指令相同，不过test指令不改变操作数的值，仅仅置eflags标志。&lt;/p&gt;
&lt;h2 id=&#34;cmp指令&#34;&gt;cmp指令&lt;/h2&gt;
&lt;p&gt;cmp 指令与 sub 指令相同，唯一的区别是cmp只置标记不保存结果，也就是cmp操作的源、目的操作数不变。&lt;/p&gt;
&lt;h1 id=&#34;例子&#34;&gt;例子&lt;/h1&gt;
&lt;p&gt;这里由于指令过多，而且写的比较匆忙，没有一一举例，仅仅做了一个简单总结，我的一位挚友对此文每种指令都做了尝试，并指出一些错误，在次表示感谢！以下测试代码由这位挚友提供，由于没有输出，可由ollydbg调试观察结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;.386&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.model&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;flat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;stdcall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;casemap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;none&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;windows.inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;include&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;kernel32.inc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;includelib&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;kernel32.lib&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;res2&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dw&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;res3&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dd&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;start:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;sub&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;inc&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;dec&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;neg&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;单操作数乘法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;al&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;;被乘数根据位数不同分别默认存放于al(8)、ax(16)、eax(32)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ah&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mul&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ah&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;;积根据位数不同分别默认存放于ax(16)、dx:ax(32)、edx:eax(64)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;c1&#34;&gt;;32位积为什么不能直接存放于eax中呢？是因为刚开始计算机只有16位所以就按这种高位低位的方式来存放
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;c1&#34;&gt;;后面发展成为32位后为了保持兼容性故还是这样存放
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;双操作数乘法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;imul&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;三操作数乘法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;imul&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;;所谓三操作数就是在最后多乘了一个立即数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;除法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;33&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;bx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;div&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;bx&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;al&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;;商
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ah&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;;余数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;移位运算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;shl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;shr&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;sal&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;sar&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;rol&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;ror&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;rcl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;rcr&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;此指令前两个寄存器必须是大于8位的，左边操作数可以是内存，最后一个必须为8位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;shld&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;shrd&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;逻辑运算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;ffffh&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;xor&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;c1&#34;&gt;;test, cmp指令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;jz&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;label1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label1:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;inc&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;res2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label2:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;nf&#34;&gt;invoke&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ExitProcess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;start&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>汇编语言学习笔记(五)-控制流</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.-assembler-control-flow/</link>
        <pubDate>Wed, 16 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.-assembler-control-flow/</guid>
        <description>&lt;p&gt;程序不可能一顺到底的执行，需要有一些分支流程控制的语法，对高级语言来讲，有分支循环等，对于汇编，有一个“跳”，或者选择性跳，跳转指令本身非常简单，仅仅一个jmp指令，类似于c语言的goto，语法为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		jmp label
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;跳转分为段跳转（小于128字节），远跳转（分段模式下跨段跳转），近跳转（其他），不过这些在AT&amp;amp;T里编译器会根据参数的 变化而选择性的生成机器码，但对于MASM，需要自己指定，&lt;code&gt;jmp near ptr label&lt;/code&gt;, &lt;code&gt;jmp far ptr label&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但本质上讲，倘若只有这样的jmp，那不论如何跳都将是个死循环，所以便有了条件跳转（Jcond），在一定条件下进行跳转，这里所谓的条件，仍然是eflags的不同标记位，如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;跳转条件&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;eflags标志&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JA&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if above&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=0 &amp;amp; ZF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JAE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if above or equal&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JB&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if below&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JBE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if below or equal&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=1 or ZF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JC&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if carry&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JCXZ&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if CX=0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;register CX=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;(is the same as JZ) Jump if equal&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JG&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if greater (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=0 &amp;amp; SF=OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JGE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if greater or equal (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SF=OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JL&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if less (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SF != OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JLE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if less or equal (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=1 or SF!=OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JMP&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Unconditional Jump&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNA&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not above&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=1 or ZF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNAE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not above or equal&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNB&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not below&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNBE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not below or equal&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=1 &amp;amp; ZF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNC&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not carry&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not equal&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNG&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not greater (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=1 or SF!=OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNGE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not greater or equal (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SF!=OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNL&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not less (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SF=OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNLE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not less or equal (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=0 &amp;amp; SF=OF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNO&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not overflow (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;OF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNP&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if no parity&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;PF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNS&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not signed (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JNZ&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if not zero&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JO&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if overflow (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;OF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JP&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if parity&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;PF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JPE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if parity even&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;PF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JPO&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if paity odd&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;PF=0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JS&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if signed (signed)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SF=1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;JZ&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Jump if zero&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;ZF=1&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;根据上次的规律很容易理解，这里我们举几个例子，把c语言的流程控制语句转化为汇编：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对应的汇编语言写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nl&#34;&gt;sum:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.int&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nl&#34;&gt;num:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.int&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.globl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;_main:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;cmpl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;num&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;jbe&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;label1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;incl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;num&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label1:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;movl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label2:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;addl&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;incl&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;cmp&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%eax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;jb&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;label2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label3:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;pushl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_exit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译使用&lt;code&gt;gcc hello.s -g&lt;/code&gt;，加上调试信息，之后使用gdb调试，这里直接使用&lt;code&gt;br label3&lt;/code&gt;在&lt;code&gt;label3&lt;/code&gt;处下断，然后&lt;code&gt;print sum&lt;/code&gt;打印信息查看结果。&lt;/p&gt;
&lt;p&gt;这段程序开始 &lt;code&gt;cmpl $10, num&lt;/code&gt;，比较num和10，jbe跳转，相当于&lt;code&gt;if (num &amp;gt; 10)&lt;/code&gt; 部分，incl把操作数加一。&lt;/p&gt;
&lt;p&gt;对于for循环比较麻烦，这里把eax寄存器当做循环计数，先初始化eax为0，紧接着调用addl %eax, sum把eax加到sum上，再把eax加一，后面的比较就与if相同了，如果小于则跳转到label2。&lt;/p&gt;
&lt;p&gt;汇编中还有一类分支结构，就是循环loop，有三种形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loop 循环到ecx为0，每次循环ecx减一
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loope/loopz 循环到ecx为0或者没有设置ZF标志
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	loopne/loopnz 循环到ecx为0，或者设置了ZF标志
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还记得在寄存器那里提到，ecx被用作循环计数器，全部体现在这里了。loop本质上讲每次先把ecx减一，如果不为零则跳转到label，通过实现上面的for循环，很容易理解loop的使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		sum dd 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov ecx, 9;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	label1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		add sum, ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		loop label1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然准确的从逻辑上讲其实这样是少一个循环的，不过最后一次加的是0，忽略掉吧。
注意这里loop是先把ecx减一后判断是否为0，如果ecx开始为0，则不会停止，ecx直接溢出，被减成负数。&lt;/p&gt;
&lt;p&gt;在学习汇编时，可以多参阅编译器生成的汇编代码，用编译器gcc -S，便可生成汇编代码，也可使用不同的优化参数-O1 -O3优化生成的汇编，这样一来可以更好的学习汇编，而来可以理解c和汇编的对应关系，方便阅读反汇编代码。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(四)-MOV指令</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.-assembler-mov-instruct/</link>
        <pubDate>Tue, 15 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.-assembler-mov-instruct/</guid>
        <description>&lt;p&gt;汇编语言和高级语言不通，需要清晰掌握数据存储和机器相关的大量细节，高级语言会自动处理很多赋值的细节，有时甚至都不知道编译器给我创建了多少变 量，赋值了几次，但在汇编里，一切都变得很清晰了，你需要自己处理每个赋值的细节，这是通过mov指令实现，在汇编里，几乎有一半多的代码都是mov。&lt;/p&gt;
&lt;p&gt;对于AT&amp;amp;T和MASM两种语法，最大的差别就从此开始了，因为二者的源、目的操作数是相反的！&lt;/p&gt;
&lt;p&gt;在AT&amp;amp;T里mov的语法结构为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movx source, destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中x为操作数的宽度，有l，w，b，q等，例如movl操作数的宽度为32位，movb操作数宽度为8位，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl $0, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	movl $0, %al
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里另一个不同是寄存器的写法，在AT&amp;amp;T里使用寄存器要在寄存器前加%符号，在MASM中则不用。另外MASM可以自动识别操作数大小，如果有些仅仅传入内存，无法识别操作数大小，则必须使用 dword ptr[] 语法，这里在寻址部分会有涉及。&lt;/p&gt;
&lt;p&gt;在MASM中，mov语言的规则为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov destination, source
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里千万注意二者的操作数是相反的！&lt;/p&gt;
&lt;p&gt;对于MOV指令还有一些规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个操作数尺寸必须相同&lt;/li&gt;
&lt;li&gt;两个操作数不可同为内存&lt;/li&gt;
&lt;li&gt;目的操作数不可为CS，EIP和IP&lt;/li&gt;
&lt;li&gt;立即数不可直接传送至段寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些规则对AT&amp;amp;T语法也同样适用，why？因为二者编译都会编译成相同的二进制代码，这些规则是cpu的规则，而不是某种语法的规则。&lt;/p&gt;
&lt;p&gt;以上说的是基本的mov指令，另外为了方便或者效率，还有些相应的扩展指令：
扩展移动，因为mov指令的操作数大小必须相同，所以如果需要把一个较小值ax移动到较大值ebx中，则需要两步：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov ebx, 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov bx, ax
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果ax为负数，需要把ebx高位扩展为全1，mov ebx, FFFFFFFFh，好在intel支持了相关的扩展指令，movzx和movsx
movzx为零扩展，即高位补零，movsx为符号扩展，即高位补符号位，一般有符号数适用movsx。此指令目标操作数必须为寄存器，源操作数可以为内存和寄存器。
写一个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		num1: .byte 0x12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		num2: .byte 0xf2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.section .text
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.globl _main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	_main:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov num1, %al
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movzx num1, %eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movsx num1, %ebx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movzx num2, %ecx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		movsx num2, %edx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		pushl $0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		call _exit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译时使用 &lt;code&gt;gcc -g hello.s -o hello&lt;/code&gt; 加入调试信息，便于调试，然后使用命令 &lt;code&gt;gdb a.exe&lt;/code&gt; 调试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	br main // 在main函数出下断点
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	r // 执行程序
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	n // 单步运行至 pushl $0 处
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	info register // 查看寄存器信息
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	eax 0×12 18
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ecx 0xf2 242
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	edx 0xfffffff2 -14
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ebx 0×12 18
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显示所有寄存器的信息，可以看到，eax和ebx都是0×12，因为num1高位是0，所以无论使用哪种方式都是高位补零，num2符号位为1，如此在使用movzx时高位补零，但是使用movsx时高位为符号位，补0，所以edx的最后结果为0xfffffff2。&lt;/p&gt;
&lt;p&gt;这里示例了AT&amp;amp;T语法，对于MASM二者的用法相同，除了操作数的顺序。&lt;/p&gt;
&lt;p&gt;mov 的另外一种变形是cmovx形式，涉及到cpu流水线的问题，cpu的eip寄存器指向当前执行的指令，但这个指令如果每次用到再从内存中读取，速度会有 所限制，于是cpu使用流水线方式，会对指令进行预读取，就是先读一定量的指令到队列中，每次都从此队列中读取，这样会加快执行速度，但是一旦遇到跳转指 令，cpu在运行到此处时并不知道程序将会走哪个分支，如此，到达跳转部分，将会有可能清空队列中所有指令，再次读取另一分支，损耗cpu执行指令的效 率，当然，cpu后来加入了乱序引擎，但是还是尽量减少跳转为上。对于一些简单的跳转移动数据，比如比较大小后决定是否赋值，使用cmovx形式便可不进 行跳转而完成这个过程。&lt;/p&gt;
&lt;p&gt;例如对于c语言的一段分支代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	if (a &amp;gt; b)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		max = a;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现用汇编改写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.686
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value1 dd 4321h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value2 dd 1234h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	max dd ?
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov eax, value1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmp eax, value2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cmovb eax, value2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		mov max, eax
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里要说明的是.686模式，如果使用.386模式编译会错误，说cmovb对目前的cpu模式不支持，从start开始，第一句 mov eax, value1 把value1赋值给eax寄存器，cmp比较eax和value2的大小，实际上做了一个eax-value2的操作，但是舍弃结果。如果eax小于 value2，则eflag寄存器的CF位被设置（参考寄存器），cmovb指令是CF=1时移动数据，否则不做操作。这样eax中即为大数，直接移动到 max内存中。&lt;/p&gt;
&lt;p&gt;这样程序看不到最终的效果，还需要调试器的帮助，在Windows平台，比较方便的动态调试工具为Ollydbg，打开 Ollydbg后文件-&amp;gt;打开cmov.exe，如此便可在代码窗口看到刚才写的指令，可以在push 0处设置断点，运行便可在右侧寄存器窗口看到结果。其使用方式与VC大致相同。&lt;/p&gt;
&lt;p&gt;另外从调试过程中，我们也可看到invoke ExitProcess, NULL被编译成push和call指令，与AT&amp;amp;T的写法相同，invoke仅仅是为了简化函数调用的写法而已。&lt;/p&gt;
&lt;p&gt;另外cmovx是一系列函数，都是根据eflag寄存器的不同标志来决定是否移动数据，其中的细节可参考Intel手册卷2A，这里简单列举一些情形以及条件：&lt;/p&gt;
&lt;p&gt;对于无符号型比较&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmova / cmovnbe &amp;gt; 赋值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovae / cmovnb &amp;gt;=
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovnc 无进位赋值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovb / cmovnae &amp;lt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovc 进位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovbe / cmovna cmove / cmovz = 或 为0 赋值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovne / cmovnz 不等于 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于有符号类型&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	:::nasm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovge / cmovnl &amp;gt;=
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovl / cmovnge &amp;lt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovle /cmovng cmovo 溢出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovno 未溢出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovs 结果带符号（负数）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cmovns 无符号（非负数） 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里乍一看，如此之多的情形，还只是其中一部分，不过稍微细心观察，这里的规律还是很明显的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	a表示above，无符号大于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	b表示blow，无符号小于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	e表示equal，等于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	n表示not，不等于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	g表示great，有符号大于
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	l表示less，有符号小于 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;掌握其中规律，记住这些指令并不是难事，而且这些规律在汇编指令中是用过的，不如以后将会看到的条件跳转指令，也是如此。&lt;/p&gt;
&lt;p&gt;到这里mov指令介绍完了，但是移动数据的指令还有很多，这里也顺便做一些归纳，简单列举几类指令，对于AT&amp;amp;T和MASM都是通用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;xchg 指令：
格式 xchg operand1, operand2 ，交换operand1和operand2两个操作数的值，但千万别以为这个指令很方便，因为这个指令操作时会对内存加锁LOCK，可能会非常耗时，所以请慎用。这里两个操作数不能同为内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bswap 指令：
格式 bswap operand , 其中operand为32位或64位寄存器，这个指令时反转字节指令，即可以让32位寄存器的4个字节数据反转，可以方便的转换大小端数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lahf 和 sahf 指令：
lahf指令将eflags寄存器的低字节复制到ah寄存器，sahf把ah寄存器的值复制到eflags寄存器的低字节，ah为隐含操作数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push 指令:
把一个16位、32位、64位数据（寄存器，立即数，内存）到堆栈，esp指针做相应修改。这里AT&amp;amp;T指令必须自己指定大小，加后缀l, w等，与mov指令相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 指令:
出栈，与push相反。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有pop和push的批量操作指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pusha/popa 全部16位通用寄存器入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushad/popad 全部32位通用寄存器入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushf/popf eflags寄存器低16位入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	pushfd/popfd eflags寄存器全32位入栈/出栈
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到这里介绍了常用的数据移动指令，当然这里不可能一一详细介绍，其中的细节还需要参考Intel手册卷2(A,B)。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(三)-数据结构</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.-assembler-datastruct/</link>
        <pubDate>Mon, 14 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.-assembler-datastruct/</guid>
        <description>&lt;p&gt;其实对于cpu来说，本没有什么类型之分，仅是一些内存，至于是什么，看你怎么去计算它们了，汇编是与机器码一一对应的，但是还是有些许区别，汇编毕竟还需要编译连接，为了给人使用方便，还是定义了不少数据类型（也有汇编除外，比如NASM，完全是对内存的操作）。&lt;/p&gt;
&lt;p&gt;对AT&amp;amp;T汇编来说，仅仅有几种基本类型，上篇介绍编程框架时已经有所涉及：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.ascii —— 字符串，但是无\0结尾
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.asciz —— 字符串，自动加入\0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.byte —— 8位数据
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.double ——　双精度64位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.float —— 单精度32位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.int —— 整数32位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.long —— 长整数32位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.octa —— 16字节整数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.quad —— 8字节整数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.short —— 短整型16位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.single —— 单精度，同.float
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这些基本数据类型时，可以用标号命名，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label1:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.ascii&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;test data\0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;label2:&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;.byte&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样便可使用label2直接引用12这块内存，当然要取12这块内存的地址应使用$label2&lt;/p&gt;
&lt;p&gt;另外，还有一些有关符号的命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.equ&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;factor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是定义常量，定义factor为3，如果还记得上一篇的内容，如果想使用此标号，应该写为 $factor&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.comm&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;symbol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;length&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里定义在.bss段，表示在symbol处分配length长度的空间，通用符号&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.lcomm&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;symbol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;length&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里定义在.bss段，表示sysmol处将会分配有length长度的空间，不过符号只能在本文件内使用&lt;/p&gt;
&lt;p&gt;对比MASM，数据类型要复杂的多，甚至有高级语言所谓的结构体。&lt;/p&gt;
&lt;p&gt;先说其基本类型及其相应的简写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	byte 8位无符号 简写db
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sbyte 8位有符号
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	word 16位无符号 简写dw
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sword 16位有符号
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	dword 32位无符号 简写dd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	sdword 32位有符号
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	fword 48位整数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	qword 64位整数 简写dq
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	tbyte 80位整数 简写dt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	read4 32位IEEE短实数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	real8 64位IEEE长实数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	real10 80位IEEE扩展精度
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义变量时格式为：
[name] 指令 初始值 [,初始值 &amp;hellip;]
例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value1 byte &amp;#39;A&amp;#39;, &amp;#39;b&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value2 dd 12345678h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	value3 byte &amp;#34;This is a string&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中数字后加h位16进制数字，在初始值处也可使用num dup(value)来创建num个value值。&lt;/p&gt;
&lt;p&gt;另外MASM中定义常量也需要equ指令，但是用法却与gas语法不同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name equ expression
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name equ symbol
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name equ
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外还有指令 textequ，可以被重定义&lt;/p&gt;
&lt;p&gt;另外MASM高级数据类型还有结构，结构其实是基本类型的组合，定义的基本格式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name struct
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name type initial_value
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name ends
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中初始化数据定义结构成员默认值，可写?表示未定义。&lt;/p&gt;
&lt;p&gt;在初始化结构体时，可使用&amp;lt;&amp;gt;构建初始化列表，若为空则结构初始化为定义的默认值。
例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; Post结构定义
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Post struct
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		IdNum	byte &amp;#34;123456&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		Time	dw	?
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		Content	byte 1024 dup(&amp;#39;A&amp;#39;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Post ends
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; Post对象声明
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No1	Post &amp;lt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No2 Post 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No3 Post 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	No4 Post 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	; 使用变量时与c无异
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	mov Post.Time, eax
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，结构体内仍可嵌套其他结构体，Masm32在 windows.inc 头文件中定义了Win32 API结构和函数。&lt;/p&gt;
&lt;p&gt;还有一种高级结构为联合，语法声明为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name union
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	union-fields
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	name ends
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 union-fields 部分与结构完全相同，这里不再赘述。&lt;/p&gt;
&lt;p&gt;这 里介绍了AT&amp;amp;T的MASM语法的数据类型部分，程序=数据+算法，数据类型并不很难，却是程序的一个重要组成部分。从这里可以看到AT&amp;amp;T数据类型十分之少，没有结构体等高级概念，当然这样定义变量时也不需要事先声明，对他来说，每个变量仅仅是一个地址，如果需要操作结构，还需我 们自己计算结构的偏移；而MASM相对方便了很多，有点类似高级语言的味道，当然语法规则也更为繁琐。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(二)-代码框架</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.-assembler-framework/</link>
        <pubDate>Sun, 13 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.-assembler-framework/</guid>
        <description>&lt;p&gt;前面总结了一下普通寄存器的知识，这里绍下汇编程序的基本框架。&lt;/p&gt;
&lt;h1 id=&#34;gas语法框架&#34;&gt;GAS语法框架&lt;/h1&gt;
&lt;p&gt;程序员学习语言都是从&lt;code&gt;hello world&lt;/code&gt;开始的，这样能快速展示一个能运行的完整程序，对语言有个直观的理解。首先说一下环境配置，对于linux程序，无需过多的配置，只需要 有gcc编译环境即可，调试时需要使用gdb，另外，由于AT&amp;amp;T汇编的跨平台性，在Windows系统下可以使用MinGW编译器，具备gcc 的全套功能，但是毕竟与纯粹的linux平台还是有些差别，为了使用AT&amp;amp;T和MASM两种语言方便切换，这里将使用MinGW编译器介绍，并且 将说明与Linux环境的差别。&lt;/p&gt;
&lt;p&gt;下面看一下&lt;code&gt;hello world&lt;/code&gt;程序，因为GAS汇编文件以.s后缀，所以文件名定为hello.s：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gas&#34; data-lang=&#34;gas&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;out_text:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;na&#34;&gt;.asciz&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello world\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;na&#34;&gt;.globl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nl&#34;&gt;_main:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;pushl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$out_text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_printf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;pushl&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;$0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_exit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了方便输出，忽略程序细节，其中引用了c函数库，可以使用 &lt;code&gt;gcc hello.s -o hello&lt;/code&gt; 来编译此程序，运行hello后输出hello world字串。&lt;/p&gt;
&lt;p&gt;至 此完成了最为简单的程序，从main开始，先调用printf输出out_text处的字串，之后调用exit程序结束程序，从代码调用的函数名可以很清 楚理解这个过程，但是汇编最需注重的是细节，任何一个细节都可能导致程序的崩溃。&lt;/p&gt;
&lt;h1 id=&#34;gas程序说明&#34;&gt;GAS程序说明&lt;/h1&gt;
&lt;p&gt;下面我对以上涉及到的细节做一些说明：&lt;/p&gt;
&lt;h2 id=&#34;函数入口&#34;&gt;函数入口&lt;/h2&gt;
&lt;p&gt;对于c来说，毫无疑问是main函数作为入口，但这也只是表象，之所以要指定入口，是因为连接器把目标文件组织成可执行文件时需要把入口代码放到代码 段最开始的位置，只要编译器告诉连接器把哪个部分放在入口处即可，所以入口仅仅是一个符号，一个程序可以完全不写main函数，直接修改连接器ld的连接 脚本或者参数，自定义一个入口点。&lt;/p&gt;
&lt;p&gt;汇编程序也是如此，因为直接使用的gcc编译器，gcc把&lt;code&gt;main&lt;/code&gt;作为入口点，但其实gcc并不是编译汇编的主体，汇编编译器其实是as，它默认入口点是 &lt;code&gt;start&lt;/code&gt;。可以把以上程序&lt;code&gt;_main&lt;/code&gt;修改为&lt;code&gt;_start&lt;/code&gt;，使用as进行编译，编译成目标文件之后再使用ld进行链接，之所以这里用gcc编译，完全是为 了简单，它可以自动进行编译连接，并在连接时加入c库。&lt;/p&gt;
&lt;h2 id=&#34;c库调用&#34;&gt;C库调用&lt;/h2&gt;
&lt;p&gt;另一个问题是main，&lt;code&gt;printf&lt;/code&gt;函数都有个下划线，问题便出来了，到底这个 是&lt;code&gt;printf&lt;/code&gt;还是&lt;code&gt;_printf&lt;/code&gt;呢？这里完全是Windows下的规则，Windows的标准c函数，在连接时符号都是加入下划线的，在vc里写入 &lt;code&gt;printf&lt;/code&gt;，编译时被修改为&lt;code&gt;_printf&lt;/code&gt;进行连接，这里由于是汇编，没有c编译器处理这些细节，只能由我们直接写出最终的连接符号。这里有必要一提的 是，对于stdcall类型函数，比如Win32 API，连接符号后会有“@参数总长度 ” 这样的后缀，比如上层的&lt;code&gt;MessageBox&lt;/code&gt;函数，在编译时便会转变成&lt;code&gt;_MessageBoxA@16&lt;/code&gt;，后面所加的A是使用的窄字符版本，这里并不是编译 器所作，而是Windows.h头文件中使用宏分离的不同字符集下的符号，作为汇编，一切工作都得由我们做了，可以看到使用GAS来处理Windows程 序甚为繁琐，因为没有很好的支持，后面可以看到MASM的一个封装，MASM32，作者本身定义了很多的宏以方便调用。当然，如果在linux下编程，便 可省去这烦人的下弧线了。&lt;/p&gt;
&lt;h2 id=&#34;数据段和代码段&#34;&gt;数据段和代码段&lt;/h2&gt;
&lt;p&gt;接下来该进入正题了，就是语法，由于最终程序是要分成若干段，比如代码段，数据段，这些c编译器可以帮忙指定，对于汇编，还是需要我们自己说明，这里的&lt;code&gt;.section&lt;/code&gt;指令便是指明段的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.data —— 初始化数据段，其中的数据在编译期间便已经占用了指定了空间&lt;/li&gt;
&lt;li&gt;.bss —— 与.data对应，是未初始化数据段，也就是这里的数据是未初始化的，在程序运行时才分配的空间&lt;/li&gt;
&lt;li&gt;.rodata —— 只读数据段，相当于常量区，其中的数据不可修改&lt;/li&gt;
&lt;li&gt;.text —— 代码段，此段具有可执行属性，只读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标签&#34;&gt;标签&lt;/h2&gt;
&lt;p&gt;另外，&lt;code&gt;out_text&lt;/code&gt;为标签，因为gas汇编并没有变量名的概念，只能在内存地址的其实位置定义一个标签，方便以后引用此位置。&lt;code&gt;.globl&lt;/code&gt; 导出&lt;code&gt;_main&lt;/code&gt;这个符号，毕竟在连接时需要使用此符号。&lt;/p&gt;
&lt;h2 id=&#34;符号&#34;&gt;$符号&lt;/h2&gt;
&lt;p&gt;最后说明一$符号的使用，在gas汇编中，对于立即数，比如0，需要在数字之前加上$符号，来指明此为立即数，$0就是立即数0，另外，对于符号前的$，即为取地址，&lt;code&gt;$out_text&lt;/code&gt;含义便是取出&lt;code&gt;out_text&lt;/code&gt;的地址，因为&lt;code&gt;printf&lt;/code&gt;需要&lt;code&gt;char *&lt;/code&gt;指针传入。&lt;/p&gt;
&lt;p&gt;如此，示例代码便很容易理解了。对于涉及到的一些汇编指令，今后将会做详细说明。&lt;/p&gt;
&lt;h1 id=&#34;masn-语法框架&#34;&gt;MASN 语法框架&lt;/h1&gt;
&lt;p&gt;对于MASM汇编，语法规则可能要繁琐，但是理解反而要简单，这可能是微软的一贯风格。
首先也来讲一下环境配置，其实编译MASM只需要在微软的开发包中提取出ml.exe和link.exe即可，有人为了方便大家使用，把所需要的一系列工具集成一个开发包，可以在这里下载 Masm32 。&lt;/p&gt;
&lt;p&gt;安装好后，便可开始&lt;code&gt;hello world&lt;/code&gt;程序，这里使用记事本创建&lt;code&gt;hello.asm&lt;/code&gt;程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    windows.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    user32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib user32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	include    kernel32.inc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	includelib kernel32.lib
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.data
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	szText    db &amp;#39;hello world!&amp;#39;,0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	start:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke MessageBox, NULL, offset szText, NULL, MB_OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    invoke ExitProcess, NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	end start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里编译的时候要注意，因为这里引用了头文件和lib文件，所以需要设置环境变量include和lib到masm32目录下的include和lib，或者直接在源文件里写绝对路径，最好设置masm32/bin到path变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	ml /c /coff hello.asm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	link /SUBSYSTEM:WINDOWS hello.obj
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ml 为编译命令，&lt;code&gt;/c&lt;/code&gt; 是仅编译不连接，&lt;code&gt;/coff&lt;/code&gt;是编译为coff格式的目标文件。
link 为连接命令，&lt;code&gt;/SUBSYSTEM:WINDOWS&lt;/code&gt; 指定为窗口程序&lt;/p&gt;
&lt;p&gt;先看开头这些命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.386
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	.model flat,stdcall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	option casemap:none
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;.386&lt;/code&gt; 指定处理器构架在&lt;code&gt;.386&lt;/code&gt;以上，&lt;code&gt;.model&lt;/code&gt;指定编译模式为flat平坦模式，&lt;code&gt;casemap:none&lt;/code&gt;选项表明程序大小写敏感。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.data 指定数据段 .code指定代码段。&lt;/li&gt;
&lt;li&gt;start 为程序开始指定一个符号&lt;/li&gt;
&lt;li&gt;end start 指明程序就此结束，并指定程序入口为start&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里给出框架仅仅为了能建立能运行的汇编环境，其中调用了一些API，也算作配合高级语言编程的一种方式，但汇编绝对不是调用几个API显示几个漂亮的窗口 就算是学会汇编，这些事情用C语言都能够更轻易的处理，一个语言擅长什么就该让它去做什么。没有能应对一切情况的语言，如同没有一个完美的人。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(一)-寄存器</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.-assembler-register/</link>
        <pubDate>Sat, 12 Apr 2014 01:18:03 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.-assembler-register/</guid>
        <description>&lt;p&gt;一直在犹豫汇编语言开始讲什么，如果只说指令，常用的也就几十条甚至十几条指令，如果认为学习汇编就是学习一些指令，那未免有点舍本逐末，如果从IA-32构架开始，又过于晦涩，纠结之下还是先对下基本寄存器做个介绍，为了完整性，顺便对其他高级寄存器做一个列举。&lt;/p&gt;
&lt;p&gt;寄存器是CPU的组成部分，因为在CPU内，所以CPU对其读写速度是最快的，不需要IO传输，但同时也决定了此类寄存器数量非常有限，有限到几乎每个存储都有自己的名字，而且有些还有多个名字^_^&lt;/p&gt;
&lt;h1 id=&#34;寄存器分类&#34;&gt;寄存器分类&lt;/h1&gt;
&lt;p&gt;IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;段寄存器&lt;/li&gt;
&lt;li&gt;状态和控制寄存器&lt;/li&gt;
&lt;li&gt;指令寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通用寄存器&#34;&gt;通用寄存器&lt;/h2&gt;
&lt;p&gt;32位通用寄存器有八个，eax, ebx, ecx, edx, esi, edi, ebp, esp，他们主要用作逻辑运算、地址计算和内存指针，具体功能如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eax —— 累加和结果寄存器
ebx —— 数据指针寄存器
ecx —— 循环计数器
edx —— i/o指针
esi —— 源地址寄存器
edi —— 目的地址寄存器
esp —— 堆栈指针
ebp —— 栈指针寄存器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，以上功能并未限制寄存器的使用，特殊情况为了效率也可作其他用途。这八个寄存器低16位分别有一个引用别名 ax, bx, cx, dx, bp, si, di, sp, 其中 ax, bx, cx, dx, 的高8位又引用至 ah, bh, ch, dh，低八位引用至 al, bl, cl, dl&lt;/p&gt;
&lt;p&gt;在 64-bit 模式下，有16个通用寄存器，但是这16个寄存器是兼容32位模式的，32位方式下寄存器名分别为 eax, ebx, ecx, edx, edi, esi, ebp, esp, r8d – r15d. 在64位模式下，他们被扩展为 rax, rbx, rcx, rdx, rdi, rsi, rbp, rsp, r8 – r15. 其中 r8 – r15 这八个寄存器是64-bit模式下新加入的寄存器。&lt;/p&gt;
&lt;h2 id=&#34;段寄存器&#34;&gt;段寄存器&lt;/h2&gt;
&lt;p&gt;段寄存器 cs, ds, ss, es, fs, gs, 保存16位的段选择子，一个段选择子指定了一个段在内存的指针，以便再内存中访问段，访问方式与内存模式有关，段模式和平坦模式其代表的意义并不相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cs —— 代码段寄存器
ds, es, fs, gs —— 数据段寄存器
ss —— 堆栈段寄存器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 64-bit 模式下，这6个寄存器并无变化，只是使用上略有区别。&lt;/p&gt;
&lt;h2 id=&#34;状态和控制寄存器-eflags&#34;&gt;状态和控制寄存器 eflags&lt;/h2&gt;
&lt;p&gt;这个寄存器表示的意义非常丰富，程序中并不直接操作此寄存器，并由此衍生出很多操作指令。&lt;/p&gt;
&lt;p&gt;除去一些保留位，其他每位都代表一个具体的含义，其中 bits 0, 2, 4, 6, 7, 11 是状态位，标识了某此操作后的状态，8, 9, 10 位为控制标识&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CF (bit 0) —— 进位标识，算术操作进行了进位和借位，则此位被设置
PF (bit 2) —— 奇偶标识，结果包含奇数个1，则设置此位
AF (bit 4) —— 辅助进位标识，结果的第3位像第4位借位，则此位被设置
ZF (bit 6) —— 零标识，结果为零，此位设置
SF (bit 7) —— 符号标识，若为负数则设置此位
OF (bit 11) —— 溢出标识，结果像最高位符号位进行借位或者进位，此标志被设置

TF (bit 8) —— 陷阱标识，设置进程可以被单步调试
IF (bit 9) —— 中断标识，设置能够响应中断请求
DF (bit 10) —— 方向标识，用于标示字符处理过程中指针移动方向。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在64-bit模式下，该寄存器被扩展为64位，rflags，但是其高32位保留未被使用，其低32位所表示含义与32位模式相同。&lt;/p&gt;
&lt;h2 id=&#34;指令寄存器-eip&#34;&gt;指令寄存器 EIP&lt;/h2&gt;
&lt;p&gt;EIP —— 标志当前进程将要执行指令位置
在64位模式下扩展为 RIP 64位指令寄存器。&lt;/p&gt;
&lt;h2 id=&#34;控制寄存器&#34;&gt;控制寄存器&lt;/h2&gt;
&lt;p&gt;cr0, cr2, cr3, cr4&lt;/p&gt;
&lt;h2 id=&#34;系统表指针寄存器&#34;&gt;系统表指针寄存器&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;idtr —— 中断描述符表信息
gdtr —— 全局描述符表信息
ldtr —— 局部描述符表信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;任务寄存器tr&#34;&gt;任务寄存器tr&lt;/h2&gt;
&lt;p&gt;保存任务的状态信息 tss&lt;/p&gt;
&lt;p&gt;调试寄存器
dr0 – dr7
控制和允许监视进程的调试操作&lt;/p&gt;
&lt;h2 id=&#34;x87-fpu-寄存器&#34;&gt;x87 FPU 寄存器&lt;/h2&gt;
&lt;p&gt;这组指令专门用过浮点运算，因为浮点运算尤其固有的特性，所以需要使用一组独立寄存器。
数据寄存器包括 r0 – r7 的8个 80 位寄存器，汇编程序中通过名字 st(x) 引用，另外还有3个16位寄存器，分别是控制寄存器，状态寄存器，标记寄存器。
这里的省略具体含义的介绍。&lt;/p&gt;
&lt;h2 id=&#34;mmx-寄存器&#34;&gt;MMX 寄存器&lt;/h2&gt;
&lt;p&gt;MMX 为一种 SIMD 技术，即可通过一条指令执行多个数据运算，共有8个64位寄存器，分别为mm0 – mm7，他与其他普通64位寄存器的区别在于通过它的指令进行运算，可以同时计算2个32位数据，或者4个16位数据等等，可以应用为图像处理过程中图形 颜色的计算。另外需要特别注意的是，MMX并非一种新的寄存器，而是FPU 80位寄存器的低64位，也就是说，使用MMX指令集，会影响浮点运算！&lt;/p&gt;
&lt;h2 id=&#34;xmm-寄存器&#34;&gt;XMM 寄存器&lt;/h2&gt;
&lt;p&gt;XMM 同 MMX，只是他有 8 个 128 位寄存器，分别为 xmm0 – xmm7，另外还包含计算过程中的状态和控制寄存器&lt;/p&gt;
&lt;p&gt;这篇介绍列举了一些CPU寄存器并对某些寄存器进行了详细介绍，但并非完整详尽的介绍，略去了很多细节，因为寄存器本身只做存储之用，真正理解还需依靠其对应的指令操作，这里仅仅为之后的介绍做一些准备工作，如果有可能，我会努力完善此文。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>汇编语言学习笔记(零)-为什么开始</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.-assembler-why-learning/</link>
        <pubDate>Fri, 11 Apr 2014 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.-assembler-why-learning/</guid>
        <description>&lt;h1 id=&#34;为什么开始&#34;&gt;为什么开始&lt;/h1&gt;
&lt;p&gt;从开始学习汇编到现在也有很长时间了，虽算不上刻苦钻研，但接触久了多少也有些感悟，打算就此做一些总结，一来算是备忘，二来也可以梳理知识使之融会贯通。我自小就不是一个勤奋的人，写这个东西也不会很积极，只当做是闲暇时的消遣，希望不要无疾而终便好。&lt;/p&gt;
&lt;p&gt;沿袭程序员“良好”习惯，这篇文章做为第零篇，主要总括汇编语言的概况以及它的主要用途，初识一种技能，知道它能做什么或许比如何去做更加有意义。&lt;/p&gt;
&lt;h1 id=&#34;汇编语言种类&#34;&gt;汇编语言种类&lt;/h1&gt;
&lt;p&gt;汇编语言不同于C、C++等高级语言，因为它“派系林立”，语法种类非常之多，但总体来讲各种语法都没有本质的差别，更多的是表述方式不同。&lt;/p&gt;
&lt;p&gt;大学时期学过一门《微机原理》的课程，其中的汇编是微软的Masm语法，如同Windows基本成为系统的代名词，Masm几乎也成了汇编代名词，但我这组文章并不是仅仅用来说明Masm，微软的东西用起来挺方便，用多了感觉多少有点繁琐；Masm 还是 Visual C++编译后端，如果有需要，可以编译C/C++代码到Masm查看汇编代码。&lt;/p&gt;
&lt;p&gt;除此之外，比较流行的语法还有Nasm，这也算是个简洁的语法，简单到连数据类型都没有，只需指定内存大小，如何理解内存是开发者的事情，这样也更接近汇编语言的本质，但易用性就较之Masm差了很多；与Masm专注于Windows平台不同，Nasm是个跨平台语言，几乎可以生成各种平台下各种格式的二进制，官方的教程也写得很详细，只是语言显得有点过于简单，似乎学的人不少，但是用的人不多。&lt;/p&gt;
&lt;p&gt;还有一种比较出名的汇编语法HLA，语法有点类似高级语言，这种语法之所以出名得益于《汇编语言编程艺术》一书，书名有“艺术”一词或许会显得比较高深，但实在不知道这种语法除了作者还有谁在使用，用于何地。&lt;/p&gt;
&lt;p&gt;最后隆重推出的语法是AT&amp;amp;T的GAS语法，压轴戏都是最后登场，此次也不例外，之前提到的各种汇编语法都是伟大的结晶，我也没有任何贬低之意，只是我更加喜欢AT&amp;amp;T而已，AT&amp;amp;T语法是Gcc的后端汇编语法，这也是为什么我更偏爱它的原因之一，Gcc几乎可以在任何平台编译任何代码，GAS当然做到Gcc所实现的事情，Nasm虽然也能轻松跨平台应用，但在特定平台下编译代码，除了代码的二进制还需有资源文件、系统库等，这点需要一个强大的链接器支持，与其使用各种拼盘，不如直接用Gcc套件来的更为直接；AT&amp;amp;T汇编也被应用于Linux内核中，这点也不难理解，原本Gcc编译的代码就跟AT&amp;amp;T汇编是一样的的东西。&lt;/p&gt;
&lt;p&gt;当然，汇编语言种类很多，还有些主要应用于Dos平台，我也没有更多接触，自此也不便妄加评论；汇编之中使用最为广泛的就属Win平台下的MASM和Linux平台下的GAS，之所以重要在于二者分别是VC++和Gcc这两大重器的后端，尤其是在Windows广泛应用的环境下，Masm在汇编语法中就显得更为重要了，所以说，有时候拼的不是谁更出色，而是拼谁的“背景”更牛。若在Linux平台想用汇编对代码进行优化、阅读Linux内核源码，就免不了GAS汇编；在Windows下做优化、破解、外挂，也免不了Masm汇编。虽说二者本质相同，但表现形式还是有很大差别。我这里写的东西并不局限于其中一种汇编，因为二者都是非常重要的语言。&lt;/p&gt;
&lt;h1 id=&#34;学习汇编语言有什么用&#34;&gt;学习汇编语言有什么用&lt;/h1&gt;
&lt;p&gt;在学习汇编之前，很多人可能都有疑问，汇编到底能做什么，除非是Geek，否则没人去用汇编写一套软件出来吧；在这里需要总括一下汇编的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;破解：也许汇编最广的用途在于软件的破解，在中国大多数人都在有意无意的使用着盗版，有很多人都不知道自己电脑中哪些软件是需要收费的，也有很多程序员收集很多软件，以及这些软件所对应的注册码供人使用，所谓己所不欲勿施于人，作为一个程序员，却侵犯着其他程序员的利益，好在如今免费的东西越来越多，尤其是互联网的广泛使用，各种云平台的挤压，为服务收费方式越来越多过为软件收费的方式。抛开盗版这种行为，破解软件的过程中本身是件很有趣的事情，是跟软件保护者的一场智力对抗比赛；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逆向工程：有时候看到某些软件制作精巧，细想之下居然不知道他是如何实现的，在作者不开源的情况下，要想理解作者的实现思路，只能阅读部分的汇编代码，还原为C代码来仿制作者的功能；同样由于互联网的冲击，提供网络服务的企业越来越多，逆向的需求也越来越少；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;游戏外挂：破解和逆向的应用场景不断收缩，但与之关联的游戏外挂却越来越火爆（当然法律的越来越健全对外挂有着相当大的阻力），因为通过游戏的盈利点非常清晰，通过一款成功的游戏能够获得巨大收益，而外挂是游戏的一种“捷径”，从中牟取的利益也是非常客观。游戏外挂本身是逆向和破解的集合，对技能的要求非常高。随着网页游戏和手机游戏的逐渐火爆，外挂的形式也变得多种多样，已经并不局限于汇编；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统编程：对于精确定位和控制可执行文件大小方面，恐怕没有哪种高级语言能够实现，Linux内核尽可能使用C语言实现，但是引导区部分仍然需要汇编处理，另外，操控硬件(in,out指令)，中断（int,syscall指令）等等，C语言也需要内联汇编实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编优化：C语言是比较底层的语言，还是需要更进一步编译为汇编代码，由于C需要通用性，翻译成汇编指令的过程中为了兼顾其他平台或者各种可能的用法，对某种具体行为未必能做到最优化处理，这时就需要手动调整汇编代码，不过Gcc 的优化能力已经非常出色，况且这种优化只能是微观优化，大多数情况还得需要宏观的优化，调整算法的复杂度，汇编优化可能提高几倍的效率，业务算法的优化可能能够提升上百倍甚至上千倍的效率，除非这里已经是算法的瓶颈所在，否则汇编优化是没有多少意义的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解高级语言：C++有很多晦涩的语法，不了解编译器如何实现，可能有各种猜测，但事实是否如此，我们可将最简单的例子编译成汇编阅读，一窥语言的底层实现，不过这里只供理解之用，不是标准规定的，各个平台的实现并不尽相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有对可执行文件的二次开发等等，都脱离不了对程序的逆向。同时我们也可以看到，在互联网时代，汇编似乎显得比较没落，更多的学习者都在于增加“功力”而已。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>如何有效决策-《卓有成效的管理者》读感</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/effective-executive/</link>
        <pubDate>Fri, 03 Jun 2011 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/effective-executive/</guid>
        <description>&lt;p&gt;在工作管理中经常需要进行决策，所谓决策，即是决定一些策略，按照常识来讲，决策是管理者的一种普遍行为，而《卓有成效管理者》中却又说明管理者不做太多的决策，只做重大的决策，与印象中管理者的形象相左，随着深入学习，逐渐开始理解只做重大决策的含义。&lt;/p&gt;
&lt;p&gt;做一个卓有成效的管理者，需要掌握时间、了解自己的贡献，发挥人的长处，以及要事优先，如果深入理解书中所讲的这几点，也就不难理解为什么管理者只需要做重大决定。&lt;/p&gt;
&lt;p&gt;首先管理者需要掌握时间，如果事无巨细都需要亲自决定，往往会耗费大量精力和时间，不能发挥自身的长处和贡献更多的力量。作为管理者首要处理的问题就是自己的时间问题，诊断自己的时间，消除不必要浪费时间的活动，安排支配时间，更有效用的利用自己的时间。管理者想要腾出自己的时间，就必须要做到发挥人的长处，用人之所长，把合适的工作下放给合适的人去做，自己只关注重要的事情，也就是做重大的决策。&lt;/p&gt;
&lt;p&gt;做重大决策必须识别什么是重大决策，如何让别人做的决定没有问题。这就要理解决策的五个要素：&lt;/p&gt;
&lt;p&gt;一、问题的性质：需要做决策的问题是经常性的还是偶然性的，如果是经常性的需要决策，就会耗费大量的精力，所以需要指定规则和政策，避免重复的做决策；
二、这一点也是最难的一点，找到问题的边界。
三、需要找到正确的决策，而不是普遍被人接收的决策
四、决策方案需要兼顾执行，决策只是开始，真正耗费时间和经历的是执行，在做决策的同时如果没有考虑如何执行，在后面的执行过程会有很多问题，难以持续；
五、执行过程中需要重视反馈，以反馈来印证决策的正确性和有效性，避免有问题的决策离正确的方向越来越远。&lt;/p&gt;
&lt;p&gt;决策往往不在是与非之间，而是可能是对的，大概是错的之间进行决策，这时想要做出有效的决策便不是意见容易的事情了。&lt;/p&gt;
&lt;p&gt;而在决策过程中，往往会认为决策是从收集事实开始的，这是一种误解，其实所有的实事都是从自己的经验开始的，通过自己的经验收集相关的实事数据，但这样并不是说可以从自己的经验随意的进行决策，而是必须同时指定一系列标准，所谓的标准就是如何判定自己的决策是否有效。&lt;/p&gt;
&lt;p&gt;另一个容易误解的事实是决策是来自统一的意见，认为所有人打成共识便是一个好的决策，其实不然，做为管理者，需要想方设法激发不同的意见，引起争辩才能更好的深思熟虑，而且有利于得出备选方案。&lt;/p&gt;
&lt;p&gt;最终，决策后需要行动，切忌在行动与不行动之间折中，如果有疑虑，需要再考虑一下是否真的需要决策，否则一旦决策，就需要付诸行动。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>成为有影响力的开发者</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/become-an-influential-programmers/</link>
        <pubDate>Thu, 02 Jun 2011 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/become-an-influential-programmers/</guid>
        <description>&lt;p&gt;腾讯会让新入职员工采访一些老员工，通过访谈方式让新员工更好的融入公司的企业文化，也能更有针对性的面对未来的工作。在腾讯混了三年，终于混成老油条了，通过近些年的工作经历，也来谈一谈如何成为一个有影响力的开发者。&lt;/p&gt;
&lt;h1 id=&#34;关于技术&#34;&gt;关于技术&lt;/h1&gt;
&lt;p&gt;每个有追求的程序员都想通过有“技术含量”的项目来锻炼自身的技术水平，不过所谓的“技术含量”的工作不多，而且需要在普通的项目上证明自身的能力后才可能有机会参与设计更重要的项目。所以先来谈谈如何磨练自身的技术水平，面对一个任何一个开发者都能胜任的项目，不同的开发者进行开发，虽然可能最终都能完成一个项目，但其过程却体现出很多不同点。&lt;/p&gt;
&lt;p&gt;首先从代码质量角度，优秀的开发者可以以更为优雅的实现方式，写出更漂亮的代码，更具灵活性更易扩展。小到一个变量的命名，大到模块的架构设计，设计细节的考虑，都有高下差异，考虑多少对一个人成长也至关重要。&lt;/p&gt;
&lt;p&gt;另外，对于周边模块，开发中了解越多，越能掌握项目的主动，把控全局，在一个团队中，系统模块了解越多的人，越有可能成为别人依赖的对象，这对影响力的增加至关重要。&lt;/p&gt;
&lt;p&gt;另外，即使是&lt;code&gt;技术含量&lt;/code&gt;不高，也有很多可挖掘思考的细节，也许每一个细节都不重要，但养成良好的习惯，日久天长，很多年的积累过后，成就便会逐渐区分出来。&lt;/p&gt;
&lt;h1 id=&#34;关于独当一面&#34;&gt;关于独当一面&lt;/h1&gt;
&lt;p&gt;作为新人，在工作岗位上最容易产生依赖心理，对一个函数的声明、一个模块的设计，因为不熟悉，总需要在各种问题上有人把关，但如果经常被动的跟着别人的要求去做，一旦产生依赖习惯，便很难自己独立做出一些决定，别人也不会放心把整个模块全权交给自己去完成。从这方面考虑，当新人即使各种不熟悉，在面对一个问题或者决定，也最好能够根据自己已经知道的情况做出一些自己的思考和决定，让导师或者leader做一个决策者，指出自己方案的不足，而不是做一个指挥者，指挥自己去做事情，随着对整体环境的逐渐熟悉，自己做的决定也越来越靠谱，而且会让leader感觉自己面对问题有自己独立的想法，基本上都很靠谱，也更容易放心的交给自己独立负责模块，逐渐建立相互之间的信任关系。&lt;/p&gt;
&lt;h1 id=&#34;关于分享&#34;&gt;关于分享&lt;/h1&gt;
&lt;p&gt;所谓的影响力，说白了也没什么神秘，努力让更多的人认识自己，认可自己。这就要把握一切机会展示自己，其中一项很重要的方面就是“分享”，想让人更快的认识自己，就要认识到自己的长处，或者努力让自己在某一方面成为专家，第一步学习，第二步应用，最后就要把自己的所学分享给他人，当周围的人对算法不是很擅长，可以精研一些算法。当周围的人对设计不在行，可以学习一些并在项目中合理的应用一些设计模式。最后把这些都分享给他人，一般开发者对于自己所不擅长并且很有用的分享都抱有开放的态度，一旦自己成为别人眼中某一方面的“专家”，就会有更多的人咨询探讨，为了保持这份“专家”身份，就会促使自己更加精研这个领域，从而某一天发现，自己真的成了专家。&lt;/p&gt;
&lt;h1 id=&#34;关于主动性&#34;&gt;关于主动性&lt;/h1&gt;
&lt;p&gt;每个人都希望把自己的工作交给“省心”的人，不需要自己操心，当接到一个任务，能够主动cover到任务的各个方面，当自己cover不住的点，就会到leader手里，一个人能cover更多的部分，leader也就越省心，也就越能体现自己的能力，积极主动的去cover更多的方面，也能更大程度上增加自己的影响力。&lt;/p&gt;
&lt;p&gt;另外主动性还包括主动优化项目中的不足，每优化一次就是一个亮点，真正的思考和优化能力，是不可替代的，也是别人所欣赏的。&lt;/p&gt;
&lt;h1 id=&#34;关于沟通&#34;&gt;关于沟通&lt;/h1&gt;
&lt;p&gt;在日常工作和项目中，沟通也是至关重要的一项能力，沟通的时候你需要了解对方所希望知道的，对一个产品解释某个代码中的细节，可能对方并不关心，只关心结论，也可能对方想要知道技术中的难点，这事也需要简化为对方能够听懂的方式，尽量减少对方的沟通成本，别人也会乐于与自己沟通。满嘴的高深技术细节，并不一定会让人觉得自己很牛，相反可能会觉得自己能力不足。&lt;/p&gt;
&lt;p&gt;沟通的一方面也包括工作汇报，当你向产品或者leader解释工作的时候，需要突出难点，有理有据，一个会让人觉得自己的思路很清晰，另一方面也能展现工作中的难点，突出成绩。相反如果没有重点平铺直叙，不容易突出自己工作的难点，容易让人忽略，以为自己的工作很简单。&lt;/p&gt;
&lt;h1 id=&#34;关于时间管理&#34;&gt;关于时间管理&lt;/h1&gt;
&lt;p&gt;当自己负责的模块越来越多，自己的影响力增大，找自己处理问题的人也会越来越多，这时候就需要考虑自己的时间，当自己一直被人中断处理各种问题，真正属于自己的工作时间就会变得很少，这时候就需要学习如何正确的处理中断。合理的安排时间，集中精力解决紧急并重要的问题，而且需要经常思考，如何把自己从繁重的无意义事情中解脱出来。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>双色球必胜秘籍</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/probability-double-color/</link>
        <pubDate>Thu, 02 Jun 2011 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/probability-double-color/</guid>
        <description>&lt;p&gt;几天前淘宝在1212促销时，买了所有双色球的组合，免费发给用户，为了这次营销发出去几千万，我虽然没中什么大奖，不过对双色球全买能有什么结果很感兴趣，抽空计算了一下所有的组合。&lt;/p&gt;
&lt;h1 id=&#34;规则&#34;&gt;规则&lt;/h1&gt;
&lt;p&gt;双色球买一注需要在33个红球中选择6个，并在16个蓝球中选择1个，每注2块钱，具体的得奖规则如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;奖级&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;中奖条件&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;奖金&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;一等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;红6蓝1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;500w上下&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;二等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;红6&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;十万级别&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;三等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;红5蓝1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;四等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;红5 或 红4蓝1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;200元&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;五等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;红4 或 红3蓝1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;10元&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;六等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;蓝1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;5元&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;概率分布&#34;&gt;概率分布&lt;/h1&gt;
&lt;p&gt;如果全买双色球，需要 &lt;code&gt;C(16, 1) * C(33, 6) = 17721088&lt;/code&gt; 注彩票，所需花费约三千五百万，那么中奖的数量有多少呢？&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;奖级&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;中奖条件&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;数量&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;一等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中6+1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;二等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中6+0&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;16&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;三等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中5+1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;162&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;四等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中5+0/4+1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;7695&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;五等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中4+0/3+1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;137475&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;六等奖&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;中2+1/1+1/0+1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1043640&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;能够回的本钱大约有 16817950，基本上等于投资的一半！这说明，如果拿10块钱随机买彩票，能获得的收益只有5块钱，记得有一次公司给员工发8w块钱的彩票，最后收益也只有4w，与计算结果相吻合。&lt;/p&gt;
&lt;p&gt;可以看出如果盲目购买彩票，除非运气很好，按照数学期望，最大可能的情况是没法回本的，那是不是有办法能提升中奖概率呢？&lt;/p&gt;
&lt;h1 id=&#34;必胜秘籍&#34;&gt;必胜秘籍&lt;/h1&gt;
&lt;p&gt;如果要玩双色球，首先得承认庄家没有作弊，如果庄家作弊的情况下，赌徒不论怎么计算都没法提高中奖概率的，如果认为开奖有不公环节，最好的选择就是不去玩。&lt;/p&gt;
&lt;p&gt;一些人喜欢按照过去双色球出号规律来推测下一次是什么号码，但不管怎么总结，都跟概率论的一个经典问题相似，投硬币如果10次都是正面，那么下一次投掷是反面的概率会不会大于50%？答案当然是不会，概率仍然是50%，所以之前出的号码，不管怎么漂亮，都不会影响下一次的号码，所以按照历史记录来“计算”显然是没法提升概率的。&lt;/p&gt;
&lt;p&gt;如果看奖项设置，最明显的就是如果中一个蓝号，肯定不会亏钱，所以可以从蓝号入手，当然，多次购买的话，总体的盈利得是正的，所以买两次彩票中一次就会盈利1块钱，如果前两次没中，第三次购买需要买两注相同的蓝号，这样猜中蓝号才能盈利，同理，按照这个规律下去，只需要购买相同的蓝号越买越多，总归有一天能实现盈利，可以说立于不败之地，不过这里还需要考虑一下本钱的问题，因为越买越多可能在没有中奖的时候下就会破产。所以需要计算一下中奖概率，以及成本规模：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;连续购买次数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;中奖概率&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;本次所需购买彩票数&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;需要总成本&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;6.25%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;12.10%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;4&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;17.60%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;8&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;10&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;47.55%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;64&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;318&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;15&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;62.01%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;820&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;4098&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;20&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;72.49%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;10542&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;52708&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;25&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;80.08%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;135570&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;677848&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;30&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;85.57%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1743440&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;8717198&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看到，如果连续10次按照这种方法购买，回本的概率将近有50%，如果连续20次购买，回本的概率有72%，但是需要总成本五万，这还算可以接受，不过如果想连续30次购买，回本的概率有85%，但需要本钱800万，这个成本就相当高了。那盈利呢，这里的计算只是只中蓝号的情况，能实现不亏钱，如果想盈利，还需要靠红号，如果红号中的多，盈利自然也更多。以淘宝投入三千万为例，完全能保证85%的可能不亏钱，中红号还能实现不小的盈利。&lt;/p&gt;
&lt;p&gt;但是这里的风险不可控，很容易本钱跟不上导致破产，所以要想必胜，只有一种方法，就是“命好”。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>软件版本对系统架构的理解</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/software-version-compare-for-design/</link>
        <pubDate>Wed, 01 Jun 2011 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/software-version-compare-for-design/</guid>
        <description>&lt;p&gt;之前阅读开源软件总习惯性的拿新版或者稳定版开始，这两天看了 netbeans 作者写的《软件框架设计的艺术》，经常拿 java1.4 版和 java1.5 版的实现区别作对比，以此来阐释某种设计理念，想想才发现，想要了解开源软件构架，还是需要查阅不同软件版本之间的差别。&lt;/p&gt;
&lt;p&gt;一个软件，其构架是否合理，没有相关的经验是比较难领悟的，但一个开源软件的精华往往在于其构架，学习其构架可以通过仔细阅读其中某一个版本，但是更好的方式是去关注不同版本中的变化，构架的合理性只有通过不断的演变才能体现出来，好的设计在不断演化中仍旧能保持很好的韧性，差的设计就需要不断做出大的变更才能适应变化的需求，而版本的更替最能有效的看到这种衍化，也能更深层理解设计。&lt;/p&gt;
&lt;p&gt;构建一个系统并不难，所有的难度都在于随着时间的推移，系统在不断的演化，可能是需求在不断变更，也可能是开始无法把所有细节考虑周全，在系统发生变化的时候，往往为了便利而破坏开始的设计，可能是为了获取一个配置而打破原有的封装，可能是为了复用一段工具代码而更改原本私有的方法，在实践中原本的封装，往往不是那么显而易见，而且重构代码的成本往往超出我们预估，以致时常为了一时的便利让代码结构变得混乱。如何维持清晰的层次结构，除了经验，还需要一点“洁癖”。&lt;/p&gt;
&lt;p&gt;另一个极端就是设计过度，记得我维护一个同事的代码，发现他把 XML 的每一项都抽象成了接口，每在 XML 里加一项，就必须对他复杂的类层次增加一个接口，XML 的易扩展特性完全无法体现，那开始的时候为什么要用 XML 呢？其实说过度设计完全是抬举这种做法，这种做法完全就是错误的设计，接口的作用就是封装变化，而他相反，把最容易变化的部分抽象成了接口，很是无语，如果不对这段代码进行维护，他可能会觉得自己的设计分离了 XML 的实现，是很完美的面向对象体现（看他注释经常出现这是面向对象的 XX 之类）。所以设计好与坏，可能当时没有感觉，但在实践中演化，所有的利弊便一览无余，演化是检验设计的唯一标准啊。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>技术答辩感悟</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/how-to-reply-for-technology/</link>
        <pubDate>Wed, 01 Jun 2011 01:16:33 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/how-to-reply-for-technology/</guid>
        <description>&lt;p&gt;昨天以旁观者身份观察了一场答辩，结合自己之前几次不成功的分享和答辩，也算是受益匪浅，有些心得记录一下。&lt;/p&gt;
&lt;h1 id=&#34;准备&#34;&gt;准备&lt;/h1&gt;
&lt;p&gt;成功的答辩离不开充分的准备，这里的准备分几个方面，第一个也是最重要的就是平时的准备，答辩之前可以针对性的考虑一些可能问到的问题，增加成功率，但很多问题是无法预测的，这就需要打铁还需自身硬，在平时设计开发的时候就做想尽的考虑，事无巨细，尽量做到对自己所做的东西了如指掌，这需要平时的习惯养成。&lt;/p&gt;
&lt;p&gt;另外，答辩之前，也需要针对性的做一些准备，首先，需要知道这次答辩的目的，比如昨晚的答辩，实际上最开始就以为review一下代码就行，其实最后还是纠结在如何设计和实现。之前我自己的答辩，也是没有对答辩的状况有合理的预期，准备的时候更多的是考虑如何讲更有逻辑性，而不知道评委最终会纠结在什么地方，什么地方他们根本不关心，没有对状况的预期，往往会手忙脚乱。&lt;/p&gt;
&lt;p&gt;还有对评委的背景，最好能有一个初步的了解，一般评委关注点更多的跟自己的背景有关。不过有时候很难了解每个评委的风格。&lt;/p&gt;
&lt;h1 id=&#34;论述&#34;&gt;论述&lt;/h1&gt;
&lt;p&gt;关于如何讲自己的项目或者设计，以前都是站在自己的角度考虑，如何才能清楚、有逻辑的讲完，但对于评委，可能是完全不同的理解。评委对一开始讲的背景，优缺点其实并不是很在意，模型才是关键，有时候一贴架构图，评委就来了精神，这里的图，就是整个架构的模型，也是理解架构的切入点，所以如何讲清楚模型是非常重要的。&lt;/p&gt;
&lt;p&gt;评委都有自身的背景，面对模型，也会结合自己的经验，所谓的经验就是定式，如果你的模型符合他的定式，便会非常容易理解，一旦模型不符合定式，就需要花费很大精力去讲解，所以从大众熟悉的模型讲起，逐渐推演，便会容易理解很多。&lt;/p&gt;
&lt;p&gt;另外还需要学习一些通用的表达方式，如金字塔原理等。&lt;/p&gt;
&lt;h1 id=&#34;面对挑战&#34;&gt;面对挑战&lt;/h1&gt;
&lt;p&gt;答辩必然会遇到评委的挑战，有些评委气势如虹，很容易造成答辩者的心理压力，导致不能正常发挥。其实很多情况下，评委只是一时兴起的问题，还不没有深思熟虑，稍加思考即可应对，所以回答问题不能急，要慢下来，思考后回答。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>发布后台程序注意总结</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/how-to-publish-server-program/</link>
        <pubDate>Sat, 16 Apr 2011 22:40:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/how-to-publish-server-program/</guid>
        <description>&lt;p&gt;QQ后台服务承载过亿的在线用户，即使是很小的事故也会影响大量的用户，造成极其不好的影响，而百分之八九十的事故都是由于上线发布引起的，所以要对服务上线发布足够的重视。&lt;/p&gt;
&lt;p&gt;这里总结一些必要的规范，减少事故发生：&lt;/p&gt;
&lt;h1 id=&#34;svn-tag&#34;&gt;SVN Tag&lt;/h1&gt;
&lt;p&gt;完成代码，测试通过后，对要发布的版本按照日期打一个Tag，方便查找线上Bug时有一个对应的代码版本，另外，如果有问题回滚到之前的版本，每次发布有Tag能够很快找到之前的版本进行回滚，每一个线上存在过的版本，都应该在SVN有一个Tag与之对应。代码编译应该使用编译机，不要在自己机器上编译发布，避免有一些只能在自己机器上编译的情况，如果有需要其他同事也方便操作。&lt;/p&gt;
&lt;h1 id=&#34;发布前代码review&#34;&gt;发布前代码review&lt;/h1&gt;
&lt;p&gt;发布前，尽量找熟悉相关模块的同事进行代码走读，能够在发布前查到一些自己没考虑清楚的逻辑；&lt;/p&gt;
&lt;h1 id=&#34;上线前周知&#34;&gt;上线前周知&lt;/h1&gt;
&lt;p&gt;在服务上线之前，一定要在相关的群里周知，对于比较重大的修改，甚至需要单独拉群进行知会，以便在服务出现问题的时候能够即时发现处理。同时另一方面，当自己相关的模块有比较重要的更新，要即时关注自己服务的视图，即时得知问题；&lt;/p&gt;
&lt;h1 id=&#34;发布时间&#34;&gt;发布时间&lt;/h1&gt;
&lt;p&gt;发布出现事故，时常是相关模块最先感知，或者需要相关模块协助定位并解决问题。这就需要在上班时间进行发布，上午10:00到11:30，下午2:00到5:00，周五及节假日前一天尽量避免发布；&lt;/p&gt;
&lt;h1 id=&#34;灰度发布&#34;&gt;灰度发布&lt;/h1&gt;
&lt;p&gt;发布过程中先发布一台机器进行灰度，尽量挑选自己用户所在的机器，这样能够验证线上服务是否正常。发布一台机器以后，需要即时关注日志、单机视图和进程是否有core，视图包括全部属性，不能只看重要属性，查看是否有非预期的错误日志输出，单机视图各项上报是否有异常变化。同时验证线上功能是否正常。&lt;/p&gt;
&lt;p&gt;对于一些比较重大的改动，可能的情况下，尽量保留新通道和旧通道，通过染色号码和号段进行灰度，这样出现情况可以快速通过修改配置禁用新逻辑。&lt;/p&gt;
&lt;h1 id=&#34;发布过程中&#34;&gt;发布过程中&lt;/h1&gt;
&lt;p&gt;发布过程中间隔一段时间需要关注一下视图变化情况，凡是同比图出现异常变动，都需要查找原因，事故的表象往往就是不起眼的视图变化。&lt;/p&gt;
&lt;h1 id=&#34;发布后&#34;&gt;发布后&lt;/h1&gt;
&lt;p&gt;发布结束后，以及发布当天下班前，通览一遍视图，确保各项指标正常。&lt;/p&gt;
&lt;h1 id=&#34;出现问题&#34;&gt;出现问题&lt;/h1&gt;
&lt;p&gt;发布过程中出现异常情况，即使不是发布引起的，也要第一时间暂停发布，确定没有问题后方可继续发布，出现异常情况短时间无法确定产生原因，要第一时间知会Leader及导师，并在Leader建议下尝试回滚和问题定位。&lt;/p&gt;
&lt;h1 id=&#34;回滚后&#34;&gt;回滚后&lt;/h1&gt;
&lt;p&gt;如遇到回滚，回滚时不应该放松警惕，应该同发布一样，逐步灰度回滚，并观察单机视图，日志，检查进程是否存在core，之前的异常问题是否已经解决等。回滚后定时检查视图，查看是否存在其他异常。&lt;/p&gt;
&lt;p&gt;另外，对于leader，在新人前几次发布需要按照步骤手把手发布，一个新人对发布的态度，往往是由前几次发布所决定，只要开始没有按照规范发布，以后的发布就会很潦草，所以要从一开始养成良好的发布习惯。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;11 详解</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/meaning-of-c&#43;&#43;11/</link>
        <pubDate>Fri, 15 Apr 2011 22:40:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/meaning-of-c&#43;&#43;11/</guid>
        <description>&lt;p&gt;C++11 已经出来很久了，一直没有时间好好学习一下，最近项目中用到了一些，花了点时间总结一些常用的语法和库，以备参考。&lt;/p&gt;
&lt;h1 id=&#34;题外话&#34;&gt;题外话&lt;/h1&gt;
&lt;p&gt;C++语言是一门非常繁复的语言，支持的编程范式很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向过程编程（c子集）&lt;/li&gt;
&lt;li&gt;面向对象OO&lt;/li&gt;
&lt;li&gt;泛型编程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且C++本身并不限制使用者，方便使用者进行混用，再加上包罗万象的语法和各种隐晦的含义，也很方便使用者滥用和误用。&lt;/p&gt;
&lt;h2 id=&#34;艺术-vs-工程&#34;&gt;艺术 vs 工程&lt;/h2&gt;
&lt;p&gt;编程中常会有编程是门艺术还是一项工程的考虑，最完美的结果当然是艺术与工程的完美结合，但现实往往所有偏向，以我个人的理解，&lt;strong&gt;艺术是让最优秀的人做的最好，工程是让最平庸的人做的不能太差&lt;/strong&gt;。像画家，只要一根笔就能绘制无穷的世界，但只有最优秀的艺术家才能做出珍品，平庸的人往往都是涂鸦，这就是艺术的最好体现。而像流水线的工人，只要培训几天就能上岗，机械的重复简单的劳动，集合起来便能做出令人惊讶的产品，这就是工程的力量。而编程，是一项脑力劳动，不能像流水线的工人那么机械，需要自身的创作，所以会有艺术成分。像很多年以前的手工业者，也往往蕴涵艺术创作，随着时代发展，越来越倾向于工程创作。编程同样也是如此，尤其是大型项目，往往更侧重工程性而非艺术性。&lt;/p&gt;
&lt;h2 id=&#34;c-是一门艺术&#34;&gt;C++ 是一门艺术&lt;/h2&gt;
&lt;p&gt;如果认同上面的理论，那就很容易得出，C++是一门艺术，优秀的人能写出优雅的艺术作品，平庸的人几乎没办法避免滥用。所以在学习的时候，要非常审慎，避免误用造成涂鸦。&lt;/p&gt;
&lt;h2 id=&#34;可以这么用-vs-为什么要这么用&#34;&gt;可以这么用 vs 为什么要这么用&lt;/h2&gt;
&lt;p&gt;在学习C++，如果仅仅是知道语法，并不算学会了C++，如果看到一个语法，心里想，原来C++可以这么用，往往会误入歧途，正确的想法应该是想，为什么要有这样一个语法，用其他的语法替代会有什么优点和缺点，刨根追底，才会更好的避免误用。同时，每个C++语法的引入，都是旷日持久的讨论权衡的结果，通过理解引入的原因，也能增加自身的编程技艺。&lt;/p&gt;
&lt;h1 id=&#34;c11-编译&#34;&gt;C++11 编译&lt;/h1&gt;
&lt;p&gt;C++11 大多数情况下兼容之前版本，从C99版本升级到C++11，C++11扩充了关键字，如果之前代码有用到，需要替换，增加编译参数&lt;code&gt;c++11&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;g++ -std=c++11 test.cpp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;c11-语法&#34;&gt;C++11 语法&lt;/h1&gt;
&lt;h2 id=&#34;auto类型推断&#34;&gt;auto类型推断&lt;/h2&gt;
&lt;p&gt;auto 语法为了简化，一个是简化写法，一个是简化程序员心智，有时候不需要关心到底是什么类型。auto 语法很简单，但需要知道 auto 是在编译期间推断的类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        vector&amp;lt;int&amp;gt; vec;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        vec.push_back(1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        auto i = vec.begin();   // vector&amp;lt;int&amp;gt;::iterator
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果是编译期间推断，设想以下场景能否成立？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto func() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        int a = 10;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return a;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实以上写法不能编译通过，需要返回值后置语法。&lt;/p&gt;
&lt;h2 id=&#34;返回值后置语法&#34;&gt;返回值后置语法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto func() -&amp;gt; int {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        int a = 10;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return a;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实对于一般函数，这么使用毫无意义，这种语法常用的使用场景有两个，其中一种用法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Map {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    struct Cell {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int color;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Cell * GetCell(int x, int y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Cell * ClearCell(int x, int y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 返回值类型必须加域
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Map::Cell * Map::GetCell(int, int)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	return nullptr;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 使用返回值后置，不用加域
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto Map::ClearCell(int, int) -&amp;gt; Cell*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	return nullptr;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外一种用法是模板的返回值类型推断，需要结合decltype使用。&lt;/p&gt;
&lt;h2 id=&#34;decltype&#34;&gt;decltype&lt;/h2&gt;
&lt;p&gt;通过使用 decltype 语法，可以在编译期间获得auto或者其他变量的类型，进行定义同类型的新变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用decltype的其中一个好处，正如auto的好处，不用关心具体的类型，另外一个也是用在模板，通过非成员begin来说明。&lt;/p&gt;
&lt;h2 id=&#34;非成员begin--end&#34;&gt;非成员begin &amp;amp; end&lt;/h2&gt;
&lt;p&gt;经常使用stl的人应该很熟悉成员begin和end，分别表示起始和结束的迭代器，这也是标准库的统一接口。在C++11中引入了非成员begin和end，用法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int a[] = {2, 1, 3};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::sort(std::begin(a), std::end(a));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::vector&amp;lt;int&amp;gt; vec;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::sort(std::begin(vec), std::end(vec));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过使用方式来设计一下 std::begin 和 std::end 是如何实现的？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;template &amp;lt;class Container&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto end (Container&amp;amp; cont) -&amp;gt; decltype (cont.end());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;template &amp;lt;class T, size_t N&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;T* end (T(&amp;amp;arr)[N]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里也是 decltype 和 auto 的经典使用法，否则需要多一个模板参数才能实现，不方便调用。但仔细想下，非成员 begin 和 end 的作用其实只是统一了数组和容器，并没有太多可讲之处，不过这种统一方便了另外一个foreach语法。&lt;/p&gt;
&lt;h2 id=&#34;for-each&#34;&gt;for each&lt;/h2&gt;
&lt;p&gt;foreach 可以简化代码，让代码更清晰可读性更强，使用方法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int arr[] = {2, 2, 3, 8, 3};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for (auto v: arr) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for (auto &amp;amp; v : arr) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	v ++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之所以能做到foreach，得益于非成员begin&amp;amp;end，通过foreach的原理，自定义的容易，只要实现begin，end，operator[]操作符，调用方也可使用foreach语法。&lt;/p&gt;
&lt;h2 id=&#34;lambda-表达式&#34;&gt;lambda 表达式&lt;/h2&gt;
&lt;p&gt;lambda 表达式是C++11重点引入的语法之一，通过lambda表达式和闭包，可以使代码更为简洁，所谓&lt;em&gt;闭包&lt;/em&gt;，是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vector&amp;lt;int&amp;gt; vec;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::for_each(vec.begin(), vec.end(), [](int v){ cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; endl;});
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int out = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::for_each(vec.begin(), vec.end(), [&amp;amp;](int v){ cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#34;:&amp;#34; &amp;lt;&amp;lt; out++ &amp;lt;&amp;lt; endl;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;方括号内的符号表示外部变量的引用情况，具体信息如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[] // 没有定义任何变量。使用未定义变量会导致错误。&lt;/li&gt;
&lt;li&gt;[x, &amp;amp;y] // x 以传值方式传入(默认)，y 以引用方式传入。&lt;/li&gt;
&lt;li&gt;[&amp;amp;] // 任何被使用到的外部变量皆隐式地以引用方式加以使用。&lt;/li&gt;
&lt;li&gt;[=] // 任何被使用到的外部变量皆隐式地以传值方式加以使用。&lt;/li&gt;
&lt;li&gt;[&amp;amp;, x] // x 显示地以传值方式加以使用。其余变量以引用方式加以使用。&lt;/li&gt;
&lt;li&gt;[=, &amp;amp;z] // z 显示地以引用方式加以使用。其余变量以传值方式加以使用。&lt;/li&gt;
&lt;li&gt;[this] // 传递this指针，匿名函数可以像成员函数一样使用成员变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中&lt;code&gt;&amp;amp;&lt;/code&gt;引用传递需要注意外部变量的生命周期，如果是局部变量，一定要确保闭包的生命周期在局部变量之前完结。&lt;/p&gt;
&lt;p&gt;现在回头再想一下，&lt;code&gt;for_each&lt;/code&gt;是如何实现的呢？这就要用到 function。&lt;/p&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;p&gt;闭包也是一个对象，可以使用function模板类型的变量接收：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int TestFunction(int param, std::function&amp;lt;int(int)&amp;gt; fun) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	return fun(param);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int main() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int test = 100;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	int ret = TestFunction(100, [](int p) {cout &amp;lt;&amp;lt; &amp;#34;add:&amp;#34; &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl;return p+100;});
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;右值引用和move语义&#34;&gt;右值引用和move语义&lt;/h2&gt;
&lt;p&gt;在C++03及之前的标准，临时对象（称为右值&lt;code&gt;R-values&lt;/code&gt;，位于赋值运算符之右）无法被改变。C++11增加一个新的非常数引用类型，称作右值引用（R-value reference），标记为&lt;code&gt;T &amp;amp;&amp;amp;&lt;/code&gt;。右值引用所引用的临时对象可以在该临时对象被初始化之后做修改，这是为了允许move语义。&lt;/p&gt;
&lt;p&gt;简单来说，在C++中经常需要创建一些临时对象，对于小内存变量还好，对于有大块内存的变量，如string等，拷贝一次将会浪费很大的空间，而临时变量创建一次就需要销毁，造成性能的浪费，move语意可以方便的把临时变量中的内存，转移到另一个对象中（当然每个类转移的代码需要自己编写）。先来看一个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;string one = &amp;#34;TestOne String&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;string two = std::move(one);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cout &amp;lt;&amp;lt; &amp;#34;One:&amp;#34; &amp;lt;&amp;lt; one &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cout &amp;lt;&amp;lt; &amp;#34;Two:&amp;#34; &amp;lt;&amp;lt; two &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到很神奇的通过一次moe，one变量变成了空字串，one和two使用的是同一份内存空间，从one转移到了two。这一切是怎么实现的呢？接下来需要看下右值引用，先来看一下什么情况下会识别为右值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Elem {};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bool is_right_reference(Elem &amp;amp; elem)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return false;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bool is_right_reference(Elem &amp;amp;&amp;amp; elem)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return true;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Elem elem;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cout &amp;lt;&amp;lt; is_right_reference(Elem()) &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cout &amp;lt;&amp;lt; is_right_reference(elem) &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cout &amp;lt;&amp;lt; is_right_reference(std::move(elem)) &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过重载&lt;code&gt;is_right_reference&lt;/code&gt;函数，来识别传入的参数是否是右值（&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;是右值参数），可以看到，第一个输出不是右值，第二个是右值，很容易理解，第三个不是右值，通过&lt;code&gt;std::move&lt;/code&gt;却可以识别为右值。通过这种用法，可以写一个右值拷贝构造函数，实现当参数是右值时，把对方的内存空间转移到自身(通过右值引用可以修改右值)，从而完成move操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Elem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strdup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Create One Elem: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;rf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Create Elem By R-Refer: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Elem&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elem1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Elem&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elem2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，通过&lt;code&gt;std::move&lt;/code&gt;方式，修改了&lt;code&gt;elem&lt;/code&gt;地址，完成了&lt;code&gt;move&lt;/code&gt;操作。当然，如果原始值以后还有用处，就不要使用move语意，避免出现代码逻辑错误或者理解上的偏差。&lt;/p&gt;
&lt;h2 id=&#34;元组&#34;&gt;元组&lt;/h2&gt;
&lt;p&gt;C++11标准库提供了&lt;code&gt;std::tuple&lt;/code&gt;类，可以方便的把若干不同类型元素集合在一起：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::tuple&amp;lt;int, int, int&amp;gt; fun() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	return std::make_tuple(1, 2, 3);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int a, b, c;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::tie(a, b, c) = fun();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto t = fun();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int one = std::get&amp;lt;0&amp;gt;(t);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;tuple&lt;/code&gt;只是一个类库，可以设想一下这个类库如何实现？这里就要用到新的语法，变长参数模板。&lt;/p&gt;
&lt;h2 id=&#34;变长参数模板&#34;&gt;变长参数模板&lt;/h2&gt;
&lt;p&gt;C++11 支持可变长参数的模板，类似可变长参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;template&amp;lt;typename ... Types&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;struct Tuple {};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;template&amp;lt;typename ... Types&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int Size() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return sizeof...(Types);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tuple &amp;lt;int, char&amp;gt; t1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cout &amp;lt;&amp;lt; Size&amp;lt;int, int, char&amp;gt;() &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里只是简单展示一下语法，这里的Tuple是没有任何意义的，因为不管多少参数，最终定义都等同于空结构体。要想实现更丰富的语法，就需要用到模板的特化，以下是一个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void Print() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;template&amp;lt;typename T, typename ... Types&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void Print(T t, Types... other) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Print(other...);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Print(1, 2, 3, 10, &amp;#39;a&amp;#39;, &amp;#34;is string&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;nullptr&#34;&gt;nullptr&lt;/h2&gt;
&lt;p&gt;nullptr 的出现主要是为了替换NULL，为什么需要一个 nullptr 呢？那就得看下NULL在使用过程中会有什么问题。NULL在C/C++中只是一个宏：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define NULL 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define NULL ((void *)0)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在C++中之所以定义成0，因为C++是强类型语言，&lt;code&gt;void *&lt;/code&gt;不能隐式复制给其他类型，要想实现&lt;code&gt;int * p = NULL;&lt;/code&gt;这样的表达式，只能定义成0。在C++中建议使用0来表示空指针而不是NULL，因为C++的重载：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void func(int *p);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void func(int i);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调用方使用 &lt;code&gt;func(NULL)&lt;/code&gt; 实际上调用的是&lt;code&gt;void func(int i);&lt;/code&gt;，但NULL给人的信息是空指针，表意跟实际运行不同，会误导我们以为调用的是&lt;code&gt;void func(int *p);&lt;/code&gt;，从而产生隐晦的错误，为了防止这种问题出现，于是 nullptr 被引入了，表示空指针，从而终结了0和NULL的各种说不清道不明的关系。&lt;/p&gt;
&lt;h2 id=&#34;override--final&#34;&gt;override &amp;amp; final&lt;/h2&gt;
&lt;p&gt;override 和 final 相对含义比较清楚，在之前的版本，对类继承重写等并没有太多限制，可能会由于编码错误等原因误用，C++11中加强了这方面的语法检查：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Shape {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	virtual void draw() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cout &amp;lt;&amp;lt; &amp;#34;draw one shape&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	virtual ~Shape() {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Circle : public Shape {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	void draw() override {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cout &amp;lt;&amp;lt; &amp;#34;draw one circle&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显式声明为override，如果因为参数等原因，不构成继承，在编译期间将会出错，建议重写继承的函数都添加override标识。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Shape {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	virtual void draw() final {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cout &amp;lt;&amp;lt; &amp;#34;draw one shape&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	virtual ~Shape() {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Circle : public Shape {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	// override will failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	void draw() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cout &amp;lt;&amp;lt; &amp;#34;draw one circle&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;试图去重写final函数，将会在编译期失败，另外final函数必须修饰virtual函数，否则会编译失败。下面是使用final标识禁止类被继承的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class FinalClass final {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// complie failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class SubClass : public FinalClass {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;委托构造函数&#34;&gt;委托构造函数&lt;/h2&gt;
&lt;p&gt;在C++03以前，构造函数不能相互调用，要想重用代码，必须写一个类似Init的函数，不同的构造函数都去调用，在C++11中，构造函数可以相互调用，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Default&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然使用起来比较方便，不过到底是使用Init函数集中初始化好呢，还是构造函数相互调用更清晰？这就看具体的问题了。&lt;/p&gt;
&lt;h2 id=&#34;使用默认或禁用函数&#34;&gt;使用默认或禁用函数&lt;/h2&gt;
&lt;p&gt;C++11允许显式地表明采用或拒用编译器提供的内置函数。例如要求类带有默认构造函数，可以用以下的语法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;struct SomeType
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  SomeType() = default;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  SomeType(OtherType value);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也可以禁止编译器自动产生某些函数。如下面的例子，类不可复制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NonCopyable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;NonCopyable&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NonCopyable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;NonCopyable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NonCopyable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;NonCopyable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁止成员函数以特定的形参调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;struct NoDouble
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	void f(int i);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    void f(double) = delete;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;constexpr&#34;&gt;constexpr&lt;/h2&gt;
&lt;p&gt;类似const，但比const更加严格，声明为constexpr的变量，取值必须在编译器间获得，否则编译出错。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;运行期间取值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constexpr编译期间取值&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，编译出错&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;没有问题&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c5&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;返回值函数，没有问题&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c6&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c7&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;试图通过非常量取值，编译出错&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;cin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;声明为&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constexpr返回值的函数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，并不限制必须返回常量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;容器初始化列表&#34;&gt;容器初始化列表&lt;/h2&gt;
&lt;p&gt;C++11 支持通过数组初始化容器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::vector&amp;lt;int&amp;gt; vec = {1, 2, 3, 4};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的实现是通过模板&lt;code&gt;template&amp;lt;class T&amp;gt; class initializer_list;&lt;/code&gt;，下面通过一个简单的例子展示如何让自己的类通过列表初始化：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class TestInit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        TestInit(initializer_list&amp;lt;int&amp;gt; list) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                for (auto k : list) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                        cout &amp;lt;&amp;lt; &amp;#34;TEST:&amp;#34; &amp;lt;&amp;lt; k &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TestInit a = {1, 3, 5, 7};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;reference-wrapper&#34;&gt;reference wrapper&lt;/h2&gt;
&lt;p&gt;看一个模板的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;inc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一次call调用以后，i值没有变化，因为模板推导时，P自动推导成了int，call的第二个参数是int有一次值拷贝，通过使用&lt;code&gt;std::ref&lt;/code&gt;，显示的指定这应该推导为引用，即能修改i的值。&lt;/p&gt;
&lt;h2 id=&#34;强类型枚举&#34;&gt;强类型枚举&lt;/h2&gt;
&lt;p&gt;在C++中，enum枚举类型与define类似，定义了一个常量，可以与整型相互转换与比较，这样往往违背了enum的初衷，C++11中增加了强类型枚举：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;One&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Two&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Three&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;One&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Two&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Three&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;CType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctype&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;One&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;ctype&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Two&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctype&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;EType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;etype&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Two&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;etype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;etype&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CType 为类型更强的枚举，没法cout输出，也不能跟整数相互转换。&lt;/p&gt;
&lt;h1 id=&#34;c11-扩展库&#34;&gt;C++11 扩展库&lt;/h1&gt;
&lt;h2 id=&#34;智能指针&#34;&gt;智能指针&lt;/h2&gt;
&lt;p&gt;智能指针的作用应该都比较清楚，为了防止内存泄漏，或者野指针，C++11在这方面也做了很多工作，先来看最基本的&lt;code&gt;shared_ptr&lt;/code&gt;，每当复制出来一份副本，引用计数+1，当所有副本都销毁时，内存也会被释放：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Shape {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Shape() {cout &amp;lt;&amp;lt; &amp;#34;Create&amp;#34; &amp;lt;&amp;lt; endl;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	~Shape() {cout &amp;lt;&amp;lt; &amp;#34;Destroy&amp;#34; &amp;lt;&amp;lt; endl;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;std::shared_ptr&amp;lt;Shape&amp;gt; outer;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	std::shared_ptr&amp;lt;Shape&amp;gt; share(new Shape);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    outer = share;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;outer.reset();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个比较好理解，接下来看下&lt;code&gt;weak_ptr&lt;/code&gt;。有了&lt;code&gt;shared_ptr&lt;/code&gt;似乎能解决大多数问题了，为什么还需要&lt;code&gt;weak_ptr&lt;/code&gt;呢？这跟所有权有关系，设想一个对象A，有一个属性P对象，但B对象有时需要使用P，如果使用&lt;code&gt;shared_ptr&lt;/code&gt;，A对象销毁后，A的属性P还存在于B对象，这从设计上不合理，这里就可以使用&lt;code&gt;weak_ptr&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void CheckWeakPtr(shared_ptr&amp;lt;Shape&amp;gt; share) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	static weak_ptr&amp;lt;Shape&amp;gt; weak = share;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	if (auto ptr = weak.lock()) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cout &amp;lt;&amp;lt; &amp;#34;Weak Locked&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	else {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		cout &amp;lt;&amp;lt; &amp;#34;Weak Expired&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		std::shared_ptr&amp;lt;Shape&amp;gt; share(new Shape);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		CheckWeakPtr(share);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	CheckWeakPtr(nullptr);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外还有一个&lt;code&gt;unique_ptr&lt;/code&gt;，它持有对象的独有权，两个&lt;code&gt;unique_ptr&lt;/code&gt;不能指向一个对象，不能进行复制操作只能进行移动操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int main()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        std::unique_ptr&amp;lt;int&amp;gt; p1(new int);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // std::unique_ptr&amp;lt;int&amp;gt; p2 = p1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        std::unique_ptr&amp;lt;int&amp;gt; p2 = std::move(p1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;散列表&#34;&gt;散列表&lt;/h2&gt;
&lt;p&gt;stl 的 set，和map都是红黑树变种实现，在C++11版本中引入四种了hash实现，分别为：&lt;code&gt;unordered_set&lt;/code&gt;, &lt;code&gt;unordered_map&lt;/code&gt;, &lt;code&gt;unordered_multimap&lt;/code&gt;, &lt;code&gt;unordered_multiset&lt;/code&gt;，如果之前用过set和map，这四种分别表示什么也很容易理解，只不过换成了hash表实现，set和map是根据大小创建红黑树，所以只要重载&lt;code&gt;operator &amp;lt;&lt;/code&gt;即可，在&lt;code&gt;unordered_set&lt;/code&gt;中，使用hash表，当然需要提供一个自定义函数了，参照前面的hash实现，另外，通过hash不能判断两个元素是否相同，还需要重载&lt;code&gt;operator==&lt;/code&gt;运算符，&lt;code&gt;unordered_set&lt;/code&gt;的声明如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;template &amp;lt; class Key,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           class Hash = hash&amp;lt;Key&amp;gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           class Pred = equal_to&amp;lt;Key&amp;gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           class Alloc = allocator&amp;lt;Key&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &amp;gt; class unordered_set;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用法跟set、map相同。需要了解的是，Hash表实现必然会遇到冲突，unorder系列容器创建一个buckets数组存放hash后的元素，落在同一个buckets中的元素使用链表方式存储。随着元素的增多，冲突的概率也会变大，标准库使用一个因子&lt;code&gt;load_factor&lt;/code&gt;表示当前的冲突概率，算法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;因子&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;元素数量&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;load_factor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket_count&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当&lt;code&gt;load_factor&lt;/code&gt;大于等于&lt;code&gt;max_load_factor&lt;/code&gt;时，调用&lt;code&gt;rehash&lt;/code&gt;进行重新hash，这时需要重新拷贝数据，对性能影响很大。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;unordered_set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;默认最大&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load_factor是1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_load_factor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load_factor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;默认&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket数量是11&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;获取最大&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket数量&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，由系统或者算法决定&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_bucket_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;获取第&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket元素数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;重新分配&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，大小向上取素数，默认情况下扩大一倍向上取素数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;复杂度，最好情况下&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，最坏情况下&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rehash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;real&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;103&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;max_load_factor&lt;/code&gt; 有重载的带参数函数，可进行设置，由调用者决定最大因子。rehash后迭代器失效，但对于取出来的独立的元素地址或者引用，是可以继续使用的。&lt;/p&gt;
&lt;h2 id=&#34;hash&#34;&gt;hash&lt;/h2&gt;
&lt;p&gt;hash 的实现使用了模板，用法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;unordered_set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;ne&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;s1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;s2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;
&lt;p&gt;C++11标准库提供了多线程支持，可以用很简单的方法创建线程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void thread_task() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cout &amp;lt;&amp;lt; &amp;#34;one task begin.&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        std::chrono::milliseconds dura(3000);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        std::this_thread::sleep_for(dura);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cout &amp;lt;&amp;lt; &amp;#34;one task end.&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int main() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        std::thread t(thread_task);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        t.join();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外还有若干锁的支持，具体可参阅手册：&lt;a class=&#34;link&#34; href=&#34;http://en.cppreference.com/w/cpp/thread&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://en.cppreference.com/w/cpp/thread&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;升级老代码到c11&#34;&gt;升级老代码到C++11&lt;/h1&gt;
&lt;p&gt;C++11 兼容大部分语法，升级的时候只需要增加&lt;code&gt;-std=c++11&lt;/code&gt;即可，不过多数情况下升级并没有这么简单，需要几点注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字扩充，如果之前的老代码有使用C++11的关键字作为变量，需要替换变量名&lt;/li&gt;
&lt;li&gt;C++11语法更为严格，如没有引入头文件，某些隐式转换，会变成编译错误，需要加入头文件或者强制转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;最后总结一下，C++11主要是在代码的简化上做了优化，如auto，lambda，尤其是加强了模板的功能，通过模板和库来提升语言的表达能力，之前的C++版本，语法即语法，库即库，C++11中可以看到更多的是语法和库密不可分，融为一体。而且在尽量消除一些隐晦的错误，如nullptr，final等。&lt;/p&gt;
&lt;p&gt;另外，C++的设计者始终秉承一个原则，就是你不知道的语法对你不会有任何影响，不论是性能上还是代码编写上，所以，不论是否精通C++的各种语法，只要知道一个子集，便能写出很好的代码，贪多不一定是好事。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;wikipedia : &lt;a class=&#34;link&#34; href=&#34;http://zh.wikipedia.org/wiki/C%2B%2B11&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://zh.wikipedia.org/wiki/C%2B%2B11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cppreference : &lt;a class=&#34;link&#34; href=&#34;http://en.cppreference.com/w/cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://en.cppreference.com/w/cpp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Latex 数学公式整理</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex-formula/</link>
        <pubDate>Fri, 15 Apr 2011 22:40:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex-formula/</guid>
        <description>&lt;h1 id=&#34;基本字符&#34;&gt;基本字符&lt;/h1&gt;
&lt;p&gt;大多数普通字符跟数学公式中的是一样的，除了：&lt;code&gt;#$%&amp;amp;~_^\{}&lt;/code&gt;，这几个，如果需要表示，需要使用&lt;code&gt;\&lt;/code&gt;进行转义。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;\$a = \{\}.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示为：&lt;/p&gt;
&lt;p&gt;$$\$a = \{\}.$$&lt;/p&gt;
&lt;h1 id=&#34;上标和下标&#34;&gt;上标和下标&lt;/h1&gt;
&lt;p&gt;公式中使用&lt;code&gt;^&lt;/code&gt;表示上标，使用&lt;code&gt;_&lt;/code&gt;表示下标，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x_1^2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x_{y^2}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示为：&lt;/p&gt;
&lt;p&gt;$$x_1^2$$&lt;/p&gt;
&lt;p&gt;$$x_{y^2}$$&lt;/p&gt;
&lt;h1 id=&#34;分式&#34;&gt;分式&lt;/h1&gt;
&lt;p&gt;分式的写法为：&lt;code&gt;\frac{分子}{分母}&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;\frac{10}{5}=2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示为：&lt;/p&gt;
&lt;p&gt;$$\frac{10}{5}=2$$&lt;/p&gt;
&lt;h1 id=&#34;根式&#34;&gt;根式&lt;/h1&gt;
&lt;p&gt;二次根式表达为：&lt;code&gt;\sqrt{表达式}&lt;/code&gt;，n 次根式表达为：&lt;code&gt;\sqrt[n]{表达式}&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;\sqrt{a}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;\sqrt[3]{a}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示为：&lt;/p&gt;
&lt;p&gt;$$\sqrt{a}$$
$$\sqrt[3]{a}$$&lt;/p&gt;
&lt;h1 id=&#34;数学公式&#34;&gt;数学公式&lt;/h1&gt;
&lt;p&gt;数学函数前加&lt;code&gt;\&lt;/code&gt;，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;\sin x
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;\sum_{x=1}^n a_n=\frac{(a_1+a_n)n}{2}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示为：&lt;/p&gt;
&lt;p&gt;$$\sin x$$&lt;/p&gt;
&lt;p&gt;$$\sum_{x=1}^n a_n=\frac{(a_1+a_n)n}{2}$$&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Objective-C 简明教程</title>
        <link>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/objective-c-brief-course/</link>
        <pubDate>Sun, 10 Apr 2011 22:40:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/objective-c-brief-course/</guid>
        <description>&lt;p&gt;本文假定读者具备c语言或者其他语言的背景，快速上手Objective-C，或做参考之用。&lt;/p&gt;
&lt;h1 id=&#34;基础&#34;&gt;基础&lt;/h1&gt;
&lt;h2 id=&#34;c语言的扩展&#34;&gt;C语言的扩展&lt;/h2&gt;
&lt;p&gt;Objective-C很大程度上兼容C语言，是C语言的扩展，所有以&lt;code&gt;@&lt;/code&gt;开头的语言，都是扩展语法。在Objective-C中写C/C++是很容易的事情，只需要使用.cpp文件即可，Objective-C完全兼容。虽然OC是兼容C++的，但如果使用后缀m的文件编译，会找不到标准stl库，需要修改m后缀为mm。&lt;/p&gt;
&lt;h2 id=&#34;hello-world&#34;&gt;Hello World&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#import &amp;lt;Foundatioin/Foundation.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;NSLog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Objective-C头文件以.h结尾，源文件以.m结尾。&lt;/p&gt;
&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;
&lt;p&gt;Objective-C 注释与 C++ 相同，符号： &lt;code&gt;//&lt;/code&gt; 或者 &lt;code&gt;/* */&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;导入&#34;&gt;导入&lt;/h2&gt;
&lt;p&gt;与C语言中的 &lt;code&gt;#include &amp;lt;&amp;gt;&lt;/code&gt; 相对应的导入 &lt;code&gt;#import &amp;lt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;
&lt;p&gt;Objective-C 中的基本类型同C，包括 &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; 等。另外，在&lt;code&gt;Foundation&lt;/code&gt;库中，这些类型还定义了别名，&lt;code&gt;NSInteger&lt;/code&gt;对应有符号整数，&lt;code&gt;NSUInteger&lt;/code&gt;对应无符号整数，&lt;code&gt;CGFloat&lt;/code&gt;对应浮点数，&lt;code&gt;BOOL&lt;/code&gt;对应布尔值。&lt;/p&gt;
&lt;p&gt;数字对应的对象还有 &lt;code&gt;NSNumber&lt;/code&gt;，可以跟基本的数字类型相互转化，详细信息可参阅 &lt;a class=&#34;link&#34; href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNumber_Class/index.html#//apple_ref/occ/instp/NSNumber/longValue&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NSNumber Class Reference&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;字符串&#34;&gt;字符串&lt;/h2&gt;
&lt;p&gt;常量字符串可以用&lt;code&gt;@&amp;quot;&amp;quot;&lt;/code&gt;结构表示，另外变量使用&lt;code&gt;NSString&lt;/code&gt;表示不可变字符串 ，&lt;code&gt;NSMutableString&lt;/code&gt;表示可变字符串。具体&lt;code&gt;NSString&lt;/code&gt;和普通C字符串的转换，可参阅&lt;a class=&#34;link&#34; href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/instp/NSString/UTF8String&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NSString Class Reference&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;之前提到的，在Objective-C中可以无障碍使用C语言的数据，不过OC还提供了数组类 &lt;code&gt;NSArray&lt;/code&gt;和&lt;code&gt;NSMutableArray&lt;/code&gt;，前者是不能修改的数组，后者支持增删操作，具体用法示例如下。&lt;/p&gt;
&lt;p&gt;插入操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NSMutableArray * array = [NSMutableArray arrayWithCapacity:50];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[array addObject:[NSNumber numberWithUnsignedLongLong:123]];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[array addObject:[NSNumber numberWithUnsignedLongLong:456]];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遍历操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;NSLog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Array Size: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%u&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userIdList&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;one&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;NSLog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;%@&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;objectAtIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;two&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;NSEnumerator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enumerator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;objectEnumerator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ob&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enumerator&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nextObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;NSLog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;%@&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;three&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NSNumber&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isKindOfClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NSNumber&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;NSLog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Elem: %llu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unsignedLongLongValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看出，&lt;code&gt;NSArray&lt;/code&gt;可以插入任何对象，遍历可使用&lt;code&gt;isKindOfClass&lt;/code&gt;识别哪种数据类型。详细的操作可参照&lt;a class=&#34;link&#34; href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/index.html#//apple_ref/occ/cl/NSMutableArray&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NSMutableArray Class Reference&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;面向对象&#34;&gt;面向对象&lt;/h1&gt;
&lt;h2 id=&#34;interface&#34;&gt;interface&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@interface Circle : NSObject
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ShapeColor fillColor;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void) setFillColor : (ShapeColor) fillColor;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void) draw;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;程序开始 &lt;code&gt;@interface&lt;/code&gt; 表示C的扩展语法，表示接口，继承自&lt;code&gt;NSObject&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ShapeColor fillColor;&lt;/code&gt; 声明了成员&lt;/li&gt;
&lt;li&gt;&lt;code&gt;- (void) draw;&lt;/code&gt;表示方法，前面的括号中表示方法的返回类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;- (void) setFillColor : (ShapeColor) fillColor;&lt;/code&gt; 冒号后面的部分，表示有一个参数 &lt;code&gt;fillColor&lt;/code&gt;，类型是&lt;code&gt;ShapeColor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方法调用&#34;&gt;方法调用&lt;/h2&gt;
&lt;p&gt;Objective-C 调用对象方法的基本语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[object method];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[object methodWithInput:input];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样可以调用类的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;id myObject = [NSString string];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中&lt;code&gt;id&lt;/code&gt;表示&lt;code&gt;myObject&lt;/code&gt;类型，可以承载任何对象。&lt;/p&gt;
&lt;p&gt;在很多语言中支持嵌套调用，如&lt;code&gt;function1 ( function2() );&lt;/code&gt;，Objective-C中可以同样可以写为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[NSString stringWithFormat:[prefs format]];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;多参数调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 声明：-(BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BOOL result = [myData writeToFile:@&amp;#34;/tmp/log.txt&amp;#34; atomically:NO];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;implementation&#34;&gt;implementation&lt;/h2&gt;
&lt;p&gt;之前的&lt;code&gt;interface&lt;/code&gt;只是声明了接口，具体的实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@implementation Circle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void) setFillColor: (ShapeColor) c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fillColor = c;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void) draw
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    NSLog(@&amp;#34;drawing&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始 &lt;code&gt;@implementation Circle&lt;/code&gt; 表示为某个类提供代码。&lt;/li&gt;
&lt;li&gt;接下来是方法定义，&lt;code&gt;fillColor = c&lt;/code&gt; 隐含 &lt;code&gt;self-&amp;gt;fillColor&lt;/code&gt;，表示当前对象的成员，调用方法时，&lt;code&gt;circle setFillColor: kRedColor&lt;/code&gt;，方法将&lt;code&gt;circle&lt;/code&gt;作为&lt;code&gt;self&lt;/code&gt;参数进行传递。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@interface&lt;/code&gt;属性定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 头文件
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@interface TestMessage : NSObject {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    NSMutableArray * elems;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@property(nonatomic,retain) NSMutableArray* elems;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@end
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 实现文件
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@implementation IMMessage
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@synthesize elems;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键字&lt;code&gt;@property&lt;/code&gt;和&lt;code&gt;@synthesize&lt;/code&gt;含义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 头文件中：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@property int count;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 等效为声明两个方法：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (int)count;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void)setCount:(int)newCount;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 实现文件中：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@synthesize count;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 等效两个方法的实现
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (int)count
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	return count;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-(void)setCount:(int)newCount
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	count = newCount;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;声明property的语法格式为：&lt;code&gt;@property (参数1,参数2) 类型 名字;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数的含义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;readwrite: 产生setter\getter方法
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;readonly: 只产生简单的getter,没有setter。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;assign: 默认类型,setter方法直接赋值，而不进行retain操作
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;retain: setter方法对参数进行release旧值，再retain新值。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;copy: setter方法进行Copy操作，与retain一样
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nonatomic: 禁止多线程，变量保护，提高性能
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;实例化&#34;&gt;实例化&lt;/h2&gt;
&lt;p&gt;对象的实例化：&lt;code&gt;shape = [Circle new];&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;私有成员&#34;&gt;私有成员&lt;/h2&gt;
&lt;p&gt;对于私有变量，可以在 &lt;code&gt;.m&lt;/code&gt;文件中声明一个 &lt;code&gt;name&lt;/code&gt; 私有变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@interface Circle (){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    NSString* name;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于私有方法，可以实现为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@interface Circle (Private)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (NSString*) GetName;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;class&#34;&gt;@class&lt;/h2&gt;
&lt;p&gt;当两个类有循环依赖，如A类引用到B，B类又引用到A，import的时候没办法把两个类都放到自身前面，无法编译通过，这事可以A类中使用&lt;code&gt;@class B&lt;/code&gt;来声明有一个类B，具体实现在其他地方，来解决循环依赖问题。&lt;/p&gt;
&lt;h1 id=&#34;高级特性&#34;&gt;高级特性&lt;/h1&gt;
&lt;h2 id=&#34;selector&#34;&gt;selector&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Objective-C&lt;/code&gt;中的方法调用就是消息传递，除了使用&lt;code&gt;[]&lt;/code&gt;来传递消息以外，还有一种在运行期间进行消息传递的方法，就是&lt;code&gt;selector&lt;/code&gt;方式，不同参数的消息传递如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 无参数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void) fooNoInputs {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	NSLog(@&amp;#34;Does nothing&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[self performSelector:@selector(fooNoInputs)];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 一个参数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void) fooOneIput:(NSString*) first {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	NSLog(@&amp;#34;Logs %@&amp;#34;, first);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[self performSelector:@selector(fooOneInput:) withObject:@&amp;#34;first&amp;#34;];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 多个参数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- (void) fooFirstInput:(NSString*) first secondInput:(NSString*) second {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	NSLog(@&amp;#34;Logs %@ then %@&amp;#34;, first, second);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[self performSelector:@selector(fooFirstInput:secondInput:) withObject:@&amp;#34;first&amp;#34; withObject:@&amp;#34;second&amp;#34;];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，在&lt;code&gt;selector&lt;/code&gt;中可以使用&lt;code&gt;onThread&lt;/code&gt;参数指定所执行方法的线程。&lt;/p&gt;
&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;
&lt;p&gt;在之前的OC版本中，需要对象操作&lt;code&gt;alloc&lt;/code&gt;，&lt;code&gt;release&lt;/code&gt;等手工进行分配释放，一旦管理不善，容易出现内存泄漏或者崩溃。在Xcode 4.2中，增加了自动引用计数&lt;code&gt;Automatic Reference Counting, ARC&lt;/code&gt;，不需要开发者考虑&lt;code&gt;release&lt;/code&gt;的问题，详情可参考&lt;a class=&#34;link&#34; href=&#34;http://www.oschina.net/translate/objc-automatic-reference-counting-in-xcode-explained&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;理解 Objective-C 的 ARC&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;参考资源&#34;&gt;参考资源&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://cocoadevcentral.com/d/learn_objectivec/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://cocoadevcentral.com/d/learn_objectivec/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>一切尽在掌握</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/everything-under-control/</link>
        <pubDate>Wed, 12 Jan 2011 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/everything-under-control/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;长兄于病视神，未有形而除之，故名不出于家。中兄治病，其在毫毛，故名不出于闾。若扁鹊者，镵血脉，投毒药，副肌肤，闲而名出闻于诸侯。———— 扁鹊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于一个&lt;code&gt;7*24&lt;/code&gt;小时对外服务的架构，一定要对服务的各个方面极致的掌控，做到“一切尽在掌握”，面对服务心中不是模糊的、可能的，而是确定的。下面通过各个方面来说明如何做到一切尽在掌握。&lt;/p&gt;
&lt;p&gt;下面从一个设计一个服务的各个方面来简单介绍一下如何做到尽在掌握，开发一个服务，分为几个阶段，每个阶段都有自身着重需要关注的点，这里从 设计之初-&amp;gt;开发过程-&amp;gt;发布过程-&amp;gt;上线运营几个方面来介绍，其实开发阶段能够掌控的非常有限，大多数的问题和要点都需要在设计之初关注，而且可以发现，这篇文章所介绍的要点大都是防御性方法，可能会让人觉得谨小慎微，但对重要的服务而言，正需要开发者怀着敬畏之心。&lt;/p&gt;
&lt;h1 id=&#34;性能&#34;&gt;性能&lt;/h1&gt;
&lt;p&gt;对于一个Server，很多人都会觉得性能是一个服务最重要的方面，有时甚至会认为写一个服务就是尽可能提升性能，性能越好，服务就被评价为写的越好。但其实不然，首先在当前的硬件水平和操作系统提供的优化的基础上，想要实现一个不错的性能的服务，是轻而易举的，而且目前开源框架非常成熟，选择一个适合自身服务的也非常容易；其次，出现性能问题往往在于架构的设计上，而不是单机所能处理的性能，在互联网时代，基本上不存在只有单机的服务；再者，如果想提升一倍的性能需要很多人力很长时间，但是如果服务设计能够水平扩展，想提升一倍性能只要增加一倍机器即可；最后，虽然每个人都希望服务的性能尽可能好，但真正需要很高性能的服务却并不多，并不一定性能越高越好，适合业务需要的性能才是最好的设计，设计一个服务要做到低成本高可用。&lt;/p&gt;
&lt;p&gt;但是性能是不是不重要呢？当然不是，尤其是面对海量用户的服务，比如任何一个模块都上百台机器，增加一倍的性能成本消耗是非常可观的成本，大多数开发者都会写Demo进行性能验证，但其实在设计之初，就应该对服务的性能情况了如指掌。&lt;/p&gt;
&lt;p&gt;对性能时常有个误解，通过测试数据去优化，但是性能测试往往滞后，其实要在设计之初做好规划，要对系统、组件、依赖的性能都了如指掌，未必要了解期代码，但必须了解其实现。&lt;/p&gt;
&lt;p&gt;比如&lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/linux-performance-kernel.html#toc_4&#34; &gt;性能调优之函数调用&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/linux-performance-hardware.html#toc_4&#34; &gt;硬件性能参数&lt;/a&gt;两张表，一些常用的操作或者逻辑性能，需要了然于胸，这样在设计服务的时候，可以快速的在脑海中定位到性能瓶颈，并预知到服务所能处理的请求量。比如锁操作，每秒只可以执行10000000次，远大于所能处理的请求量，真正应该担心的不是锁造成的开销，而是某一资源的竞态。&lt;/p&gt;
&lt;p&gt;设计一个服务，在设计阶段需要预先计算以下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延迟：每个请求预计的耗时，这里主要计算网络耗时和磁盘耗时&lt;/li&gt;
&lt;li&gt;每秒处理能力：需要考虑服务的性能瓶颈，预算处理能力，这个指标也是衡量一个服务的最重要指标&lt;/li&gt;
&lt;li&gt;容量：一台机器能够存储多少用户数据，总共需要多少存储，能够存储几天，增长曲线如何等&lt;/li&gt;
&lt;li&gt;吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;架构设计&#34;&gt;架构设计&lt;/h1&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;p&gt;缓存是服务性能的加速器，一个好的缓存方案能够极大的提升服务性能，设计缓存需要考虑几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存的命中率：对某些运算结果进行缓存或者某些数据缓存，在设计的时候要预估命中率&lt;/li&gt;
&lt;li&gt;缓存的更新：缓存的数据是否能够得到及时更新，更新时延是否能够满足业务需求&lt;/li&gt;
&lt;li&gt;缓存重启：当大面积缓存机器重启时，是否会对后端服务造成很大压力导致雪崩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存具体的设计方案与业务息息相关，需要针对不同的情况缓存合理的数据。&lt;/p&gt;
&lt;h2 id=&#34;伸缩性&#34;&gt;伸缩性&lt;/h2&gt;
&lt;p&gt;服务提供方也许经常会由于做活动，或者某些爆发事件导致请求量急剧增长，面对这类服务，要考虑很好的伸缩性，在需要扩容的时候，扩容的时延级别是什么样的，分钟级、小时级、还是天级。&lt;/p&gt;
&lt;p&gt;对于无状态服务，扩容往往很简单，增加机器并部署即可，区别在于这个过程是否需要手工干预，但对于有状态服务，扩容时需要把数据进行分片复制，除非是做分布式存储的业务，否则建议尽量使用适合业务模型的可以动态扩容的分布式存储。对于业务方，更需要考虑缓存的动态扩容，比如使用一致性Hash，尽量减少增删机器时缓存的失效比率。&lt;/p&gt;
&lt;p&gt;另外根据业务的不同，有些业务可能会瞬时的请求量暴增，比如QQ业务，在除夕夜会造成请求量突增，但由于原本体量过大，不会有很多倍的暴涨。但对于微博则不同，预留几倍的性能空间是非常必要的，又比如秒杀业务，瞬时请求又会高的惊人。事先考虑伸缩性以及预留足够的扩容时延空间，可以很好的应对请求量和用户量迅速上涨的情况。&lt;/p&gt;
&lt;h2 id=&#34;重试过载保护&#34;&gt;重试/过载保护&lt;/h2&gt;
&lt;p&gt;在调用一个服务接口时，会出现三种情况，成功、失败、超时，其中成功和失败相对容易处理，但对于超时，可能对方已经操作成功，只是还未来得及回包，或者处理失败，对于调用者来说无法知道是哪种情况，而且为了服务质量，提升成功率，必须要做重试处理，当然，有了重试就需要去重，服务提供方需要有机制确保同样的请求调用多次不会出现问题。&lt;/p&gt;
&lt;p&gt;当然，如果服务提供方由于请求量暴涨，或者内部处理异常的原因导致无法处理当前的请求量，比如服务一秒钟只能处理8k请求量，当请求量达到1w时，表面上看起来有2k请求量无法处理，不过由于请求方重试，导致下一秒请求量增长到1w2，而服务还在处理上一秒的2k请求，这样会导致处理方永远处理的是已经超时的请求，而且随着请求方重试，又会导致请求量不断上涨，造成“雪崩”，所以在设计服务的时候，需要考虑雪崩情况下的过载保护，由于处理能力已经跟不上请求量，造成2k/s的请求失败是必然的，要果断抛弃不能正常处理的请求，起码能够服务百分之80的用户。&lt;/p&gt;
&lt;h2 id=&#34;冷热分离&#34;&gt;冷热分离&lt;/h2&gt;
&lt;p&gt;有些情况下为了提升性能，又需要把冷数据和热的数据分离，根据需要可以对最近的经常使用的数据保存在内存或者SSD磁盘，对很久之前的访问量较少的数据保存在磁盘，当然相关的策略都需要根据业务进行决策。当然设计冷热数据交互沉淀的系统复杂度较高，没有十分的必要，尽量使用缓存的方式。&lt;/p&gt;
&lt;h1 id=&#34;自动测试&#34;&gt;自动测试&lt;/h1&gt;
&lt;p&gt;自动化测试对于开发来讲并不是必须的，但如果有自动测试的服务，稳定性会的到质的提升，关于自动测试可以参考文章&lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/thinking-in-unit-tests.html&#34; &gt;单元测试的思考&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;灰度染色&#34;&gt;灰度染色&lt;/h1&gt;
&lt;p&gt;所谓灰度，就是指介于黑和白之间，比如新功能发布过程中，先找一部分灰度用户试用，根据反馈情况再决定是进一步扩大还是做一些调整，在发布过程中也可以使用灰度策略，先发布部分机器或者用户，可以及早的在小范围内发现问题，及时修复。&lt;/p&gt;
&lt;p&gt;灰度的粒度可大可小，往小了说可以只对某些人生效，比如开发人员和产品人员；再扩大可以为全公司内部人员；或者可以灰度某个号段或者活跃/非活跃用户。&lt;/p&gt;
&lt;p&gt;灰度可以用在开发、发布、运营的不同阶段，下面逐一举例：&lt;/p&gt;
&lt;h2 id=&#34;功能灰度&#34;&gt;功能灰度&lt;/h2&gt;
&lt;p&gt;产品上开发了某个新功能，但不知道功能的效果如何，比如优化了某种算法，分别对不同的用户使用不同的算法，对比其反馈效果，这也就是常说的AB Test，可以通过试错的方式快速迭代产品。另外从开发的角度，可能重构了部分模块代码，或者新功能尚不稳定，可以先开放给内部用户使用，通过数据上报或者人工反馈的方式，在开放给外部用户之前，预先通过实践检验代码是否有问题。&lt;/p&gt;
&lt;p&gt;实现上讲，需要通过一个机制可以快速判断一个用户是否灰度用户，可以通过本地Hash+远程定时同步的方式来做，另外是否灰度，灰度号码，或是按照号段灰度，或是全量。&lt;/p&gt;
&lt;h2 id=&#34;发布灰度&#34;&gt;发布灰度&lt;/h2&gt;
&lt;p&gt;从发布角度，因为90%以上的事故都是发布引起的，即使遵循严格发布规范，仍然可能存在隐藏的代码BUG，出现BUG或者事故不可避免，但是需要通过一系列机制保证事故的影响范围尽可能小，其中一项就是灰度发布，如果模块存在大量的机器，需要预先发布其中一台，根据风险程度进行不同时长的观察，确认无误后再逐渐扩大范围。&lt;/p&gt;
&lt;h2 id=&#34;染色运营&#34;&gt;染色运营&lt;/h2&gt;
&lt;p&gt;线上的大多数问题，都需要日志来确定原因，但是线上环境如果打印过于详细的日志，会导致性能的急剧下降，如果打印很精简又不容易查找问题，面对两难情况，一个解决办法就是使用染色号码，并不针对所有用户都打印详细的日志，只对某一些染色的号码打印详细日志，如果有用户出现问题，可以对这些号码染色，一旦复现问题，便可以轻而易举定位，同时，也不会造成系统性能下降。当然，对于一些重要服务和重要节点，全量的日志也不可避免。&lt;/p&gt;
&lt;p&gt;当然这一切都需要快速的染色号码查找和同步机制，以及灵活的配置系统所支撑，构建相应的基础设置是非常值得的。&lt;/p&gt;
&lt;h1 id=&#34;日志&#34;&gt;日志&lt;/h1&gt;
&lt;p&gt;日志的重要性不必多说，多数线上问题，以及一些对账机制，都依赖完善的日志系统，多数的日志组件，都会打印到本地，但是面对几百台机器，想检索到某个具体用户的日志流水，是比较困难的，这时就需要远程日志组件。在打印日志的同时，把某些级别或者某些用户的日志打印到远程机器，通过Web页面搜索日志，再统一某种格式，即使非模块的开发者，也可以通过阅读日志了解用户发生了什么。&lt;/p&gt;
&lt;h1 id=&#34;监控&#34;&gt;监控&lt;/h1&gt;
&lt;p&gt;监控可能多数服务都会配备，从最基本的讲，需要监控进程是否存在，机器的当前内存占用、磁盘占用、CPU占用率，这也是大多数情况需要了解的，但对于业务的监控，也是重中之重，你是否能够了解所负责服务过去一段时间每分钟所处理的最大业务包量、每天什么时间请求量最高、不同的处理接口调用比率、处理延迟数据，当依赖接口的失败率上涨、或者未知原因请求量暴涨，你是否能够第一时间感知？如果一时说不上来，这就需要在监控上多下功夫了，在业务开发过程中，需要针对业务的关键点，进行数据上报，由单独的模块汇总，绘制曲线，一定要可视化处理，运营过程中，需要根据情况调整告警阈值，设置最大值、最小值、波动、比率等告警，一旦出现异常，可以第一时间感知并处理，主动发现问题。&lt;/p&gt;
&lt;p&gt;另外在每天都需扫一遍核心数据，检查数据是否有异常，同比如何，对自己的服务做到心中有数，掌握每一个变化。&lt;/p&gt;
&lt;p&gt;实现上小米的开源监控组件&lt;a class=&#34;link&#34; href=&#34;http://open-falcon.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Open-Falcon&lt;/a&gt;是一个值得尝试的方案。&lt;/p&gt;
&lt;h1 id=&#34;柔性可用&#34;&gt;柔性可用&lt;/h1&gt;
&lt;p&gt;柔性可用也很容易被人忽略，虽然理想情况下要做到所有服务的可用性，但是在极端情况下，比如用户量超出预期的暴增、某个机房的网络被切断、大面积断电停机等，设计服务架构时，需要深刻理解用户的核心价值，在不能满足用户的所有诉求的时候，尽量满足最核心的诉求，在异常极端情况下，在不能满足所有功能的情况下，优先保证核心功能的可用性。&lt;/p&gt;
&lt;p&gt;举个例子，对于QQ的APNs推送服务，推送的消息需要用户的群名片、备注等信息，但是遇到异常没有额外的性能拉取信息，可以选择忽略这些信息，对用户来说，真正的核心诉求是收到消息的提醒，能够提供其他额外信息增强用户体验甚好，如果实在难以达到，也尽量保证推送的触答。&lt;/p&gt;
&lt;p&gt;这需要架构师对业务的核心价值有着很清晰的理解，敢于设计柔性系统。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>做最好的架构-范式和总结</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/do-best-system-design-using-paradigm/</link>
        <pubDate>Tue, 11 Jan 2011 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/do-best-system-design-using-paradigm/</guid>
        <description>&lt;h1 id=&#34;武侠中的境界&#34;&gt;武侠中的境界&lt;/h1&gt;
&lt;p&gt;《射雕英雄传》郭靖的父亲资质不高，曾说道，人一生精力是有限的，学的太多往往分心，哪样都学不好。郭靖遗传了父亲的资质和世界观，在洪七公教郭靖降龙十八掌时，也对洪七公说道，降龙十八掌很厉害，能把一样练好就行了，这句话还受到了洪七公的赞赏。不过资质平平的郭靖最终成为屈指可数的高手，真的是因为专心学习一样高深的武学么？&lt;/p&gt;
&lt;p&gt;事实却恰恰相反，郭靖武功大进是在桃花岛山洞，周伯通教授九阴真经开始，九阴真经中的武功包罗万象，如九阴白骨抓，移魂大法，大伏魔拳法，易筋锻骨等等，每种武学实际都有很大差别。后周伯通又教授了空明拳，左右互博，在洪七公、欧阳锋和黄药师比拼音律的时候又学习攻守进退之法，又经常与裘千仞欧阳锋等过招比拼，后又受一灯大师指点，内外精修方才窥视武学至高境界，成为旷世高手。&lt;/p&gt;
&lt;p&gt;不过郭靖资质平平，武学也就止于此，而杨过则更进一步，机缘下学习了林朝英和王重阳的武功，后学习了部分九阴真经，还有从小学习的蛤蟆功，后来又学了打狗棒法和东邪黄药师的武功，最后又在神雕帮助下学习了独孤求败的武学。基本上学全了当时最厉害的武学，集大成后创了黯然销魂掌，三拳五脚便干掉了老顽童等三人合力拿下的金轮法王。&lt;/p&gt;
&lt;p&gt;金庸武学中，要想窥视武学的最高境界，必须在机缘下学习很多不同的武学，相互印证，至少也需要不断跟其他高手过招。反观天下第一的王重阳教出的徒弟，虽然不至于很弱，但难以成为高手，归根结底还是因为只学习重阳宫一种武学。再看少林寺，一直成为武林至尊，在于少林本身一派就有很强的七十二种绝技，所谓他山之石可以攻玉，虽然练成多种的人很少，却能做一些参考。但七十二种每一种都不是当时顶尖的武学，所以少林靠自身的武功一直没有绝顶的高手。&lt;/p&gt;
&lt;p&gt;总结一下，要想成为一个高手，当然至少需要精通一门顶级的武学，另外还需要不断涉猎至少是需要了解其他顶级的武学，了解越多，才能相互印证自身的武学，眼界才能更上一层楼。&lt;/p&gt;
&lt;h1 id=&#34;一专多长&#34;&gt;一专多长&lt;/h1&gt;
&lt;p&gt;放到编程领域，同样需要如此。从最基本的编程语言来讲，经常在一些人简历上看到各种语言学全了，其实往往哪个都没学好，就好比爬山，一个山头爬了一半，根本不知道山顶的样子，也不知道其他山有多高，再去爬其他的山，爬了一半也以为到顶了；另外，如果精通一门语言，可以说是一个好的程序员，但如果想更进一步，还需要了解其他语言的优缺点。有一门自身喜爱并精通的语言，又可以了然其他语言的设计原则，像 lisp，erlang 等很有特色的语言，虽然不一定会用，有所了解往往能开阔自身眼界，用自己熟悉的语言时，理解会更深。&lt;/p&gt;
&lt;p&gt;又比如设计一个业务的存储系统，可能比较精通公司用的某一种很出色的存储，再去写新的存储时，当然不会写的太差，但未必会成为当时这种情况下最合适的存储。可能会有其他设计迥异但又很合适的方案，只因为自己没有见过，很难想出，即使想出来，也不如别人经过若干年的检验来的细致。&lt;/p&gt;
&lt;p&gt;程序代码的设计更是如此，GOF 总结了 23 种设计模式，就是为了使我们更快速的了解前人不同场景下合理的设计，不过也就常说的那句话，没有写过或者维护过类似的系统，是无法很好的理解设计模式的，每种模式背后都有大量的故事，总结这 23 种模式的人是牛人，学习这 23 种模式的人未必会成为牛人，其实设计模式远远不止 23 种，何止成千上万种，大量的模式需要在实践中慢慢摸索学习，不过同样的，当对某一种或者几种模式有了深刻的理解和教训，再去看其他模式，多少也能理解更加深入。&lt;/p&gt;
&lt;p&gt;所以，不论做哪方面设计，精通一种出色的设计是必须的，但同时需要尽可能了解更多更出色的设计，这样再遇到新的挑战时才能自然而然相处最合适的方案。&lt;/p&gt;
&lt;h1 id=&#34;范式&#34;&gt;范式&lt;/h1&gt;
&lt;p&gt;引用 &lt;a class=&#34;link&#34; href=&#34;http://baike.baidu.com/subview/26218/6845453.htm#viewPageContent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;百度百科&lt;/a&gt; 解释：范式（paradigm）的概念和理论是美国著名科学哲学家托马斯·库恩 (Thomas,Kuhn) 提出并在《科学革命的结构》(The Structure of Scientific Revolutions)（1962）中系统阐述的，它指的是一个共同体成员所共享的信仰、价值、技术等等的集合。指常规科学所赖以运作的理论基础和实践规范，是从事某一科学的研究者群体所共同遵从的世界观和行为方式。&lt;/p&gt;
&lt;p&gt;这个定义说的也很清楚，范式就是成熟的一些套路，遵循这些套路便能做出不错的设计，这也是走向好的架构必经的节点。比如存储设计，有如 MySQL 这种使用 B+ 树的模式，也有 leveldb 这种 LSM tree 的模式，还有 Redis 这种 Hash+dump 的方式。每种设计又有通用或者特有的一些防止数据丢失和修复的操作。精通其中之一可能会很好的完成一个新的存储设计，但同时了解其他范式，则能更加合理和全面的做出更符合需要的设计，而且通过相互之间的对比，会加深对设计的理解。&lt;/p&gt;
&lt;h1 id=&#34;世界观和方法论&#34;&gt;世界观和方法论&lt;/h1&gt;
&lt;p&gt;虽说，熟读唐诗三百首，不会作诗也会吟，当了解领域内的不同设计范式以后，还可以更进一步，归纳总结不同设计的特点，抽象自身的世界观和方法论，甚至设计更好的方案。其实世界观和方法论总体来讲比较虚，有点形而上学的意思。&lt;/p&gt;
&lt;p&gt;学习的境界就好比佛家三境界，看山是山，看水是水；看山不是山，看水不是水；看山还是山，看水还是水。就拿设计模式举例，设计模式背后的世界观和方法论就是几种设计原则，初学者看这些原则的时候，往往觉得很容易理解，这就看山是山的境界；当深入的学习设计的模式和原理以后，会发现这几种原则不是那么简单，每个都蕴含着千万的道理在其中，这就是看山不是山的境界；再学到后来，各种设计模式融会贯通，建立自己的世界观和方法论，发现其实设计也就这几种原理，无需什么模式便能做出优秀的设计，这就是看山还是山的境界了。&lt;/p&gt;
&lt;p&gt;学习的路径很漫长，但归根结底就是学习前人的范式，总结自己的方法论，先继承，再创新。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>如何阅读源代码</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/how-to-understand-open-source-code/</link>
        <pubDate>Mon, 10 Jan 2011 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/how-to-understand-open-source-code/</guid>
        <description>&lt;h1 id=&#34;为什么阅读源码&#34;&gt;为什么阅读源码&lt;/h1&gt;
&lt;p&gt;最早在学习 C++ 基本语法的时候，看到 Bjarne Stroustrup 大师在《The C++ Programming Language》一书中讲到，如何学好C++语言呢？跟学习英语相同——多看，多写。很多年过去了，身边能够做到 &amp;ldquo;多写&amp;rdquo; 的大有人在，但真正做到 &amp;ldquo;多看&amp;rdquo; 的人却凤毛麟角（这似乎很语言学习相反，大多数人学习语言都喜欢多看，不喜欢多写）。&lt;/p&gt;
&lt;p&gt;在《STL源码剖析》中，侯捷写道：源码之前，了无秘密。想要理解一个开源软件，而不去阅读源码，往往流于表面，远远谈不上深入理解。只有熟悉其源码，这款软件才算真正展示在你的面前。&lt;/p&gt;
&lt;p&gt;常言道，熟读唐诗三百首，不会作诗也会吟。通过阅读高质量的源码，能够开阔眼界，随时可以把别人优秀的设计思路引入到自己的程序当中，见多识广，写出的代码也更能经受时间的考验。&lt;/p&gt;
&lt;h1 id=&#34;源码阅读难在哪&#34;&gt;源码阅读难在哪&lt;/h1&gt;
&lt;p&gt;阅读源码既然是很重要的，那为什么大多数人不想阅读代码呢。首先，相对文学作品，阅读源码的时候需要更多的思考，即烧脑作品，但本身又很枯燥，当然这样的文学作品和电影也不少，简直让人坐立不安；另外，源码并不像电影，循序渐进的讲述一个故事，更多的是逻辑的跳转、调用等，可能一直窥一斑，无法见全豹，时间一长也便没有耐性看下去了；最后每个人都有自己的想法和思路，看代码仅仅看到的局部，难以了解整体思路，猜测别人的想法也是件痛苦的事情。&lt;/p&gt;
&lt;h1 id=&#34;阅读源码之前&#34;&gt;阅读源码之前&lt;/h1&gt;
&lt;p&gt;在阅读源码之前，尽可能的了解程序，至少应该懂得如何使用，功能是什么，怎么编译、部署、调用，这是最基本的了解，如果连这些都不清楚，直接看代码是难以快速找到切入点的。&lt;/p&gt;
&lt;p&gt;另外，如果是成熟的软件，很多人都会进行源码的分析，虽然大多数人讲解可能只是为了记录，未必适合自己，但能够方便了解代码结构和大体架构。&lt;/p&gt;
&lt;p&gt;比如，阅读Redis代码，可以参阅&lt;a class=&#34;link&#34; href=&#34;http://redisbook.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Redis 设计与实现&lt;/a&gt;，可以看到Redis模块划分比较清晰，通过 &lt;strong&gt;数据结构&lt;/strong&gt;，&lt;strong&gt;对象&lt;/strong&gt;，&lt;strong&gt;事件模型&lt;/strong&gt;，等，可以方便把Redis代码拆解成小部分，每一个部分都是独立的，这样便很容易阅读和理解。当然，很多情况下没有想尽的参考，只能一步步分析学习。&lt;/p&gt;
&lt;p&gt;另外一个需要确定的问题是，阅读源码的目的，要去参与开发，还是只是了解，是要借鉴其中某一种设计思想，还是好奇某个特性是如何实现？怀着不同的目的，方法也必然不同。类似文章阅读的精读和粗读，精读可以详尽了解某软件的实现细节，粗读可以迅速扩展视野。大多数情况下，无法做到精读，了解即可，但有时需要精读一些感兴趣的项目。&lt;/p&gt;
&lt;h1 id=&#34;代码分解&#34;&gt;代码分解&lt;/h1&gt;
&lt;p&gt;阅读代码首先要了解代码的组成结构，可以通过参考资料，文件名，初步判断文件的作用（这时就体现出来起一个好名字的作用了）。另外可以看一下头文件，通过类名，函数名，大致了解一下，有些可能不知其可，但没有关系，能猜多少算多少。&lt;/p&gt;
&lt;p&gt;接下来有两种方式，一个是能判断出来文件或类的作用，而且比较独立，精读的话可以先把独立的部分看懂，粗读的话至少需要看一遍主要接口的实现，然后分离出去，这部分代码就不会影响以后的阅读。比如Redis的集中数据结构，字符串，list等，都可以分离出来。&lt;/p&gt;
&lt;p&gt;在阅读源码过程中，一定要重视&lt;strong&gt;接口&lt;/strong&gt;的作用，可能一时不大了解实现，但没关系，只要看懂了接口，这部分代码就可以先略过去，不影响以后的阅读。接口是代码之间的粘合剂，通过合理的分离接口，便能把代码分解成不同功能的部分，这也是代码架构必须考虑的问题。只要能够把代码分解，阅读代码便会很轻松了。当然，项目架构过程中，能够合理的把代码分解，也是项目成功的必要因素。&lt;/p&gt;
&lt;p&gt;当然，有时一些有趣的功能，虽然能够分解，但接口使用等等不易理解。一个好的方法就是为这些代码写一些测试程序，尝试通过接口去使用这些代码，便能深刻了解这些接口的含义，当然这需要耗费一些时间，但对理解代码是值得的。比如，Redis的事件驱动，通过尝试写&lt;a class=&#34;link&#34; href=&#34;https://drawing.fancymore.com/reading/source-analysis-redis-event-model.html&#34; &gt;测试代码&lt;/a&gt;，能够快速掌握接口的使用，因为更为熟练，所以在后续的源码阅读过程中，也会感觉更清晰。不管是对某个接口，某个模块，还是对整个项目，熟练使用对代码的理解意义非常大。&lt;/p&gt;
&lt;h1 id=&#34;骨架&#34;&gt;骨架&lt;/h1&gt;
&lt;p&gt;对于一个网络Server，网络事件处理框架，往往就是这个项目的骨架。对于存储，数据结构往往是个关键，每个程序都有最核心的代码，通过熟悉其使用，猜测核心部分，然后再通过入口，增加日志等等，找到实现原理，再剥离这部分，往更深一层探索。掌握一个项目的骨架，即使很多没看过的地方，也很容易找到对应功能的代码。&lt;/p&gt;
&lt;h1 id=&#34;善于动手&#34;&gt;善于动手&lt;/h1&gt;
&lt;p&gt;不管是自己负责的项目，还是一些开源项目，如果只是看，即使看的很熟练，往往也是有个模糊的印象，但如果出现一个bug让自己去改，带着这个问题，往往比较容易快速的了解相关的代码。所以，带着一个问题去阅读，往往能起到事半功倍的效果。&lt;/p&gt;
&lt;p&gt;对于开源项目，可能没有那么多修改的机会（但也可以尝试去查看官网的Bug列表，挑一些简单的练手）。可以自己尝试做一些修改，包括写一些接口测试代码，尝试修改成一种奇怪又有趣的运行方式，比如阅读Linux进程代码，可以尝试写一个简单的进程调度算法，或者如果出现某个进程，强制执行完成等等。尝试一些类似Hacker的工作，既有趣又能很深刻的掌握相关代码，也是一些可以尝试的方法。&lt;/p&gt;
&lt;p&gt;另外，执行过程中进行调试，或者增加一些日志，也是很好的弄懂某个问题的方法。总之一句话，要动手去改，才能发现真实的项目。&lt;/p&gt;
&lt;h1 id=&#34;善于总结&#34;&gt;善于总结&lt;/h1&gt;
&lt;p&gt;代码阅读完成，可能一段时间便会遗忘，所以要做一些总结和分享，一个有效的方法就是绘制UML图，画一些类图，以及相互之间的关系，画一些时序图，记录代码运行过程。像Redis虽然是c实现，但其中也尽是面向对象方法，不难用UML绘制。另外一项就是分享，可以写一些博客，或者面对面分享，在相互交流中很可能想到之前一直没有想过的问题。&lt;/p&gt;
&lt;p&gt;另外，很多开源的项目有着类似的架构和设计思想，通过提炼总结，下次阅读代码时，会更加有效的找到自己想要了解的部分，以及一个功能最应该考虑的部分是什么，比如自己曾经写过或者读过一个网络框架程序，再次遇到类似程序，可以把之前项目中一些不是很清楚的，或者性能的瓶颈，或者实现不优雅的部分，对应到当前项目中，相互对比学习，也能更快的掌握代码的核心。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>大并发程序设计的思考</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/large-concurrent-software-design/</link>
        <pubDate>Sun, 09 Jan 2011 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/large-concurrent-software-design/</guid>
        <description>&lt;p&gt;之前设计 VPN 大并发时候，第一次听到大并发的时候，心头一片迷茫，不知道如何设计才算是大并发的，网上找了很多资料，基本都没有对此进行过详细的说明，可能需要一些经验，或者阅读更为出色的代码才能得知，但在大并发 VPN 的设计当中，我总结了很多，当然，这些东西并非是一个准则，我对这个方面也只是初学而已，只是记录一些心得，使自己学到的东西更为系统，也方便日后阅读其他优秀设计的时候参照，不论方法是对是错，总得有个自己的感悟。&lt;/p&gt;
&lt;p&gt;在我设计的时候，第一个问题就是什么是大并发？其实这个概念很简单，就是同一时间能够响应尽可能多的用户，比如同时在线用户为 1w 人，如果并发性不足，可能后 5k 人就直接被拒绝掉了。对于 UDP 来说，如果你的线程正在处理其他数据，而没有即时的调用 recvfrom，很容易致使 UDP 内核缓冲区满，再有新的数据包将会被无情的丢弃，这样会导致后来的 5k 人所发的 UDP 包很容易丢失以致无法连接。而对于 TCP 来讲，如果没有及时 accept，连接将会丢失。&lt;/p&gt;
&lt;p&gt;如此一来，对于 TCP 来讲，只要单独分出一个线程拼命 accept 和收取数据，增加并发数不成问题；对于 UDP 应用，也是分离出线程拼命调用 recvfrom，把数据先缓存到用户态，也能够增加并发。但随之而来会有一个新问题，如何处理数据，如果处理不过来，那虽然接受下来也无济于事，仍然需要客户端无止境的等待，所以这里又涉及到一个吞吐量的问题。如何快速的处理数据。如果能够尽可能多的接受连接而又能尽可能快的处理数据，增加并发量将会是水到渠成的。可以把接受数据部分称为前端，处理数据称为后端，前端直接决定并发量，后端决定吞吐量，当然二者是有相当大的关联性的。&lt;/p&gt;
&lt;p&gt;其实说了半天，只是理论上这样，如何实现还需针对具体情况，但这个可以当做一个指导方针，对于收取连接而言，linux 下可以使用 epoll 模型，windows 下可以使用 iocp 模型，都可以最大限度的接受连接，当然这里需要注意的是不要把耗时的操作放到这里，比如收取到数据以后，放入队列，而处理数据线程取队列中的数据，这个过程不能造成频繁的竞态，否则会损失前端接受数据的性能。&lt;/p&gt;
&lt;p&gt;至于后端而言，提高效率需要理解处理流程中的瓶颈。&lt;/p&gt;
&lt;p&gt;首先不能开启太多的线程，如果使用最简单的多线程模型，一个链接上来开启一个线程处理，似乎很高校，但由于系统需要不断的切换如此多的线程，切换线程时需要保存源线程环境，恢复目标线程环境，是一个相当耗时的操作，如果需要相应 1w 并发，使用 1w 甚至 5k 线程处理是相当不明智的做法。理论上讲，如果有 2 个 cpu，使用 2 个线程，一个 cpu 处理一个线程，不进行切换最为高效，不过由于进行处理数据不是时刻需要使用 cpu，比如读文件或数据库，将可能会有系统等待发生，一个线程不可能跑满整个 cpu，所以适当的提高线程数，尽可能多的压榨 cpu 的每一点性能。&lt;/p&gt;
&lt;p&gt;而且在处理数据的过程中，尽可能不要出现长时间等待的状况，比如某个非常耗时的系统调用。这里的等待，也包括线程之间的竞态，如果所有的线程都需要从一个核心 data 中读写数据，可能读写这个数据时需要互斥，这样可能会造成很多线程等待同一个数据的读写，这种情况线程多了反而效果不佳，需要考虑调整程序的整体结构，尽可能的消除线程间的竞态。争取分离消耗 cpu 而且计算过程互不侵犯的部分为多线程，比如对数据包的加解密过程。&lt;/p&gt;
&lt;p&gt;另外一个效率消耗在于内存管理，对 VPN 而言，每个用户的 IP 包过来都需要为之创建一个存储单元，如果对于每一个数据包的传递过程都多一次复制，那复制的代价是非常可观的。而且对于通用的 malloc 而言，需要兼顾各种情况，对于某一个具体应用，效率并非很高，比如如果传递的数据都是定长的，可以实现分配一定量的空间串成链表，这样分配和释放都只需要几次有限的操作便可，效率比之 malloc 提升很多，这里对于 IP 包数据而言，由于需要经过分片，所以长度限制在 1500 左右，适当的分配一个定长的大空间虽然会造成一写空间的浪费，但却用空间换取了时间上的优势。&lt;/p&gt;
&lt;p&gt;另外一个值得注意的问题就是内存碎片，对于一个需要运行几年的服务器程序而言，看似微小的碎片，会逐渐造成大量不可用内存。所以一般需要长时间运行的程序都会自己实现特定情形的内存管理，尽量减少内存碎片的产生，他的危害虽然不如内存泄露严重，但却非常不易防止。&lt;/p&gt;
&lt;p&gt;对于具体实现会有具体的效率提升方式，不过通用的方法就是理解程序运行流程，分离出耗时不耗时的操作，哪里的代码可以并发运行，哪里的代码只需要单线程便可，整个程序的瓶颈在哪等等。尽量减少等待，减少锁竞态，减少内存复制，前端可以尽可能多的接受连接，后端可以尽可能快的处理数据，使用 epoll 或者异步模型处理等待事件，便可很大限度的增加并发访问。&lt;/p&gt;
&lt;p&gt;对于大并发的程序，还有一个重要的方面就是测试，不要相信测试人员会对你的程序做出一个合理的评判，性能真正的展现在于在真实环境中运行，大量用户访问的时候。在开发过程中需要考虑的问题便是如何进行测试，只有能够尽可能真实的模拟应用环境，才能让开发者了解自己程序的性能，从而不断的调整，这些测试数据直接成为修改程序流程或者构架的理由，除非对此经验丰富，否则不要去想当然的以为程序将会怎样，真实的数据才是唯一的性能标准。&lt;/p&gt;
&lt;p&gt;而且测试过程中的现象直接成为改进程序的理由，如果在访问极限的时候，CPU 还未层充分利用，则可能程序过多挂起在等待过程中，就要通过现象思考等待在何处，哪里成为性能瓶颈，从而为增加 IO 缓存、提高网卡性能指标等等提供依据。当然这个过程也是非常复杂而不易把握的。同样需要经验和对处理过程的充分理解，还需依据合理的代码设计。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>指令队列设计</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/message-queue-development/</link>
        <pubDate>Sat, 20 Nov 2010 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/message-queue-development/</guid>
        <description>&lt;p&gt;最近有时间赶紧开始NC项目的开发，今天刚写到指令队列的处理，我的最初的设计是让整个VPN系统能够自动运转，分多个线程不断的处理数据，类似流水线工厂，外界通过压入数据包供处理线程加解密，或者压入指令包，处理线程识别并且执行，方便服务器客户端之间互相控制，也可在本地直接压入指令包控制，当时觉得这种设计是非常和谐的，而现在看来这样虽然能让系统更易扩展，但却不利于即时控制。&lt;/p&gt;
&lt;p&gt;这种方法给我的感觉是我无法接触核心的控制，外界只是简单的send几个指令包而已，对外界调用是方便很多，而且扩展性更强，不过有种拿不住核心的感觉，调用send指令包函数返回，所要执行的功能并未立即实现，而是有一定的延时性，这种延时性会造成几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统反应迟钝，因为不是函数返回就会即时生效，而且甚至都不知道何时开始生效；&lt;/li&gt;
&lt;li&gt;如果执行功能出错，虽然有重试机制，但不可预知的错误随时可能发生，最终结果如何也未可知；&lt;/li&gt;
&lt;li&gt;增加了系统的不可预知性，因为有延时存在，如果同时执行若干命令，相互之间是否会有影响；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，这样处理的优点就是简洁性，所有事件的处理过程都经过统一的分发处理，像一个命令处理工厂，不断的接受命令，执行命令即可，不用抽取各种操作接口，命令本身也更易扩展，而且不用区分是本地指令还是服务器指令或者客户端之间点对点协议，想来这种设计的优点还是大于缺点的，要看如何处理各种让人纠结的问题了。现在感觉项目处于悬浮状态，是易扩展还是易崩溃，就得看这里的实现如何了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>软件设计的思考</title>
        <link>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/thinking-of-software-design/</link>
        <pubDate>Fri, 05 Nov 2010 22:50:04 +0800</pubDate>
        
        <guid>https://drawing.fancymore.com/posts/program/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/thinking-of-software-design/</guid>
        <description>&lt;p&gt;最近回想之前写烂的程序，对软件设计方式进行了一些思考，经历了迷茫的过度之后，多少也有了一些认识，不管认识是否正确，人总是在思考中前进的。引用毕加索的话：画乃我思所获，非我见所得。&lt;/p&gt;
&lt;p&gt;之前一家公司项目经理极度强调设计，他所言都是书上所讲，我无法辩驳，况且关注软件设计并不能说是坏事，但现今回想，感觉他所说的理论都过于理论，照本宣科而已，我不知道他是否有过成功或者失败的大型项目设计经验。软件的设计是一门实践课，不是读书能学来的能力。&lt;/p&gt;
&lt;p&gt;关于面向对象，从开始学习面向对象开始，就被java的一切皆对象的思想误导了，c++不是java。所谓的面向过程还是面向对象，为了解决软件危机而引出的，但谁也不会认为一个扫雷的程序会引发软件危机，所以系统级别的面向对象才是真的面向对象，比如Linux内核，一切皆文件的思想，谁也不能否认这是非常完美的面向对象思想，可Linux内核全部用c语言实现，并没有一个C++所谓的“类”存在。所以正如软件工程所强调的，面向对象仅仅是一种思想，而不是某个具体的实现，如果写扫雷的时候其中充斥着面向对象，弄的一切皆对象，反而违背了面向对象的真正含义，这种面向对象的经验也不能用于大型项目。&lt;/p&gt;
&lt;p&gt;之前公司的项目为了隔离ICE，几乎把每个应该是结构的地方都弄成了类，不止于此，还把每个这样的类抽象出接口，几乎一个存储操作也得走好几个接口才可实现，类过于繁杂，层次过深。虽然其中每个地方都符合软件设计的规范，也符合设计模式，但这简直是对面向对象的滥用，再好的理论也不能防止人滥用。&lt;/p&gt;
&lt;p&gt;软件工程是一门大开大合的理论，为了解决软件生产随规模增大复杂度增大的问题，目的为了大规模项目具有可控性，犹如关羽的大刀，只有恢弘的战场上才可展现其威力，而对于被大刀划分出来的细微模块，犹豫巷战，还不如匕首来的轻巧，巷战时使用大刀，无非是自我束缚。一直在想，程序中没有类，没有继承，没有多态，那程序是不是就一定不是面向对象了呢？类似面向对象这种软件工程思想，类似于从战局上把握全局，而具体每一个功能实现，都是小小的战斗，战斗和战略本是两种不同的理论，能够从战略上做出很好决策的不一定也适用于战斗（失街亭的马谡就是个例子^_^）。所以把面向对象、各种设计模式用于某一个结构体的实现，完全是对软件工程的曲解。软件工程不是写几个小程序就能领悟得了的，如果有人给你讲面向对象，你先问他，设计过近百万行的项目么？&lt;/p&gt;
&lt;p&gt;所以在全局上使用软件工程的相关理论把握项目不能失控，在某一细微功能实现上，应该尽力保持简洁，5行的代码远比50行的容易维护，不管你使用什么高深的理论都是如此。从细小的代码上应用“一切皆对象”，代码量将为了这些设施成倍增长，为后来人的维护造成极大的麻烦，但若从全局上划分面向对象，仅仅是一种划分方式，并不会对代码量造成多大影响，我想，这才符合软件工程的初衷，也符合“简单即完美”。Unix和Linux秉承这一思想，影响至今。&lt;/p&gt;
&lt;p&gt;再来讨论C++这门语言，首先这门语言非常复杂，是对智力的考验，有些语法非常出色，极大简化了程序开发，但是他所造成的结果并不如他所期待的那样，C++是为了大型软件所设计的，开发小规模项目并不见得轻松，而大型软件所使用的面向对象却应是全局的划分，而C++却是从最细小的地方提供面向对象的语法支持，这不是与软件工程相违背么！而且C++这种机制还容易误导人们从最小的地方使用类的思想，而且，C++提供的机制是为了让防止别人滥用类，提供了一些私有机制，不过这种机制越来越复杂，反而更容易让人滥用。还是那句话，多好的理论和多好的机制都不能防止别人滥用，会C++语法的人很多，但是最终懂面向对象的人很少，滥用的人越来越多，这就是最好的证明，C++的各种语法都不能促人做出更好的设计！！！&lt;/p&gt;
&lt;p&gt;而且C++一些看似很自动化的语法，恰恰使人麻痹，相反使用c虽然得自己“手工处理”，但却能警醒人们更加合理的使用。无怪乎Linux内核好几百万的代码全部使用纯c来开发，仍然保持着近乎完美的设计！c够轻巧也更不容易滥用。这里倒不是说哪种语言更好，只是说软件设计的思想。&lt;/p&gt;
&lt;p&gt;再说局部开发的goto，任何教科书上都讲，不可使用goto，似乎每个人都有这样的意识不去用goto，但存在即合理，在c函数中如果有多处返回的错误处理部分，goto恰恰使代码更为简洁合理，这是goto的正确用法之一，如果不滥用goto，它能使代码更为清晰，比之前项目经理所说的do {} while(false) 更加合理，所以照本宣科的去学用什么不用什么，而不去想这么做的目的，将会带领项目最终走向地狱。在局部编码中，一切规则都是为了让人易懂易改，一切与之违背的即使经典理论也应摒弃。&lt;/p&gt;
&lt;p&gt;在前项目经理推荐阅读《代码大全》，其中类和接口设计部分所言，类继承不可超过三层！否则徒增复杂度，他没有阅读此书么？&lt;/p&gt;
&lt;p&gt;另外还有一些编码规范的解释，不过这点虽然重要但不是关键，最好的编码规范也不能保证你的代码易于理解（但最烂的规范却必定能使你的代码不能理解）。代码容不容易理解关键要看代码的组织方式，能不能达到“自说明”的程度。乍一看有板有眼但不能理解的代码比比皆是，无论做什么，都只有一个目的，让读代码的人“易读易改”。&lt;/p&gt;
&lt;p&gt;最后感谢两个说我代码烂的人，第一个人说的很对，代码很烂，我自己都读不懂了，我也在迷茫思考，不过别人看不懂在于设计，那么复杂的设计即使我能写出来别人也不容易看懂，设计不是我的，我也没有太负责的去纠正这些，导致代码烂有多方面因素，我后来已经思考。但另一个说我代码烂的人，我也承认代码写的不好，因为我正在转型，但是他承认我的代码一眼就能看懂，也非常容易改，那还要奢求什么呢？难道非得如他一般一个小问题都继承多态扩增好几倍的代码量别人都不懂才算写的好么？请尊重软件工程，不要滥用。&lt;/p&gt;
&lt;p&gt;另外，NC大并发是我第一个设计的项目，一天未离开公司，我都会根据我所体会到的经验，修正之前的设计以达完美，自己能够掌控一个项目，应该说是比较幸福的事情，也应为这个项目负全责！&lt;/p&gt;
&lt;p&gt;有些东西，看过不如改过，改过不如写过。一个项目总是看但不参与修改，也只能懂个皮毛，修修改改对一些细节理解的比较清楚，如果一直参与开发项目，得到东西就会很多。一个项目在初期或者重构期，总是能很学到最多的东西；一旦这个项目成型，需要改改Bug，这时参与进去的人便不会学到很多构架方面的东西了；当项目已经完成，这时参与进去的开发人员学到的东西便少的可怜了。&lt;/p&gt;
&lt;p&gt;当然不能否认，看一些优秀的代码也能学到很多东西，但往往这些东西不会对自己造成深刻的影响，除非自己曾经已经构建过相似的东西，以此引起共鸣，比如有apache经验再去看nginx，可以在很短的时间领悟其精髓。每次看开源的代码，都在想，如果看完了，抛弃这些东西，让我从头去写一个类似的东西，我能够完全构建出来么？开源软件看的比较多的除了以前工作中需要用的openvpn，就是nginx了，看过以后对它的架构有一定的感悟，但让我重写一个，想想都有点发怵，即使再多看几遍，照猫画虎的仿出来，也不明白为什么这么写比较好，为什么就不能用其他方法么，我只能看到作者的重点，却看不到作者所走的弯路。这也就是为什么代码只是项目的一部分，另一部分在于代码的演进，而人往往能看到代码的价值，却忽略代码演进的价值。代码可以很容易看到，代码演进即使有svn，git版本维护，也难让人理解精髓，这里的演进就是一个人的经验所在了。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
